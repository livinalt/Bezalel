module.exports = [
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['contexts'].AppRouterContext; //# sourceMappingURL=app-router-context.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['contexts'].HooksClientContext; //# sourceMappingURL=hooks-client-context.js.map
}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getSegmentValue", {
    enumerable: true,
    get: function() {
        return getSegmentValue;
    }
});
function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-segment-value.js.map
}),
"[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DEFAULT_SEGMENT_KEY: null,
    PAGE_SEGMENT_KEY: null,
    addSearchParamsIfPageSegment: null,
    isGroupSegment: null,
    isParallelRouteSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_SEGMENT_KEY: function() {
        return DEFAULT_SEGMENT_KEY;
    },
    PAGE_SEGMENT_KEY: function() {
        return PAGE_SEGMENT_KEY;
    },
    addSearchParamsIfPageSegment: function() {
        return addSearchParamsIfPageSegment;
    },
    isGroupSegment: function() {
        return isGroupSegment;
    },
    isParallelRouteSegment: function() {
        return isParallelRouteSegment;
    }
});
function isGroupSegment(segment) {
    // Use array[0] for performant purpose
    return segment[0] === '(' && segment.endsWith(')');
}
function isParallelRouteSegment(segment) {
    return segment.startsWith('@') && segment !== '@children';
}
function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;
    }
    return segment;
}
const PAGE_SEGMENT_KEY = '__PAGE__';
const DEFAULT_SEGMENT_KEY = '__DEFAULT__'; //# sourceMappingURL=segment.js.map
}),
"[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RedirectStatusCode", {
    enumerable: true,
    get: function() {
        return RedirectStatusCode;
    }
});
var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {
    RedirectStatusCode[RedirectStatusCode["SeeOther"] = 303] = "SeeOther";
    RedirectStatusCode[RedirectStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    RedirectStatusCode[RedirectStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    return RedirectStatusCode;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-status-code.js.map
}),
"[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    REDIRECT_ERROR_CODE: null,
    RedirectType: null,
    isRedirectError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    REDIRECT_ERROR_CODE: function() {
        return REDIRECT_ERROR_CODE;
    },
    RedirectType: function() {
        return RedirectType;
    },
    isRedirectError: function() {
        return isRedirectError;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)");
const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';
var RedirectType = /*#__PURE__*/ function(RedirectType) {
    RedirectType["push"] = "push";
    RedirectType["replace"] = "replace";
    return RedirectType;
}({});
function isRedirectError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const digest = error.digest.split(';');
    const [errorCode, type] = digest;
    const destination = digest.slice(2, -2).join(';');
    const status = digest.at(-2);
    const statusCode = Number(status);
    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-error.js.map
}),
"[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getRedirectError: null,
    getRedirectStatusCodeFromError: null,
    getRedirectTypeFromError: null,
    getURLFromRedirectError: null,
    permanentRedirect: null,
    redirect: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getRedirectError: function() {
        return getRedirectError;
    },
    getRedirectStatusCodeFromError: function() {
        return getRedirectStatusCodeFromError;
    },
    getRedirectTypeFromError: function() {
        return getRedirectTypeFromError;
    },
    getURLFromRedirectError: function() {
        return getURLFromRedirectError;
    },
    permanentRedirect: function() {
        return permanentRedirect;
    },
    redirect: function() {
        return redirect;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const actionAsyncStorage = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)").actionAsyncStorage : "TURBOPACK unreachable";
function getRedirectError(url, type, statusCode) {
    if (statusCode === void 0) statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;
    const error = Object.defineProperty(new Error(_redirecterror.REDIRECT_ERROR_CODE), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = _redirecterror.REDIRECT_ERROR_CODE + ";" + type + ";" + url + ";" + statusCode + ";";
    return error;
}
function redirect(/** The URL to redirect to */ url, type) {
    var _actionAsyncStorage_getStore;
    type != null ? type : type = (actionAsyncStorage == null ? void 0 : (_actionAsyncStorage_getStore = actionAsyncStorage.getStore()) == null ? void 0 : _actionAsyncStorage_getStore.isAction) ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);
}
function permanentRedirect(/** The URL to redirect to */ url, type) {
    if (type === void 0) type = _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);
}
function getURLFromRedirectError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) return null;
    // Slices off the beginning of the digest that contains the code and the
    // separating ';'.
    return error.digest.split(';').slice(2, -2).join(';');
}
function getRedirectTypeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return error.digest.split(';', 2)[1];
}
function getRedirectStatusCodeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return Number(error.digest.split(';').at(-2));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect.js.map
}),
"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTTPAccessErrorStatus: null,
    HTTP_ERROR_FALLBACK_ERROR_CODE: null,
    getAccessFallbackErrorTypeByStatus: null,
    getAccessFallbackHTTPStatus: null,
    isHTTPAccessFallbackError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTTPAccessErrorStatus: function() {
        return HTTPAccessErrorStatus;
    },
    HTTP_ERROR_FALLBACK_ERROR_CODE: function() {
        return HTTP_ERROR_FALLBACK_ERROR_CODE;
    },
    getAccessFallbackErrorTypeByStatus: function() {
        return getAccessFallbackErrorTypeByStatus;
    },
    getAccessFallbackHTTPStatus: function() {
        return getAccessFallbackHTTPStatus;
    },
    isHTTPAccessFallbackError: function() {
        return isHTTPAccessFallbackError;
    }
});
const HTTPAccessErrorStatus = {
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    UNAUTHORIZED: 401
};
const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));
const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';
function isHTTPAccessFallbackError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const [prefix, httpStatus] = error.digest.split(';');
    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));
}
function getAccessFallbackHTTPStatus(error) {
    const httpStatus = error.digest.split(';')[1];
    return Number(httpStatus);
}
function getAccessFallbackErrorTypeByStatus(status) {
    switch(status){
        case 401:
            return 'unauthorized';
        case 403:
            return 'forbidden';
        case 404:
            return 'not-found';
        default:
            return;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=http-access-fallback.js.map
}),
"[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "notFound", {
    enumerable: true,
    get: function() {
        return notFound;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
/**
 * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)
 * within a route segment as well as inject a tag.
 *
 * `notFound()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * - In a Server Component, this will insert a `<meta name="robots" content="noindex" />` meta tag and set the status code to 404.
 * - In a Route Handler or Server Action, it will serve a 404 to the caller.
 *
 * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";404";
function notFound() {
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found.js.map
}),
"[project]/node_modules/next/dist/client/components/forbidden.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "forbidden", {
    enumerable: true,
    get: function() {
        return forbidden;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
// TODO: Add `forbidden` docs
/**
 * @experimental
 * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)
 * within a route segment as well as inject a tag.
 *
 * `forbidden()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";403";
function forbidden() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`forbidden()` is experimental and only allowed to be enabled when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E488",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forbidden.js.map
}),
"[project]/node_modules/next/dist/client/components/unauthorized.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unauthorized", {
    enumerable: true,
    get: function() {
        return unauthorized;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
// TODO: Add `unauthorized` docs
/**
 * @experimental
 * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)
 * within a route segment as well as inject a tag.
 *
 * `unauthorized()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 *
 * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";401";
function unauthorized() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E411",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unauthorized.js.map
}),
"[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isHangingPromiseRejectionError: null,
    makeDevtoolsIOAwarePromise: null,
    makeHangingPromise: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isHangingPromiseRejectionError: function() {
        return isHangingPromiseRejectionError;
    },
    makeDevtoolsIOAwarePromise: function() {
        return makeDevtoolsIOAwarePromise;
    },
    makeHangingPromise: function() {
        return makeHangingPromise;
    }
});
function isHangingPromiseRejectionError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === HANGING_PROMISE_REJECTION;
}
const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
class HangingPromiseRejectionError extends Error {
    constructor(route, expression){
        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route "${route}".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;
    }
}
const abortListenersBySignal = new WeakMap();
function makeHangingPromise(signal, route, expression) {
    if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(route, expression));
    } else {
        const hangingPromise = new Promise((_, reject)=>{
            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));
            let currentListeners = abortListenersBySignal.get(signal);
            if (currentListeners) {
                currentListeners.push(boundRejection);
            } else {
                const listeners = [
                    boundRejection
                ];
                abortListenersBySignal.set(signal, listeners);
                signal.addEventListener('abort', ()=>{
                    for(let i = 0; i < listeners.length; i++){
                        listeners[i]();
                    }
                }, {
                    once: true
                });
            }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
    }
}
function ignoreReject() {}
function makeDevtoolsIOAwarePromise(underlying) {
    // in React DevTools if we resolve in a setTimeout we will observe
    // the promise resolution as something that can suspend a boundary or root.
    return new Promise((resolve)=>{
        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.
        setTimeout(()=>{
            resolve(underlying);
        }, 0);
    });
} //# sourceMappingURL=dynamic-rendering-utils.js.map
}),
"[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isPostpone", {
    enumerable: true,
    get: function() {
        return isPostpone;
    }
});
const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
function isPostpone(error) {
    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;
} //# sourceMappingURL=is-postpone.js.map
}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This has to be a shared module which is shared between client component error boundary and dynamic component
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    BailoutToCSRError: null,
    isBailoutToCSRError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BailoutToCSRError: function() {
        return BailoutToCSRError;
    },
    isBailoutToCSRError: function() {
        return isBailoutToCSRError;
    }
});
const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
class BailoutToCSRError extends Error {
    constructor(reason){
        super("Bail out to client-side rendering: " + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;
    }
}
function isBailoutToCSRError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === BAILOUT_TO_CSR;
} //# sourceMappingURL=bailout-to-csr.js.map
}),
"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isNextRouterError", {
    enumerable: true,
    get: function() {
        return isNextRouterError;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
function isNextRouterError(error) {
    return (0, _redirecterror.isRedirectError)(error) || (0, _httpaccessfallback.isHTTPAccessFallbackError)(error);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=is-next-router-error.js.map
}),
"[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DynamicServerError: null,
    isDynamicServerError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DynamicServerError: function() {
        return DynamicServerError;
    },
    isDynamicServerError: function() {
        return isDynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';
class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;
    }
}
function isDynamicServerError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hooks-server-context.js.map
}),
"[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    StaticGenBailoutError: null,
    isStaticGenBailoutError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    StaticGenBailoutError: function() {
        return StaticGenBailoutError;
    },
    isStaticGenBailoutError: function() {
        return isStaticGenBailoutError;
    }
});
const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;
    }
}
function isStaticGenBailoutError(error) {
    if (typeof error !== 'object' || error === null || !('code' in error)) {
        return false;
    }
    return error.code === NEXT_STATIC_GEN_BAILOUT;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-bailout.js.map
}),
"[project]/node_modules/next/dist/lib/framework/boundary-constants.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    METADATA_BOUNDARY_NAME: null,
    OUTLET_BOUNDARY_NAME: null,
    ROOT_LAYOUT_BOUNDARY_NAME: null,
    VIEWPORT_BOUNDARY_NAME: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    METADATA_BOUNDARY_NAME: function() {
        return METADATA_BOUNDARY_NAME;
    },
    OUTLET_BOUNDARY_NAME: function() {
        return OUTLET_BOUNDARY_NAME;
    },
    ROOT_LAYOUT_BOUNDARY_NAME: function() {
        return ROOT_LAYOUT_BOUNDARY_NAME;
    },
    VIEWPORT_BOUNDARY_NAME: function() {
        return VIEWPORT_BOUNDARY_NAME;
    }
});
const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';
const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'; //# sourceMappingURL=boundary-constants.js.map
}),
"[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    atLeastOneTask: null,
    scheduleImmediate: null,
    scheduleOnNextTick: null,
    waitAtLeastOneReactRenderTask: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    atLeastOneTask: function() {
        return atLeastOneTask;
    },
    scheduleImmediate: function() {
        return scheduleImmediate;
    },
    scheduleOnNextTick: function() {
        return scheduleOnNextTick;
    },
    waitAtLeastOneReactRenderTask: function() {
        return waitAtLeastOneReactRenderTask;
    }
});
const scheduleOnNextTick = (cb)=>{
    // We use Promise.resolve().then() here so that the operation is scheduled at
    // the end of the promise job queue, we then add it to the next process tick
    // to ensure it's evaluated afterwards.
    //
    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
    //
    Promise.resolve().then(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            process.nextTick(cb);
        }
    });
};
const scheduleImmediate = (cb)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        setImmediate(cb);
    }
};
function atLeastOneTask() {
    return new Promise((resolve)=>scheduleImmediate(resolve));
}
function waitAtLeastOneReactRenderTask() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return new Promise((r)=>setImmediate(r));
    }
} //# sourceMappingURL=scheduler.js.map
}),
"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "InvariantError", {
    enumerable: true,
    get: function() {
        return InvariantError;
    }
});
class InvariantError extends Error {
    constructor(message, options){
        super("Invariant: " + (message.endsWith('.') ? message : message + '.') + " This is a bug in Next.js.", options);
        this.name = 'InvariantError';
    }
} //# sourceMappingURL=invariant-error.js.map
}),
"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    Postpone: null,
    PreludeState: null,
    abortAndThrowOnSynchronousRequestDataAccess: null,
    abortOnSynchronousPlatformIOAccess: null,
    accessedDynamicData: null,
    annotateDynamicAccess: null,
    consumeDynamicAccess: null,
    createDynamicTrackingState: null,
    createDynamicValidationState: null,
    createHangingInputAbortSignal: null,
    createRenderInBrowserAbortSignal: null,
    delayUntilRuntimeStage: null,
    formatDynamicAPIAccesses: null,
    getFirstDynamicReason: null,
    isDynamicPostpone: null,
    isPrerenderInterruptedError: null,
    logDisallowedDynamicError: null,
    markCurrentScopeAsDynamic: null,
    postponeWithTracking: null,
    throwIfDisallowedDynamic: null,
    throwToInterruptStaticGeneration: null,
    trackAllowedDynamicAccess: null,
    trackDynamicDataInDynamicRender: null,
    trackSynchronousPlatformIOAccessInDev: null,
    trackSynchronousRequestDataAccessInDev: null,
    useDynamicRouteParams: null,
    warnOnSyncDynamicError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Postpone: function() {
        return Postpone;
    },
    PreludeState: function() {
        return PreludeState;
    },
    abortAndThrowOnSynchronousRequestDataAccess: function() {
        return abortAndThrowOnSynchronousRequestDataAccess;
    },
    abortOnSynchronousPlatformIOAccess: function() {
        return abortOnSynchronousPlatformIOAccess;
    },
    accessedDynamicData: function() {
        return accessedDynamicData;
    },
    annotateDynamicAccess: function() {
        return annotateDynamicAccess;
    },
    consumeDynamicAccess: function() {
        return consumeDynamicAccess;
    },
    createDynamicTrackingState: function() {
        return createDynamicTrackingState;
    },
    createDynamicValidationState: function() {
        return createDynamicValidationState;
    },
    createHangingInputAbortSignal: function() {
        return createHangingInputAbortSignal;
    },
    createRenderInBrowserAbortSignal: function() {
        return createRenderInBrowserAbortSignal;
    },
    delayUntilRuntimeStage: function() {
        return delayUntilRuntimeStage;
    },
    formatDynamicAPIAccesses: function() {
        return formatDynamicAPIAccesses;
    },
    getFirstDynamicReason: function() {
        return getFirstDynamicReason;
    },
    isDynamicPostpone: function() {
        return isDynamicPostpone;
    },
    isPrerenderInterruptedError: function() {
        return isPrerenderInterruptedError;
    },
    logDisallowedDynamicError: function() {
        return logDisallowedDynamicError;
    },
    markCurrentScopeAsDynamic: function() {
        return markCurrentScopeAsDynamic;
    },
    postponeWithTracking: function() {
        return postponeWithTracking;
    },
    throwIfDisallowedDynamic: function() {
        return throwIfDisallowedDynamic;
    },
    throwToInterruptStaticGeneration: function() {
        return throwToInterruptStaticGeneration;
    },
    trackAllowedDynamicAccess: function() {
        return trackAllowedDynamicAccess;
    },
    trackDynamicDataInDynamicRender: function() {
        return trackDynamicDataInDynamicRender;
    },
    trackSynchronousPlatformIOAccessInDev: function() {
        return trackSynchronousPlatformIOAccessInDev;
    },
    trackSynchronousRequestDataAccessInDev: function() {
        return trackSynchronousRequestDataAccessInDev;
    },
    useDynamicRouteParams: function() {
        return useDynamicRouteParams;
    },
    warnOnSyncDynamicError: function() {
        return warnOnSyncDynamicError;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _boundaryconstants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/framework/boundary-constants.js [app-ssr] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)");
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-ssr] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const hasPostpone = typeof _react.default.unstable_postpone === 'function';
function createDynamicTrackingState(isDebugDynamicAccesses) {
    return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicErrorWithStack: null
    };
}
function createDynamicValidationState() {
    return {
        hasSuspenseAboveBody: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasAllowedDynamic: false,
        dynamicErrors: []
    };
}
function getFirstDynamicReason(trackingState) {
    var _trackingState_dynamicAccesses_;
    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;
}
function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'cache':
            case 'unstable-cache':
                // Inside cache scopes, marking a scope as dynamic has no effect,
                // because the outer cache scope creates a cache boundary. This is
                // subtly different from reading a dynamic data source, which is
                // forbidden inside a cache scope.
                return;
            case 'private-cache':
                // A private cache scope is already dynamic by definition.
                return;
            case 'prerender-legacy':
            case 'prerender-ppr':
            case 'request':
                break;
            default:
                workUnitStore;
        }
    }
    // If we're forcing dynamic rendering or we're forcing static rendering, we
    // don't need to do anything here because the entire page is already dynamic
    // or it's static and it should not throw or postpone here.
    if (store.forceDynamic || store.forceStatic) return;
    if (store.dynamicShouldError) {
        throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
            value: "E553",
            enumerable: false,
            configurable: true
        });
    }
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender-ppr':
                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
            case 'prerender-legacy':
                workUnitStore.revalidate = 0;
                // We aren't prerendering, but we are generating a static page. We need
                // to bail out of static generation.
                const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                    value: "E550",
                    enumerable: false,
                    configurable: true
                });
                store.dynamicUsageDescription = expression;
                store.dynamicUsageStack = err.stack;
                throw err;
            case 'request':
                if ("TURBOPACK compile-time truthy", 1) {
                    workUnitStore.usedDynamic = true;
                }
                break;
            default:
                workUnitStore;
        }
    }
}
function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
    // We aren't prerendering but we are generating a static page. We need to bail out of static generation
    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
        value: "E558",
        enumerable: false,
        configurable: true
    });
    prerenderStore.revalidate = 0;
    store.dynamicUsageDescription = expression;
    store.dynamicUsageStack = err.stack;
    throw err;
}
function trackDynamicDataInDynamicRender(workUnitStore) {
    switch(workUnitStore.type){
        case 'cache':
        case 'unstable-cache':
            // Inside cache scopes, marking a scope as dynamic has no effect,
            // because the outer cache scope creates a cache boundary. This is
            // subtly different from reading a dynamic data source, which is
            // forbidden inside a cache scope.
            return;
        case 'private-cache':
            // A private cache scope is already dynamic by definition.
            return;
        case 'prerender':
        case 'prerender-runtime':
        case 'prerender-legacy':
        case 'prerender-ppr':
        case 'prerender-client':
            break;
        case 'request':
            if ("TURBOPACK compile-time truthy", 1) {
                workUnitStore.usedDynamic = true;
            }
            break;
        default:
            workUnitStore;
    }
}
function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
    const error = createPrerenderInterruptedError(reason);
    prerenderStore.controller.abort(error);
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    // It is important that we set this tracking value after aborting. Aborts are executed
    // synchronously except for the case where you abort during render itself. By setting this
    // value late we can use it to determine if any of the aborted tasks are the task that
    // called the sync IO expression in the first place.
    if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
    }
}
function trackSynchronousPlatformIOAccessInDev(requestStore) {
    // We don't actually have a controller to abort but we do the semantic equivalent by
    // advancing the request store out of prerender mode
    requestStore.prerenderPhase = false;
}
function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {
    const prerenderSignal = prerenderStore.controller.signal;
    if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
        // It is important that we set this tracking value after aborting. Aborts are executed
        // synchronously except for the case where you abort during render itself. By setting this
        // value late we can use it to determine if any of the aborted tasks are the task that
        // called the sync IO expression in the first place.
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
            if (dynamicTracking.syncDynamicErrorWithStack === null) {
                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            }
        }
    }
    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);
}
function warnOnSyncDynamicError(dynamicTracking) {
    if (dynamicTracking.syncDynamicErrorWithStack) {
        // the server did something sync dynamic, likely
        // leading to an early termination of the prerender.
        console.error(dynamicTracking.syncDynamicErrorWithStack);
    }
}
const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
function Postpone({ reason, route }) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;
    postponeWithTracking(route, reason, dynamicTracking);
}
function postponeWithTracking(route, expression, dynamicTracking) {
    assertPostpone();
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
    _react.default.unstable_postpone(createPostponeReason(route, expression));
}
function createPostponeReason(route, expression) {
    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
}
function isDynamicPostpone(err) {
    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
    }
    return false;
}
function isDynamicPostponeReason(reason) {
    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');
}
if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
        value: "E296",
        enumerable: false,
        configurable: true
    });
}
const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
function createPrerenderInterruptedError(message) {
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = NEXT_PRERENDER_INTERRUPTED;
    return error;
}
function isPrerenderInterruptedError(error) {
    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;
}
function accessedDynamicData(dynamicAccesses) {
    return dynamicAccesses.length > 0;
}
function consumeDynamicAccess(serverDynamic, clientDynamic) {
    // We mutate because we only call this once we are no longer writing
    // to the dynamicTrackingState and it's more efficient than creating a new
    // array.
    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
    return serverDynamic.dynamicAccesses;
}
function formatDynamicAPIAccesses(dynamicAccesses) {
    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes('node_modules/next/')) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(' (<anonymous>)')) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(' (node:')) {
                return false;
            }
            return true;
        }).join('\n');
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), "__NEXT_ERROR_CODE", {
            value: "E224",
            enumerable: false,
            configurable: true
        });
    }
}
function createRenderInBrowserAbortSignal() {
    const controller = new AbortController();
    controller.abort(Object.defineProperty(new _bailouttocsr.BailoutToCSRError('Render in Browser'), "__NEXT_ERROR_CODE", {
        value: "E721",
        enumerable: false,
        configurable: true
    }));
    return controller.signal;
}
function createHangingInputAbortSignal(workUnitStore) {
    switch(workUnitStore.type){
        case 'prerender':
        case 'prerender-runtime':
            const controller = new AbortController();
            if (workUnitStore.cacheSignal) {
                // If we have a cacheSignal it means we're in a prospective render. If
                // the input we're waiting on is coming from another cache, we do want
                // to wait for it so that we can resolve this cache entry too.
                workUnitStore.cacheSignal.inputReady().then(()=>{
                    controller.abort();
                });
            } else {
                // Otherwise we're in the final render and we should already have all
                // our caches filled.
                // If the prerender uses stages, we have wait until the runtime stage,
                // at which point all runtime inputs will be resolved.
                // (otherwise, a runtime prerender might consider `cookies()` hanging
                //  even though they'd resolve in the next task.)
                //
                // We might still be waiting on some microtasks so we
                // wait one tick before giving up. When we give up, we still want to
                // render the content of this cache as deeply as we can so that we can
                // suspend as deeply as possible in the tree or not at all if we don't
                // end up waiting for the input.
                const runtimeStagePromise = (0, _workunitasyncstorageexternal.getRuntimeStagePromise)(workUnitStore);
                if (runtimeStagePromise) {
                    runtimeStagePromise.then(()=>(0, _scheduler.scheduleOnNextTick)(()=>controller.abort()));
                } else {
                    (0, _scheduler.scheduleOnNextTick)(()=>controller.abort());
                }
            }
            return controller.signal;
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
        case 'request':
        case 'cache':
        case 'private-cache':
        case 'unstable-cache':
            return undefined;
        default:
            workUnitStore;
    }
}
function annotateDynamicAccess(expression, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function useDynamicRouteParams(expression) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore && workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender-client':
            case 'prerender':
                {
                    const fallbackParams = workUnitStore.fallbackRouteParams;
                    if (fallbackParams && fallbackParams.size > 0) {
                        // We are in a prerender with cacheComponents semantics. We are going to
                        // hang here and never resolve. This will cause the currently
                        // rendering component to effectively be a dynamic hole.
                        _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, expression));
                    }
                    break;
                }
            case 'prerender-ppr':
                {
                    const fallbackParams = workUnitStore.fallbackRouteParams;
                    if (fallbackParams && fallbackParams.size > 0) {
                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);
                    }
                    break;
                }
            case 'prerender-runtime':
                throw Object.defineProperty(new _invarianterror.InvariantError(`\`${expression}\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                    value: "E771",
                    enumerable: false,
                    configurable: true
                });
            case 'cache':
            case 'private-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError(`\`${expression}\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                    value: "E745",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-legacy':
            case 'request':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
}
const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
// Common implicit body tags that React will treat as body when placed directly in html
const bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';
// Detects when RootLayoutBoundary (our framework marker component) appears
// after Suspense in the component stack, indicating the root layout is wrapped
// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.
//
// Example matches:
//   at Suspense (<anonymous>)
//   at __next_root_layout_boundary__ (<anonymous>)
//
// Or with other components in between (but not body/html/implicit-body):
//   at Suspense (<anonymous>)
//   at SomeComponent (<anonymous>)
//   at __next_root_layout_boundary__ (<anonymous>)
const hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\n\\s+at Suspense \\(<anonymous>\\)(?:(?!\\n\\s+at (?:${bodyAndImplicitTags}) \\(<anonymous>\\))[\\s\\S])*?\\n\\s+at ${_boundaryconstants.ROOT_LAYOUT_BOUNDARY_NAME} \\([^\\n]*\\)`);
const hasMetadataRegex = new RegExp(`\\n\\s+at ${_boundaryconstants.METADATA_BOUNDARY_NAME}[\\n\\s]`);
const hasViewportRegex = new RegExp(`\\n\\s+at ${_boundaryconstants.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`);
const hasOutletRegex = new RegExp(`\\n\\s+at ${_boundaryconstants.OUTLET_BOUNDARY_NAME}[\\n\\s]`);
function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {
    if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
    } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
    } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {
        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.
        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense
        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.
        dynamicValidation.hasAllowedDynamic = true;
        dynamicValidation.hasSuspenseAboveBody = true;
        return;
    } else if (hasSuspenseRegex.test(componentStack)) {
        // this error had a Suspense boundary above it so we don't need to report it as a source
        // of disallowed
        dynamicValidation.hasAllowedDynamic = true;
        return;
    } else if (clientDynamic.syncDynamicErrorWithStack) {
        // This task was the task that called the sync error.
        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);
        return;
    } else {
        const message = `Route "${workStore.route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;
        const error = createErrorWithComponentOrOwnerStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
    }
}
/**
 * In dev mode, we prefer using the owner stack, otherwise the provided
 * component stack is used.
 */ function createErrorWithComponentOrOwnerStack(message, componentStack) {
    const ownerStack = ("TURBOPACK compile-time value", "development") !== 'production' && _react.default.captureOwnerStack ? _react.default.captureOwnerStack() : null;
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);
    return error;
}
var PreludeState = /*#__PURE__*/ function(PreludeState) {
    PreludeState[PreludeState["Full"] = 0] = "Full";
    PreludeState[PreludeState["Empty"] = 1] = "Empty";
    PreludeState[PreludeState["Errored"] = 2] = "Errored";
    return PreludeState;
}({});
function logDisallowedDynamicError(workStore, error) {
    console.error(error);
    if (!workStore.dev) {
        if (workStore.hasReadableErrorStacks) {
            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.`);
        } else {
            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:
  - Start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.
  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`);
        }
    }
}
function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {
    if (prelude !== 0) {
        if (dynamicValidation.hasSuspenseAboveBody) {
            // This route has opted into allowing fully dynamic rendering
            // by including a Suspense boundary above the body. In this case
            // a lack of a shell is not considered disallowed so we simply return
            return;
        }
        if (serverDynamic.syncDynamicErrorWithStack) {
            // There is no shell and the server did something sync dynamic likely
            // leading to an early termination of the prerender before the shell
            // could be completed. We terminate the build/validating render.
            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // We didn't have any sync bailouts but there may be user code which
        // blocked the root. We would have captured these during the prerender
        // and can log them here and then terminate the build/validating render
        const dynamicErrors = dynamicValidation.dynamicErrors;
        if (dynamicErrors.length > 0) {
            for(let i = 0; i < dynamicErrors.length; i++){
                logDisallowedDynamicError(workStore, dynamicErrors[i]);
            }
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // If we got this far then the only other thing that could be blocking
        // the root is dynamic Viewport. If this is dynamic then
        // you need to opt into that by adding a Suspense boundary above the body
        // to indicate your are ok with fully dynamic rendering.
        if (dynamicValidation.hasDynamicViewport) {
            console.error(`Route "${workStore.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        if (prelude === 1) {
            // If we ever get this far then we messed up the tracking of invalid dynamic.
            // We still adhere to the constraint that you must produce a shell but invite the
            // user to report this as a bug in Next.js.
            console.error(`Route "${workStore.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    } else {
        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {
            console.error(`Route "${workStore.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    }
}
function delayUntilRuntimeStage(prerenderStore, result) {
    if (prerenderStore.runtimeStagePromise) {
        return prerenderStore.runtimeStagePromise.then(()=>result);
    }
    return result;
} //# sourceMappingURL=dynamic-rendering.js.map
}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _ispostpone = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-ssr] (ecmascript)");
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)");
function unstable_rethrow(error) {
    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error) || (0, _hooksservercontext.isDynamicServerError)(error) || (0, _dynamicrendering.isDynamicPostpone)(error) || (0, _ispostpone.isPostpone)(error) || (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error)) {
        throw error;
    }
    if (error instanceof Error && 'cause' in error) {
        unstable_rethrow(error.cause);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.server.js.map
}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.
 * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.
 * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.
 *
 * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const unstable_rethrow = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-ssr] (ecmascript)").unstable_rethrow : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.js.map
}),
"[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @internal */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyURLSearchParams: null,
    RedirectType: null,
    forbidden: null,
    notFound: null,
    permanentRedirect: null,
    redirect: null,
    unauthorized: null,
    unstable_isUnrecognizedActionError: null,
    unstable_rethrow: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return ReadonlyURLSearchParams;
    },
    RedirectType: function() {
        return _redirecterror.RedirectType;
    },
    forbidden: function() {
        return _forbidden.forbidden;
    },
    notFound: function() {
        return _notfound.notFound;
    },
    permanentRedirect: function() {
        return _redirect.permanentRedirect;
    },
    redirect: function() {
        return _redirect.redirect;
    },
    unauthorized: function() {
        return _unauthorized.unauthorized;
    },
    unstable_isUnrecognizedActionError: function() {
        return unstable_isUnrecognizedActionError;
    },
    unstable_rethrow: function() {
        return _unstablerethrow.unstable_rethrow;
    }
});
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const _notfound = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)");
const _forbidden = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/forbidden.js [app-ssr] (ecmascript)");
const _unauthorized = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unauthorized.js [app-ssr] (ecmascript)");
const _unstablerethrow = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-ssr] (ecmascript)");
class ReadonlyURLSearchParamsError extends Error {
    constructor(){
        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');
    }
}
class ReadonlyURLSearchParams extends URLSearchParams {
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {
        throw new ReadonlyURLSearchParamsError();
    }
}
function unstable_isUnrecognizedActionError() {
    throw Object.defineProperty(new Error('`unstable_isUnrecognizedActionError` can only be used on the client.'), "__NEXT_ERROR_CODE", {
        value: "E776",
        enumerable: false,
        configurable: true
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.react-server.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/server-inserted-html.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['contexts'].ServerInsertedHtml; //# sourceMappingURL=server-inserted-html.js.map
}),
"[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    UnrecognizedActionError: null,
    unstable_isUnrecognizedActionError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    UnrecognizedActionError: function() {
        return UnrecognizedActionError;
    },
    unstable_isUnrecognizedActionError: function() {
        return unstable_isUnrecognizedActionError;
    }
});
class UnrecognizedActionError extends Error {
    constructor(...args){
        super(...args);
        this.name = 'UnrecognizedActionError';
    }
}
function unstable_isUnrecognizedActionError(error) {
    return !!(error && typeof error === 'object' && error instanceof UnrecognizedActionError);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unrecognized-action-error.js.map
}),
"[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "bailoutToClientRendering", {
    enumerable: true,
    get: function() {
        return bailoutToClientRendering;
    }
});
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
function bailoutToClientRendering(reason) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (workStore == null ? void 0 : workStore.forceStatic) return;
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-runtime':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                throw Object.defineProperty(new _bailouttocsr.BailoutToCSRError(reason), "__NEXT_ERROR_CODE", {
                    value: "E394",
                    enumerable: false,
                    configurable: true
                });
            case 'request':
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=bailout-to-client-rendering.js.map
}),
"[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyURLSearchParams: null,
    RedirectType: null,
    ServerInsertedHTMLContext: null,
    forbidden: null,
    notFound: null,
    permanentRedirect: null,
    redirect: null,
    unauthorized: null,
    unstable_isUnrecognizedActionError: null,
    unstable_rethrow: null,
    useParams: null,
    usePathname: null,
    useRouter: null,
    useSearchParams: null,
    useSelectedLayoutSegment: null,
    useSelectedLayoutSegments: null,
    useServerInsertedHTML: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return _navigationreactserver.ReadonlyURLSearchParams;
    },
    RedirectType: function() {
        return _navigationreactserver.RedirectType;
    },
    ServerInsertedHTMLContext: function() {
        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;
    },
    forbidden: function() {
        return _navigationreactserver.forbidden;
    },
    notFound: function() {
        return _navigationreactserver.notFound;
    },
    permanentRedirect: function() {
        return _navigationreactserver.permanentRedirect;
    },
    redirect: function() {
        return _navigationreactserver.redirect;
    },
    unauthorized: function() {
        return _navigationreactserver.unauthorized;
    },
    unstable_isUnrecognizedActionError: function() {
        return _unrecognizedactionerror.unstable_isUnrecognizedActionError;
    },
    unstable_rethrow: function() {
        return _navigationreactserver.unstable_rethrow;
    },
    useParams: function() {
        return useParams;
    },
    usePathname: function() {
        return usePathname;
    },
    useRouter: function() {
        return useRouter;
    },
    useSearchParams: function() {
        return useSearchParams;
    },
    useSelectedLayoutSegment: function() {
        return useSelectedLayoutSegment;
    },
    useSelectedLayoutSegments: function() {
        return useSelectedLayoutSegments;
    },
    useServerInsertedHTML: function() {
        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)");
const _getsegmentvalue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _navigationreactserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-ssr] (ecmascript)");
const _serverinsertedhtmlsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/server-inserted-html.js [app-ssr] (ecmascript)");
const _unrecognizedactionerror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-ssr] (ecmascript)");
const useDynamicRouteParams = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)").useDynamicRouteParams : "TURBOPACK unreachable";
function useSearchParams() {
    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);
    // In the case where this is `null`, the compat types added in
    // `next-env.d.ts` will add a new overload that changes the return type to
    // include `null`.
    const readonlySearchParams = (0, _react.useMemo)(()=>{
        if (!searchParams) {
            // When the router is not ready in pages, we won't have the search params
            // available.
            return null;
        }
        return new _navigationreactserver.ReadonlyURLSearchParams(searchParams);
    }, [
        searchParams
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { bailoutToClientRendering } = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-ssr] (ecmascript)");
        // TODO-APP: handle dynamic = 'force-static' here and on the client
        bailoutToClientRendering('useSearchParams()');
    }
    return readonlySearchParams;
}
function usePathname() {
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('usePathname()');
    // In the case where this is `null`, the compat types added in `next-env.d.ts`
    // will add a new overload that changes the return type to include `null`.
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
}
function useRouter() {
    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);
    if (router === null) {
        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), "__NEXT_ERROR_CODE", {
            value: "E238",
            enumerable: false,
            configurable: true
        });
    }
    return router;
}
function useParams() {
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useParams()');
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);
}
/** Get the canonical parameters from the current level to the leaf node. */ // Client components API
function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {
    if (first === void 0) first = true;
    if (segmentPath === void 0) segmentPath = [];
    let node;
    if (first) {
        // Use the provided parallel route key on the first parallel route
        node = tree[1][parallelRouteKey];
    } else {
        // After first parallel route prefer children, if there's no children pick the first parallel route.
        const parallelRoutes = tree[1];
        var _parallelRoutes_children;
        node = (_parallelRoutes_children = parallelRoutes.children) != null ? _parallelRoutes_children : Object.values(parallelRoutes)[0];
    }
    if (!node) return segmentPath;
    const segment = node[0];
    let segmentValue = (0, _getsegmentvalue.getSegmentValue)(segment);
    if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) {
        return segmentPath;
    }
    segmentPath.push(segmentValue);
    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
}
function useSelectedLayoutSegments(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = 'children';
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegments()');
    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);
    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts
    if (!context) return null;
    return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey);
}
function useSelectedLayoutSegment(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = 'children';
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegment()');
    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);
    if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {
        return null;
    }
    const selectedLayoutSegment = parallelRouteKey === 'children' ? selectedLayoutSegments[0] : selectedLayoutSegments[selectedLayoutSegments.length - 1];
    // if the default slot is showing, we return null since it's not technically "selected" (it's a fallback)
    // and returning an internal value like `__DEFAULT__` would be confusing.
    return selectedLayoutSegment === _segment.DEFAULT_SEGMENT_KEY ? null : selectedLayoutSegment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.js.map
}),
"[project]/node_modules/next/navigation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */ var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var Url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var spawn = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)").spawn;
/**
 * Module exports.
 */ module.exports = XMLHttpRequest;
// backwards-compat
XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;
/**
 * `XMLHttpRequest` constructor.
 *
 * Supported options for the `opts` object are:
 *
 *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled
 *
 * @param {Object} opts optional "options" object
 */ function XMLHttpRequest(opts) {
    "use strict";
    opts = opts || {};
    /**
   * Private variables
   */ var self = this;
    var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
    var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
    // Holds http.js objects
    var request;
    var response;
    // Request settings
    var settings = {};
    // Disable header blacklist.
    // Not part of XHR specs.
    var disableHeaderCheck = false;
    // Set some default headers
    var defaultHeaders = {
        "User-Agent": "node-XMLHttpRequest",
        "Accept": "*/*"
    };
    var headers = Object.assign({}, defaultHeaders);
    // These headers are not user setable.
    // The following are allowed but banned in the spec:
    // * user-agent
    var forbiddenRequestHeaders = [
        "accept-charset",
        "accept-encoding",
        "access-control-request-headers",
        "access-control-request-method",
        "connection",
        "content-length",
        "content-transfer-encoding",
        "cookie",
        "cookie2",
        "date",
        "expect",
        "host",
        "keep-alive",
        "origin",
        "referer",
        "te",
        "trailer",
        "transfer-encoding",
        "upgrade",
        "via"
    ];
    // These request methods are not allowed
    var forbiddenRequestMethods = [
        "TRACE",
        "TRACK",
        "CONNECT"
    ];
    // Send flag
    var sendFlag = false;
    // Error flag, used when errors occur or abort is called
    var errorFlag = false;
    var abortedFlag = false;
    // Event listeners
    var listeners = {};
    /**
   * Constants
   */ this.UNSENT = 0;
    this.OPENED = 1;
    this.HEADERS_RECEIVED = 2;
    this.LOADING = 3;
    this.DONE = 4;
    /**
   * Public vars
   */ // Current state
    this.readyState = this.UNSENT;
    // default ready state change handler in case one is not set or is set late
    this.onreadystatechange = null;
    // Result & response
    this.responseText = "";
    this.responseXML = "";
    this.response = Buffer.alloc(0);
    this.status = null;
    this.statusText = null;
    /**
   * Private methods
   */ /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */ var isAllowedHttpHeader = function(header) {
        return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;
    };
    /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */ var isAllowedHttpMethod = function(method) {
        return method && forbiddenRequestMethods.indexOf(method) === -1;
    };
    /**
   * Public methods
   */ /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */ this.open = function(method, url, async, user, password) {
        this.abort();
        errorFlag = false;
        abortedFlag = false;
        // Check for valid request method
        if (!isAllowedHttpMethod(method)) {
            throw new Error("SecurityError: Request method not allowed");
        }
        settings = {
            "method": method,
            "url": url.toString(),
            "async": typeof async !== "boolean" ? true : async,
            "user": user || null,
            "password": password || null
        };
        setState(this.OPENED);
    };
    /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */ this.setDisableHeaderCheck = function(state) {
        disableHeaderCheck = state;
    };
    /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   * @return boolean Header added
   */ this.setRequestHeader = function(header, value) {
        if (this.readyState != this.OPENED) {
            throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
        }
        if (!isAllowedHttpHeader(header)) {
            console.warn('Refused to set unsafe header "' + header + '"');
            return false;
        }
        if (sendFlag) {
            throw new Error("INVALID_STATE_ERR: send flag is true");
        }
        headers[header] = value;
        return true;
    };
    /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */ this.getResponseHeader = function(header) {
        if (typeof header === "string" && this.readyState > this.OPENED && response.headers[header.toLowerCase()] && !errorFlag) {
            return response.headers[header.toLowerCase()];
        }
        return null;
    };
    /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */ this.getAllResponseHeaders = function() {
        if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
            return "";
        }
        var result = "";
        for(var i in response.headers){
            // Cookie headers are excluded
            if (i !== "set-cookie" && i !== "set-cookie2") {
                result += i + ": " + response.headers[i] + "\r\n";
            }
        }
        return result.substr(0, result.length - 2);
    };
    /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */ this.getRequestHeader = function(name) {
        // @TODO Make this case insensitive
        if (typeof name === "string" && headers[name]) {
            return headers[name];
        }
        return "";
    };
    /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */ this.send = function(data) {
        if (this.readyState != this.OPENED) {
            throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
        }
        if (sendFlag) {
            throw new Error("INVALID_STATE_ERR: send has already been called");
        }
        var ssl = false, local = false;
        var url = Url.parse(settings.url);
        var host;
        // Determine the server
        switch(url.protocol){
            case 'https:':
                ssl = true;
            // SSL & non-SSL both need host, no break here.
            case 'http:':
                host = url.hostname;
                break;
            case 'file:':
                local = true;
                break;
            case undefined:
            case '':
                host = "localhost";
                break;
            default:
                throw new Error("Protocol not supported.");
        }
        // Load files off the local filesystem (file://)
        if (local) {
            if (settings.method !== "GET") {
                throw new Error("XMLHttpRequest: Only GET method is supported");
            }
            if (settings.async) {
                fs.readFile(unescape(url.pathname), function(error, data) {
                    if (error) {
                        self.handleError(error, error.errno || -1);
                    } else {
                        self.status = 200;
                        self.responseText = data.toString('utf8');
                        self.response = data;
                        setState(self.DONE);
                    }
                });
            } else {
                try {
                    this.response = fs.readFileSync(unescape(url.pathname));
                    this.responseText = this.response.toString('utf8');
                    this.status = 200;
                    setState(self.DONE);
                } catch (e) {
                    this.handleError(e, e.errno || -1);
                }
            }
            return;
        }
        // Default to port 80. If accessing localhost on another port be sure
        // to use http://localhost:port/path
        var port = url.port || (ssl ? 443 : 80);
        // Add query string if one is used
        var uri = url.pathname + (url.search ? url.search : '');
        // Set the Host header or the server may reject the request
        headers["Host"] = host;
        if (!(ssl && port === 443 || port === 80)) {
            headers["Host"] += ':' + url.port;
        }
        // Set Basic Auth if necessary
        if (settings.user) {
            if (typeof settings.password == "undefined") {
                settings.password = "";
            }
            var authBuf = new Buffer(settings.user + ":" + settings.password);
            headers["Authorization"] = "Basic " + authBuf.toString("base64");
        }
        // Set content length header
        if (settings.method === "GET" || settings.method === "HEAD") {
            data = null;
        } else if (data) {
            headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
            var headersKeys = Object.keys(headers);
            if (!headersKeys.some(function(h) {
                return h.toLowerCase() === 'content-type';
            })) {
                headers["Content-Type"] = "text/plain;charset=UTF-8";
            }
        } else if (settings.method === "POST") {
            // For a post with no data set Content-Length: 0.
            // This is required by buggy servers that don't meet the specs.
            headers["Content-Length"] = 0;
        }
        var agent = opts.agent || false;
        var options = {
            host: host,
            port: port,
            path: uri,
            method: settings.method,
            headers: headers,
            agent: agent
        };
        if (ssl) {
            options.pfx = opts.pfx;
            options.key = opts.key;
            options.passphrase = opts.passphrase;
            options.cert = opts.cert;
            options.ca = opts.ca;
            options.ciphers = opts.ciphers;
            options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;
        }
        // Reset error flag
        errorFlag = false;
        // Handle async requests
        if (settings.async) {
            // Use the proper protocol
            var doRequest = ssl ? https.request : http.request;
            // Request is being sent, set send flag
            sendFlag = true;
            // As per spec, this is called here for historical reasons.
            self.dispatchEvent("readystatechange");
            // Handler for the response
            var responseHandler = function(resp) {
                // Set response var to the response we got back
                // This is so it remains accessable outside this scope
                response = resp;
                // Check for redirect
                // @TODO Prevent looped redirects
                if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
                    // Change URL to the redirect location
                    settings.url = response.headers.location;
                    var url = Url.parse(settings.url);
                    // Set host var in case it's used later
                    host = url.hostname;
                    // Options for the new request
                    var newOptions = {
                        hostname: url.hostname,
                        port: url.port,
                        path: url.path,
                        method: response.statusCode === 303 ? 'GET' : settings.method,
                        headers: headers
                    };
                    if (ssl) {
                        newOptions.pfx = opts.pfx;
                        newOptions.key = opts.key;
                        newOptions.passphrase = opts.passphrase;
                        newOptions.cert = opts.cert;
                        newOptions.ca = opts.ca;
                        newOptions.ciphers = opts.ciphers;
                        newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;
                    }
                    // Issue the new request
                    request = doRequest(newOptions, responseHandler).on('error', errorHandler);
                    request.end();
                    // @TODO Check if an XHR event needs to be fired here
                    return;
                }
                setState(self.HEADERS_RECEIVED);
                self.status = response.statusCode;
                response.on('data', function(chunk) {
                    // Make sure there's some data
                    if (chunk) {
                        var data = Buffer.from(chunk);
                        self.response = Buffer.concat([
                            self.response,
                            data
                        ]);
                    }
                    // Don't emit state changes if the connection has been aborted.
                    if (sendFlag) {
                        setState(self.LOADING);
                    }
                });
                response.on('end', function() {
                    if (sendFlag) {
                        // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks
                        // there can be a timing issue (the callback is called and a new call is made before the flag is reset).
                        sendFlag = false;
                        // Discard the 'end' event if the connection has been aborted
                        setState(self.DONE);
                        // Construct responseText from response
                        self.responseText = self.response.toString('utf8');
                    }
                });
                response.on('error', function(error) {
                    self.handleError(error);
                });
            };
            // Error handler for the request
            var errorHandler = function(error) {
                // In the case of https://nodejs.org/api/http.html#requestreusedsocket triggering an ECONNRESET,
                // don't fail the xhr request, attempt again.
                if (request.reusedSocket && error.code === 'ECONNRESET') return doRequest(options, responseHandler).on('error', errorHandler);
                self.handleError(error);
            };
            // Create the request
            request = doRequest(options, responseHandler).on('error', errorHandler);
            if (opts.autoUnref) {
                request.on('socket', (socket)=>{
                    socket.unref();
                });
            }
            // Node 0.4 and later won't accept empty data. Make sure it's needed.
            if (data) {
                request.write(data);
            }
            request.end();
            self.dispatchEvent("loadstart");
        } else {
            // Create a temporary file for communication with the other Node process
            var contentFile = ".node-xmlhttprequest-content-" + process.pid;
            var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
            fs.writeFileSync(syncFile, "", "utf8");
            // The async request the other Node process executes
            var execString = "var http = require('http'), https = require('https'), fs = require('fs');" + "var doRequest = http" + (ssl ? "s" : "") + ".request;" + "var options = " + JSON.stringify(options) + ";" + "var responseText = '';" + "var responseData = Buffer.alloc(0);" + "var req = doRequest(options, function(response) {" + "response.on('data', function(chunk) {" + "  var data = Buffer.from(chunk);" + "  responseText += data.toString('utf8');" + "  responseData = Buffer.concat([responseData, data]);" + "});" + "response.on('end', function() {" + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText, data: responseData.toString('base64')}}), 'utf8');" + "fs.unlinkSync('" + syncFile + "');" + "});" + "response.on('error', function(error) {" + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');" + "fs.unlinkSync('" + syncFile + "');" + "});" + "}).on('error', function(error) {" + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');" + "fs.unlinkSync('" + syncFile + "');" + "});" + (data ? "req.write('" + JSON.stringify(data).slice(1, -1).replace(/'/g, "\\'") + "');" : "") + "req.end();";
            // Start the other Node Process, executing this string
            var syncProc = spawn(process.argv[0], [
                "-e",
                execString
            ]);
            var statusText;
            while(fs.existsSync(syncFile)){
            // Wait while the sync file is empty
            }
            self.responseText = fs.readFileSync(contentFile, 'utf8');
            // Kill the child process once the file has data
            syncProc.stdin.end();
            // Remove the temporary file
            fs.unlinkSync(contentFile);
            if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
                // If the file returned an error, handle it
                var errorObj = JSON.parse(self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, ""));
                self.handleError(errorObj, 503);
            } else {
                // If the file returned okay, parse its data and move to the DONE state
                self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
                var resp = JSON.parse(self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1"));
                response = {
                    statusCode: self.status,
                    headers: resp.data.headers
                };
                self.responseText = resp.data.text;
                self.response = Buffer.from(resp.data.data, 'base64');
                setState(self.DONE, true);
            }
        }
    };
    /**
   * Called when an error is encountered to deal with it.
   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.
   */ this.handleError = function(error, status) {
        this.status = status || 0;
        this.statusText = error;
        this.responseText = error.stack;
        errorFlag = true;
        setState(this.DONE);
    };
    /**
   * Aborts a request.
   */ this.abort = function() {
        if (request) {
            request.abort();
            request = null;
        }
        headers = Object.assign({}, defaultHeaders);
        this.responseText = "";
        this.responseXML = "";
        this.response = Buffer.alloc(0);
        errorFlag = abortedFlag = true;
        if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {
            sendFlag = false;
            setState(this.DONE);
        }
        this.readyState = this.UNSENT;
    };
    /**
   * Adds an event listener. Preferred method of binding to events.
   */ this.addEventListener = function(event, callback) {
        if (!(event in listeners)) {
            listeners[event] = [];
        }
        // Currently allows duplicate callbacks. Should it?
        listeners[event].push(callback);
    };
    /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */ this.removeEventListener = function(event, callback) {
        if (event in listeners) {
            // Filter will return a new array with the callback removed
            listeners[event] = listeners[event].filter(function(ev) {
                return ev !== callback;
            });
        }
    };
    /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */ this.dispatchEvent = function(event) {
        if (typeof self["on" + event] === "function") {
            if (this.readyState === this.DONE && settings.async) setTimeout(function() {
                self["on" + event]();
            }, 0);
            else self["on" + event]();
        }
        if (event in listeners) {
            for(let i = 0, len = listeners[event].length; i < len; i++){
                if (this.readyState === this.DONE) setTimeout(function() {
                    listeners[event][i].call(self);
                }, 0);
                else listeners[event][i].call(self);
            }
        }
    };
    /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */ var setState = function(state) {
        if (self.readyState === state || self.readyState === self.UNSENT && abortedFlag) return;
        self.readyState = state;
        if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
            self.dispatchEvent("readystatechange");
        }
        if (self.readyState === self.DONE) {
            let fire;
            if (abortedFlag) fire = "abort";
            else if (errorFlag) fire = "error";
            else fire = "load";
            self.dispatchEvent(fire);
            // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
            self.dispatchEvent("loadend");
        }
    };
}
;
}),
"[project]/node_modules/engine.io-parser/build/esm/commons.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERROR_PACKET",
    ()=>ERROR_PACKET,
    "PACKET_TYPES",
    ()=>PACKET_TYPES,
    "PACKET_TYPES_REVERSE",
    ()=>PACKET_TYPES_REVERSE
]);
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key)=>{
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = {
    type: "error",
    data: "parser error"
};
;
}),
"[project]/node_modules/engine.io-parser/build/esm/encodePacket.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "encodePacket",
    ()=>encodePacket,
    "encodePacketToBinary",
    ()=>encodePacketToBinary
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/commons.js [app-ssr] (ecmascript)");
;
const encodePacket = ({ type, data }, supportsBinary, callback)=>{
    if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        return callback(supportsBinary ? data : "b" + toBuffer(data, true).toString("base64"));
    }
    // plain string
    return callback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PACKET_TYPES"][type] + (data || ""));
};
const toBuffer = (data, forceBufferConversion)=>{
    if (Buffer.isBuffer(data) || data instanceof Uint8Array && !forceBufferConversion) {
        return data;
    } else if (data instanceof ArrayBuffer) {
        return Buffer.from(data);
    } else {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    }
};
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return callback(toBuffer(packet.data, false));
    }
    encodePacket(packet, true, (encoded)=>{
        if (!TEXT_ENCODER) {
            // lazily created for compatibility with Node.js 10
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}
}),
"[project]/node_modules/engine.io-parser/build/esm/decodePacket.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodePacket",
    ()=>decodePacket
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/commons.js [app-ssr] (ecmascript)");
;
const decodePacket = (encodedPacket, binaryType)=>{
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType)
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        const buffer = Buffer.from(encodedPacket.substring(1), "base64");
        return {
            type: "message",
            data: mapBinary(buffer, binaryType)
        };
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PACKET_TYPES_REVERSE"][type]) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ERROR_PACKET"];
    }
    return encodedPacket.length > 1 ? {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PACKET_TYPES_REVERSE"][type],
        data: encodedPacket.substring(1)
    } : {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PACKET_TYPES_REVERSE"][type]
    };
};
const mapBinary = (data, binaryType)=>{
    switch(binaryType){
        case "arraybuffer":
            if (data instanceof ArrayBuffer) {
                // from WebSocket & binaryType "arraybuffer"
                return data;
            } else if (Buffer.isBuffer(data)) {
                // from HTTP long-polling
                return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
            } else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
        case "nodebuffer":
        default:
            if (Buffer.isBuffer(data)) {
                // from HTTP long-polling or WebSocket & binaryType "nodebuffer" (default)
                return data;
            } else {
                // from WebTransport (Uint8Array)
                return Buffer.from(data);
            }
    }
};
}),
"[project]/node_modules/engine.io-parser/build/esm/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createPacketDecoderStream",
    ()=>createPacketDecoderStream,
    "createPacketEncoderStream",
    ()=>createPacketEncoderStream,
    "decodePayload",
    ()=>decodePayload,
    "encodePayload",
    ()=>encodePayload,
    "protocol",
    ()=>protocol
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$encodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/encodePacket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$decodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/decodePacket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/commons.js [app-ssr] (ecmascript)");
;
;
;
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback)=>{
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i)=>{
        // force base64 encoding for binary packets
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$encodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodePacket"])(packet, false, (encodedPacket)=>{
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
const decodePayload = (encodedPayload, binaryType)=>{
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for(let i = 0; i < encodedPackets.length; i++){
        const decodedPacket = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$decodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodePacket"])(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
function createPacketEncoderStream() {
    return new TransformStream({
        transform (packet, controller) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$encodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodePacketToBinary"])(packet, (encodedPacket)=>{
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                } else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                } else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        }
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk)=>acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for(let i = 0; i < size; i++){
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* State.READ_HEADER */ ;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform (chunk, controller) {
            chunks.push(chunk);
            while(true){
                if (state === 0 /* State.READ_HEADER */ ) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* State.READ_PAYLOAD */ ;
                    } else if (expectedLength === 126) {
                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */ ;
                    } else {
                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */ ;
                    }
                } else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */ ) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* State.READ_PAYLOAD */ ;
                } else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */ ) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ERROR_PACKET"]);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* State.READ_PAYLOAD */ ;
                } else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$decodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodePacket"])(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* State.READ_HEADER */ ;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$commons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ERROR_PACKET"]);
                    break;
                }
            }
        }
    });
}
const protocol = 4;
;
}),
"[project]/node_modules/@socket.io/component-emitter/lib/esm/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */ __turbopack_context__.s([
    "Emitter",
    ()=>Emitter
]);
function Emitter(obj) {
    if (obj) return mixin(obj);
}
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */ function mixin(obj) {
    for(var key in Emitter.prototype){
        obj[key] = Emitter.prototype[key];
    }
    return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */ Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */ Emitter.prototype.once = function(event, fn) {
    function on() {
        this.off(event, on);
        fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */ Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    // all
    if (0 == arguments.length) {
        this._callbacks = {};
        return this;
    }
    // specific event
    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this;
    // remove all handlers
    if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
    }
    // remove specific handler
    var cb;
    for(var i = 0; i < callbacks.length; i++){
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
        }
    }
    // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.
    if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
    }
    return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */ Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks['$' + event];
    for(var i = 1; i < arguments.length; i++){
        args[i - 1] = arguments[i];
    }
    if (callbacks) {
        callbacks = callbacks.slice(0);
        for(var i = 0, len = callbacks.length; i < len; ++i){
            callbacks[i].apply(this, args);
        }
    }
    return this;
};
// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */ Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */ Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
};
}),
"[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CookieJar",
    ()=>CookieJar,
    "createCookieJar",
    ()=>createCookieJar,
    "defaultBinaryType",
    ()=>defaultBinaryType,
    "globalThisShim",
    ()=>globalThisShim,
    "nextTick",
    ()=>nextTick,
    "parse",
    ()=>parse
]);
const nextTick = process.nextTick;
const globalThisShim = /*TURBOPACK member replacement*/ __turbopack_context__.g;
const defaultBinaryType = "nodebuffer";
function createCookieJar() {
    return new CookieJar();
}
function parse(setCookieString) {
    const parts = setCookieString.split("; ");
    const i = parts[0].indexOf("=");
    if (i === -1) {
        return;
    }
    const name = parts[0].substring(0, i).trim();
    if (!name.length) {
        return;
    }
    let value = parts[0].substring(i + 1).trim();
    if (value.charCodeAt(0) === 0x22) {
        // remove double quotes
        value = value.slice(1, -1);
    }
    const cookie = {
        name,
        value
    };
    for(let j = 1; j < parts.length; j++){
        const subParts = parts[j].split("=");
        if (subParts.length !== 2) {
            continue;
        }
        const key = subParts[0].trim();
        const value = subParts[1].trim();
        switch(key){
            case "Expires":
                cookie.expires = new Date(value);
                break;
            case "Max-Age":
                const expiration = new Date();
                expiration.setUTCSeconds(expiration.getUTCSeconds() + parseInt(value, 10));
                cookie.expires = expiration;
                break;
            default:
        }
    }
    return cookie;
}
class CookieJar {
    constructor(){
        this._cookies = new Map();
    }
    parseCookies(values) {
        if (!values) {
            return;
        }
        values.forEach((value)=>{
            const parsed = parse(value);
            if (parsed) {
                this._cookies.set(parsed.name, parsed);
            }
        });
    }
    get cookies() {
        const now = Date.now();
        this._cookies.forEach((cookie, name)=>{
            var _a;
            if (((_a = cookie.expires) === null || _a === void 0 ? void 0 : _a.getTime()) < now) {
                this._cookies.delete(name);
            }
        });
        return this._cookies.entries();
    }
    addCookies(xhr) {
        const cookies = [];
        for (const [name, cookie] of this.cookies){
            cookies.push(`${name}=${cookie.value}`);
        }
        if (cookies.length) {
            xhr.setDisableHeaderCheck(true);
            xhr.setRequestHeader("cookie", cookies.join("; "));
        }
    }
    appendCookies(headers) {
        for (const [name, cookie] of this.cookies){
            headers.append("cookie", `${name}=${cookie.value}`);
        }
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "byteLength",
    ()=>byteLength,
    "installTimerFunctions",
    ()=>installTimerFunctions,
    "pick",
    ()=>pick,
    "randomString",
    ()=>randomString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)");
;
function pick(obj, ...attr) {
    return attr.reduce((acc, k)=>{
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"].setTimeout;
const NATIVE_CLEAR_TIMEOUT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"].clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"]);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"]);
    } else {
        obj.setTimeoutFn = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"].setTimeout.bind(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"]);
        obj.clearTimeoutFn = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"].clearTimeout.bind(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"]);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for(let i = 0, l = str.length; i < l; i++){
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        } else if (c < 0x800) {
            length += 2;
        } else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        } else {
            i++;
            length += 4;
        }
    }
    return length;
}
function randomString() {
    return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */ __turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
function encode(obj) {
    let str = '';
    for(let i in obj){
        if (obj.hasOwnProperty(i)) {
            if (str.length) str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
function decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for(let i = 0, l = pairs.length; i < l; i++){
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}
}),
"[project]/node_modules/ms/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}),
"[project]/node_modules/engine.io-client/node_modules/debug/src/common.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-ssr] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) {
                continue;
            }
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
            } else {
                createDebug.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === '*') {
            return true;
        }
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) {
                return false;
            }
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/has-flag/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}),
"[project]/node_modules/supports-color/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-ssr] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = os.release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
    }
    //TURBOPACK unreachable
    ;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}),
"[project]/node_modules/engine.io-client/node_modules/debug/src/node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-ssr] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/engine.io-client/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/engine.io-client/node_modules/debug/src/browser.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/engine.io-client/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/engine.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/engine.io-client/node_modules/debug/src/browser.js [app-ssr] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/engine.io-client/node_modules/debug/src/node.js [app-ssr] (ecmascript)");
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transport.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Transport",
    ()=>Transport,
    "TransportError",
    ()=>TransportError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$decodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/decodePacket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@socket.io/component-emitter/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseqs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("engine.io-client:transport"); // debug()
class TransportError extends Error {
    constructor(reason, description, context){
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
class Transport extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Emitter"] {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */ constructor(opts){
        super();
        this.writable = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["installTimerFunctions"])(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */ onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */ open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */ close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */ send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        } else {
            // this might happen if the transport was silently closed in the beforeunload event handler
            debug("transport is not open, discarding packets");
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */ onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */ onData(data) {
        const packet = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$decodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodePacket"])(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */ onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */ onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */ pause(onPause) {}
    createUri(schema, query = {}) {
        return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
            return ":" + this.opts.port;
        } else {
            return "";
        }
    }
    _query(query) {
        const encodedQuery = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseqs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/polling.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Polling",
    ()=>Polling
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transport.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("engine.io-client:polling"); // debug()
class Polling extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Transport"] {
    constructor(){
        super(...arguments);
        this._polling = false;
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */ doOpen() {
        this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */ pause(onPause) {
        this.readyState = "pausing";
        const pause = ()=>{
            debug("paused");
            this.readyState = "paused";
            onPause();
        };
        if (this._polling || !this.writable) {
            let total = 0;
            if (this._polling) {
                debug("we are currently polling - waiting to pause");
                total++;
                this.once("pollComplete", function() {
                    debug("pre-pause polling complete");
                    --total || pause();
                });
            }
            if (!this.writable) {
                debug("we are currently writing - waiting to pause");
                total++;
                this.once("drain", function() {
                    debug("pre-pause writing complete");
                    --total || pause();
                });
            }
        } else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */ _poll() {
        debug("polling");
        this._polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */ onData(data) {
        debug("polling got data %s", data);
        const callback = (packet)=>{
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({
                    description: "transport closed by the server"
                });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decodePayload"])(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this._polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this._poll();
            } else {
                debug('ignoring poll - transport state "%s"', this.readyState);
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */ doClose() {
        const close = ()=>{
            debug("writing close packet");
            this.write([
                {
                    type: "close"
                }
            ]);
        };
        if ("open" === this.readyState) {
            debug("transport open - closing");
            close();
        } else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            debug("transport not open - deferring close");
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */ write(packets) {
        this.writable = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodePayload"])(packets, (data)=>{
            this.doWrite(data, ()=>{
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */ uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomString"])();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// imported from https://github.com/component/has-cors
__turbopack_context__.s([
    "hasCORS",
    ()=>hasCORS
]);
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
} catch (err) {
// if XMLHttp support is disabled in IE then it will throw
// when trying to create
}
const hasCORS = value;
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseXHR",
    ()=>BaseXHR,
    "Request",
    ()=>Request,
    "XHR",
    ()=>XHR
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/polling.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@socket.io/component-emitter/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$has$2d$cors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("engine.io-client:polling"); // debug()
function empty() {}
class BaseXHR extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Polling"] {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */ constructor(opts){
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        }
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */ doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context)=>{
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */ doPoll() {
        debug("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context)=>{
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
class Request extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Emitter"] {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */ constructor(createRequest, uri, opts){
        super();
        this.createRequest = createRequest;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["installTimerFunctions"])(this, opts);
        this._opts = opts;
        this._method = opts.method || "GET";
        this._uri = uri;
        this._data = undefined !== opts.data ? opts.data : null;
        this._create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */ _create() {
        var _a;
        const opts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pick"])(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this._opts.xd;
        const xhr = this._xhr = this.createRequest(opts);
        try {
            debug("xhr open %s: %s", this._method, this._uri);
            xhr.open(this._method, this._uri, true);
            try {
                if (this._opts.extraHeaders) {
                    // @ts-ignore
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for(let i in this._opts.extraHeaders){
                        if (this._opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                        }
                    }
                }
            } catch (e) {}
            if ("POST" === this._method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                } catch (e) {}
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            } catch (e) {}
            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this._opts.withCredentials;
            }
            if (this._opts.requestTimeout) {
                xhr.timeout = this._opts.requestTimeout;
            }
            xhr.onreadystatechange = ()=>{
                var _a;
                if (xhr.readyState === 3) {
                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(// @ts-ignore
                    xhr.getResponseHeader("set-cookie"));
                }
                if (4 !== xhr.readyState) return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this._onLoad();
                } else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(()=>{
                        this._onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            debug("xhr data %s", this._data);
            xhr.send(this._data);
        } catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(()=>{
                this._onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this._index = Request.requestsCount++;
            Request.requests[this._index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */ _onError(err) {
        this.emitReserved("error", err, this._xhr);
        this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */ _cleanup(fromError) {
        if ("undefined" === typeof this._xhr || null === this._xhr) {
            return;
        }
        this._xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this._xhr.abort();
            } catch (e) {}
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this._index];
        }
        this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */ _onLoad() {
        const data = this._xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this._cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */ abort() {
        this._cleanup();
    }
}
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */ if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"] ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for(let i in Request.requests){
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}
const hasXHR2 = function() {
    const xhr = newRequest({
        xdomain: false
    });
    return xhr && xhr.responseType !== null;
}();
class XHR extends BaseXHR {
    constructor(opts){
        super(opts);
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
        Object.assign(opts, {
            xd: this.xd
        }, this.opts);
        return new Request(newRequest, this.uri(), opts);
    }
}
function newRequest(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$has$2d$cors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasCORS"])) {
            return new XMLHttpRequest();
        }
    } catch (e) {}
    if (!xdomain) {
        try {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"][[
                "Active"
            ].concat("Object").join("X")]("Microsoft.XMLHTTP");
        } catch (e) {}
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "XHR",
    ()=>XHR
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xmlhttprequest$2d$ssl$2f$lib$2f$XMLHttpRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$xhr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js [app-ssr] (ecmascript)");
;
;
const XMLHttpRequest = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xmlhttprequest$2d$ssl$2f$lib$2f$XMLHttpRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.default || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xmlhttprequest$2d$ssl$2f$lib$2f$XMLHttpRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__;
class XHR extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$xhr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseXHR"] {
    request(opts = {}) {
        var _a;
        Object.assign(opts, {
            xd: this.xd,
            cookieJar: (_a = this.socket) === null || _a === void 0 ? void 0 : _a._cookieJar
        }, this.opts);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$xhr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Request"]((opts)=>new XMLHttpRequest(opts), this.uri(), opts);
    }
}
}),
"[project]/node_modules/ws/lib/stream.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Duplex } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */ function emitClose(stream) {
    stream.emit('close');
}
/**
 * The listener of the `'end'` event.
 *
 * @private
 */ function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
        this.destroy();
    }
}
/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */ function duplexOnError(err) {
    this.removeListener('error', duplexOnError);
    this.destroy();
    if (this.listenerCount('error') === 0) {
        // Do not suppress the throwing behavior.
        this.emit('error', err);
    }
}
/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */ function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
    });
    ws.on('message', function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
    });
    ws.once('error', function error(err) {
        if (duplex.destroyed) return;
        // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
        //
        // - If the `'error'` event is emitted before the `'open'` event, then
        //   `ws.terminate()` is a noop as no socket is assigned.
        // - Otherwise, the error is re-emitted by the listener of the `'error'`
        //   event of the `Receiver` object. The listener already closes the
        //   connection by calling `ws.close()`. This allows a close frame to be
        //   sent to the other peer. If `ws.terminate()` is called right after this,
        //   then the close frame might not be sent.
        terminateOnDestroy = false;
        duplex.destroy(err);
    });
    ws.once('close', function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
            callback(err);
            process.nextTick(emitClose, duplex);
            return;
        }
        let called = false;
        ws.once('error', function error(err) {
            called = true;
            callback(err);
        });
        ws.once('close', function close() {
            if (!called) callback(err);
            process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
    };
    duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
            ws.once('open', function open() {
                duplex._final(callback);
            });
            return;
        }
        // If the value of the `_socket` property is `null` it means that `ws` is a
        // client websocket and the handshake failed. In fact, when this happens, a
        // socket is never assigned to the websocket. Wait for the `'error'` event
        // that will be emitted by the websocket.
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
            callback();
            if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
            ws._socket.once('finish', function finish() {
                // `duplex` is not destroyed here because the `'end'` event will be
                // emitted on `duplex` after this `'finish'` event. The EOF signaling
                // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
                callback();
            });
            ws.close();
        }
    };
    duplex._read = function() {
        if (ws.isPaused) ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
            ws.once('open', function open() {
                duplex._write(chunk, encoding, callback);
            });
            return;
        }
        ws.send(chunk, callback);
    };
    duplex.on('end', duplexOnEnd);
    duplex.on('error', duplexOnError);
    return duplex;
}
module.exports = createWebSocketStream;
}),
"[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    BINARY_TYPES: [
        'nodebuffer',
        'arraybuffer',
        'fragments'
    ],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
    kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
    kListener: Symbol('kListener'),
    kStatusCode: Symbol('status-code'),
    kWebSocket: Symbol('websocket'),
    NOOP: ()=>{}
};
}),
"[project]/node_modules/ws/lib/buffer-util.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { EMPTY_BUFFER } = __turbopack_context__.r("[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)");
const FastBuffer = Buffer[Symbol.species];
/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */ function concat(list, totalLength) {
    if (list.length === 0) return EMPTY_BUFFER;
    if (list.length === 1) return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for(let i = 0; i < list.length; i++){
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
    }
    if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
}
/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */ function _mask(source, mask, output, offset, length) {
    for(let i = 0; i < length; i++){
        output[offset + i] = source[i] ^ mask[i & 3];
    }
}
/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */ function _unmask(buffer, mask) {
    for(let i = 0; i < buffer.length; i++){
        buffer[i] ^= mask[i & 3];
    }
}
/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */ function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}
/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */ function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data)) return data;
    let buf;
    if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
    }
    return buf;
}
module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
};
/* istanbul ignore else  */ if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
        const bufferUtil = (()=>{
            const e = new Error("Cannot find module 'bufferutil'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
        module.exports.mask = function(source, mask, output, offset, length) {
            if (length < 48) _mask(source, mask, output, offset, length);
            else bufferUtil.mask(source, mask, output, offset, length);
        };
        module.exports.unmask = function(buffer, mask) {
            if (buffer.length < 32) _unmask(buffer, mask);
            else bufferUtil.unmask(buffer, mask);
        };
    } catch (e) {
    // Continue regardless of the error.
    }
}
}),
"[project]/node_modules/ws/lib/limiter.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const kDone = Symbol('kDone');
const kRun = Symbol('kRun');
/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */ class Limiter {
    /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */ constructor(concurrency){
        this[kDone] = ()=>{
            this.pending--;
            this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
    }
    /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */ add(job) {
        this.jobs.push(job);
        this[kRun]();
    }
    /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */ [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
            const job = this.jobs.shift();
            this.pending++;
            job(this[kDone]);
        }
    }
}
module.exports = Limiter;
}),
"[project]/node_modules/ws/lib/permessage-deflate.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const zlib = __turbopack_context__.r("[externals]/zlib [external] (zlib, cjs)");
const bufferUtil = __turbopack_context__.r("[project]/node_modules/ws/lib/buffer-util.js [app-ssr] (ecmascript)");
const Limiter = __turbopack_context__.r("[project]/node_modules/ws/lib/limiter.js [app-ssr] (ecmascript)");
const { kStatusCode } = __turbopack_context__.r("[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)");
const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([
    0x00,
    0x00,
    0xff,
    0xff
]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');
//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;
/**
 * permessage-deflate implementation.
 */ class PerMessageDeflate {
    /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */ constructor(options, isServer, maxPayload){
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
            const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
            zlibLimiter = new Limiter(concurrency);
        }
    }
    /**
   * @type {String}
   */ static get extensionName() {
        return 'permessage-deflate';
    }
    /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */ offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
            params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
            params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
            params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
            params.client_max_window_bits = true;
        }
        return params;
    }
    /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */ accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
    }
    /**
   * Releases all resources used by the extension.
   *
   * @public
   */ cleanup() {
        if (this._inflate) {
            this._inflate.close();
            this._inflate = null;
        }
        if (this._deflate) {
            const callback = this._deflate[kCallback];
            this._deflate.close();
            this._deflate = null;
            if (callback) {
                callback(new Error('The deflate stream was closed while data was being processed'));
            }
        }
    }
    /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */ acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params)=>{
            if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {
                return false;
            }
            return true;
        });
        if (!accepted) {
            throw new Error('None of the extension offers can be accepted');
        }
        if (opts.serverNoContextTakeover) {
            accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
            accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === 'number') {
            accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === 'number') {
            accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
            delete accepted.client_max_window_bits;
        }
        return accepted;
    }
    /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */ acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
            throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
            if (typeof this._options.clientMaxWindowBits === 'number') {
                params.client_max_window_bits = this._options.clientMaxWindowBits;
            }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {
            throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
    }
    /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */ normalizeParams(configurations) {
        configurations.forEach((params)=>{
            Object.keys(params).forEach((key)=>{
                let value = params[key];
                if (value.length > 1) {
                    throw new Error(`Parameter "${key}" must have only a single value`);
                }
                value = value[0];
                if (key === 'client_max_window_bits') {
                    if (value !== true) {
                        const num = +value;
                        if (!Number.isInteger(num) || num < 8 || num > 15) {
                            throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        }
                        value = num;
                    } else if (!this._isServer) {
                        throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                    }
                } else if (key === 'server_max_window_bits') {
                    const num = +value;
                    if (!Number.isInteger(num) || num < 8 || num > 15) {
                        throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                    }
                    value = num;
                } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
                    if (value !== true) {
                        throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                    }
                } else {
                    throw new Error(`Unknown parameter "${key}"`);
                }
                params[key] = value;
            });
        });
        return configurations;
    }
    /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */ decompress(data, fin, callback) {
        zlibLimiter.add((done)=>{
            this._decompress(data, fin, (err, result)=>{
                done();
                callback(err, result);
            });
        });
    }
    /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */ compress(data, fin, callback) {
        zlibLimiter.add((done)=>{
            this._compress(data, fin, (err, result)=>{
                done();
                callback(err, result);
            });
        });
    }
    /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */ _decompress(data, fin, callback) {
        const endpoint = this._isServer ? 'client' : 'server';
        if (!this._inflate) {
            const key = `${endpoint}_max_window_bits`;
            const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
            this._inflate = zlib.createInflateRaw({
                ...this._options.zlibInflateOptions,
                windowBits
            });
            this._inflate[kPerMessageDeflate] = this;
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            this._inflate.on('error', inflateOnError);
            this._inflate.on('data', inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(()=>{
            const err = this._inflate[kError];
            if (err) {
                this._inflate.close();
                this._inflate = null;
                callback(err);
                return;
            }
            const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
            if (this._inflate._readableState.endEmitted) {
                this._inflate.close();
                this._inflate = null;
            } else {
                this._inflate[kTotalLength] = 0;
                this._inflate[kBuffers] = [];
                if (fin && this.params[`${endpoint}_no_context_takeover`]) {
                    this._inflate.reset();
                }
            }
            callback(null, data);
        });
    }
    /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */ _compress(data, fin, callback) {
        const endpoint = this._isServer ? 'server' : 'client';
        if (!this._deflate) {
            const key = `${endpoint}_max_window_bits`;
            const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
            this._deflate = zlib.createDeflateRaw({
                ...this._options.zlibDeflateOptions,
                windowBits
            });
            this._deflate[kTotalLength] = 0;
            this._deflate[kBuffers] = [];
            this._deflate.on('data', deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{
            if (!this._deflate) {
                //
                // The deflate stream was closed while data was being processed.
                //
                return;
            }
            let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
            if (fin) {
                data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
            }
            //
            // Ensure that the callback will not be called again in
            // `PerMessageDeflate#cleanup()`.
            //
            this._deflate[kCallback] = null;
            this._deflate[kTotalLength] = 0;
            this._deflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
                this._deflate.reset();
            }
            callback(null, data);
        });
    }
}
module.exports = PerMessageDeflate;
/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */ function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
}
/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */ function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
    }
    this[kError] = new RangeError('Max payload size exceeded');
    this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
    this[kError][kStatusCode] = 1009;
    this.removeListener('data', inflateOnData);
    this.reset();
}
/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */ function inflateOnError(err) {
    //
    // There is no need to call `Zlib#close()` as the handle is automatically
    // closed when an error is emitted.
    //
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
}
}),
"[project]/node_modules/ws/lib/validation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { isUtf8 } = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0 // 112 - 127
];
/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */ function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
}
/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */ function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while(i < len){
        if ((buf[i] & 0x80) === 0) {
            // 0xxxxxxx
            i++;
        } else if ((buf[i] & 0xe0) === 0xc0) {
            // 110xxxxx 10xxxxxx
            if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong
            ) {
                return false;
            }
            i += 2;
        } else if ((buf[i] & 0xf0) === 0xe0) {
            // 1110xxxx 10xxxxxx 10xxxxxx
            if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)
            ) {
                return false;
            }
            i += 3;
        } else if ((buf[i] & 0xf8) === 0xf0) {
            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
            ) {
                return false;
            }
            i += 4;
        } else {
            return false;
        }
    }
    return true;
}
module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
};
if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
} else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
        const isValidUTF8 = (()=>{
            const e = new Error("Cannot find module 'utf-8-validate'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
        module.exports.isValidUTF8 = function(buf) {
            return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
    } catch (e) {
    // Continue regardless of the error.
    }
}
}),
"[project]/node_modules/ws/lib/receiver.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Writable } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const PerMessageDeflate = __turbopack_context__.r("[project]/node_modules/ws/lib/permessage-deflate.js [app-ssr] (ecmascript)");
const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __turbopack_context__.r("[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)");
const { concat, toArrayBuffer, unmask } = __turbopack_context__.r("[project]/node_modules/ws/lib/buffer-util.js [app-ssr] (ecmascript)");
const { isValidStatusCode, isValidUTF8 } = __turbopack_context__.r("[project]/node_modules/ws/lib/validation.js [app-ssr] (ecmascript)");
const FastBuffer = Buffer[Symbol.species];
const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;
/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */ class Receiver extends Writable {
    /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */ constructor(options = {}){
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = undefined;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = undefined;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
    }
    /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */ _write(chunk, encoding, cb) {
        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
    }
    /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */ consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
            const buf = this._buffers[0];
            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
            return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
            const buf = this._buffers[0];
            const offset = dst.length - n;
            if (n >= buf.length) {
                dst.set(this._buffers.shift(), offset);
            } else {
                dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
            }
            n -= buf.length;
        }while (n > 0)
        return dst;
    }
    /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */ startLoop(cb) {
        this._loop = true;
        do {
            switch(this._state){
                case GET_INFO:
                    this.getInfo(cb);
                    break;
                case GET_PAYLOAD_LENGTH_16:
                    this.getPayloadLength16(cb);
                    break;
                case GET_PAYLOAD_LENGTH_64:
                    this.getPayloadLength64(cb);
                    break;
                case GET_MASK:
                    this.getMask();
                    break;
                case GET_DATA:
                    this.getData(cb);
                    break;
                case INFLATING:
                case DEFER_EVENT:
                    this._loop = false;
                    return;
            }
        }while (this._loop)
        if (!this._errored) cb();
    }
    /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */ getInfo(cb) {
        if (this._bufferedBytes < 2) {
            this._loop = false;
            return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 0x30) !== 0x00) {
            const error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
            cb(error);
            return;
        }
        const compressed = (buf[0] & 0x40) === 0x40;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
            const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
            cb(error);
            return;
        }
        this._fin = (buf[0] & 0x80) === 0x80;
        this._opcode = buf[0] & 0x0f;
        this._payloadLength = buf[1] & 0x7f;
        if (this._opcode === 0x00) {
            if (compressed) {
                const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                cb(error);
                return;
            }
            if (!this._fragmented) {
                const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
                cb(error);
                return;
            }
            this._opcode = this._fragmented;
        } else if (this._opcode === 0x01 || this._opcode === 0x02) {
            if (this._fragmented) {
                const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
                cb(error);
                return;
            }
            this._compressed = compressed;
        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
            if (!this._fin) {
                const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
                cb(error);
                return;
            }
            if (compressed) {
                const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                cb(error);
                return;
            }
            if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {
                const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
                cb(error);
                return;
            }
        } else {
            const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
            cb(error);
            return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 0x80) === 0x80;
        if (this._isServer) {
            if (!this._masked) {
                const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
                cb(error);
                return;
            }
        } else if (this._masked) {
            const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
            cb(error);
            return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
    }
    /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */ getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
            this._loop = false;
            return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
    }
    /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */ getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
            this._loop = false;
            return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        //
        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
        // if payload length is greater than this number.
        //
        if (num > Math.pow(2, 53 - 32) - 1) {
            const error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
            cb(error);
            return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
    }
    /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */ haveLength(cb) {
        if (this._payloadLength && this._opcode < 0x08) {
            this._totalPayloadLength += this._payloadLength;
            if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
                const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
                cb(error);
                return;
            }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
    }
    /**
   * Reads mask bytes.
   *
   * @private
   */ getMask() {
        if (this._bufferedBytes < 4) {
            this._loop = false;
            return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
    }
    /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */ getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
            if (this._bufferedBytes < this._payloadLength) {
                this._loop = false;
                return;
            }
            data = this.consume(this._payloadLength);
            if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
                unmask(data, this._mask);
            }
        }
        if (this._opcode > 0x07) {
            this.controlMessage(data, cb);
            return;
        }
        if (this._compressed) {
            this._state = INFLATING;
            this.decompress(data, cb);
            return;
        }
        if (data.length) {
            //
            // This message is not compressed so its length is the sum of the payload
            // length of all fragments.
            //
            this._messageLength = this._totalPayloadLength;
            this._fragments.push(data);
        }
        this.dataMessage(cb);
    }
    /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */ decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf)=>{
            if (err) return cb(err);
            if (buf.length) {
                this._messageLength += buf.length;
                if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
                    const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
                    cb(error);
                    return;
                }
                this._fragments.push(buf);
            }
            this.dataMessage(cb);
            if (this._state === GET_INFO) this.startLoop(cb);
        });
    }
    /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */ dataMessage(cb) {
        if (!this._fin) {
            this._state = GET_INFO;
            return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
            let data;
            if (this._binaryType === 'nodebuffer') {
                data = concat(fragments, messageLength);
            } else if (this._binaryType === 'arraybuffer') {
                data = toArrayBuffer(concat(fragments, messageLength));
            } else {
                data = fragments;
            }
            if (this._allowSynchronousEvents) {
                this.emit('message', data, true);
                this._state = GET_INFO;
            } else {
                this._state = DEFER_EVENT;
                setImmediate(()=>{
                    this.emit('message', data, true);
                    this._state = GET_INFO;
                    this.startLoop(cb);
                });
            }
        } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                cb(error);
                return;
            }
            if (this._state === INFLATING || this._allowSynchronousEvents) {
                this.emit('message', buf, false);
                this._state = GET_INFO;
            } else {
                this._state = DEFER_EVENT;
                setImmediate(()=>{
                    this.emit('message', buf, false);
                    this._state = GET_INFO;
                    this.startLoop(cb);
                });
            }
        }
    }
    /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */ controlMessage(data, cb) {
        if (this._opcode === 0x08) {
            if (data.length === 0) {
                this._loop = false;
                this.emit('conclude', 1005, EMPTY_BUFFER);
                this.end();
            } else {
                const code = data.readUInt16BE(0);
                if (!isValidStatusCode(code)) {
                    const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
                    cb(error);
                    return;
                }
                const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                    const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                    cb(error);
                    return;
                }
                this._loop = false;
                this.emit('conclude', code, buf);
                this.end();
            }
            this._state = GET_INFO;
            return;
        }
        if (this._allowSynchronousEvents) {
            this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
            this._state = GET_INFO;
        } else {
            this._state = DEFER_EVENT;
            setImmediate(()=>{
                this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
                this._state = GET_INFO;
                this.startLoop(cb);
            });
        }
    }
    /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */ createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
    }
}
module.exports = Receiver;
}),
"[project]/node_modules/ws/lib/sender.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */ const { Duplex } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { randomFillSync } = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const PerMessageDeflate = __turbopack_context__.r("[project]/node_modules/ws/lib/permessage-deflate.js [app-ssr] (ecmascript)");
const { EMPTY_BUFFER } = __turbopack_context__.r("[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)");
const { isValidStatusCode } = __turbopack_context__.r("[project]/node_modules/ws/lib/validation.js [app-ssr] (ecmascript)");
const { mask: applyMask, toBuffer } = __turbopack_context__.r("[project]/node_modules/ws/lib/buffer-util.js [app-ssr] (ecmascript)");
const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;
/**
 * HyBi Sender implementation.
 */ class Sender {
    /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */ constructor(socket, extensions, generateMask){
        this._extensions = extensions || {};
        if (generateMask) {
            this._generateMask = generateMask;
            this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
    }
    /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */ static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
            mask = options.maskBuffer || maskBuffer;
            if (options.generateMask) {
                options.generateMask(mask);
            } else {
                if (randomPoolPointer === RANDOM_POOL_SIZE) {
                    /* istanbul ignore else  */ if (randomPool === undefined) {
                        //
                        // This is lazily initialized because server-sent frames must not
                        // be masked so it may never be used.
                        //
                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
                    }
                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
                    randomPoolPointer = 0;
                }
                mask[0] = randomPool[randomPoolPointer++];
                mask[1] = randomPool[randomPoolPointer++];
                mask[2] = randomPool[randomPoolPointer++];
                mask[3] = randomPool[randomPoolPointer++];
            }
            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
            offset = 6;
        }
        let dataLength;
        if (typeof data === 'string') {
            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
                dataLength = options[kByteLength];
            } else {
                data = Buffer.from(data);
                dataLength = data.length;
            }
        } else {
            dataLength = data.length;
            merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
            offset += 8;
            payloadLength = 127;
        } else if (dataLength > 125) {
            offset += 2;
            payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
        if (options.rsv1) target[0] |= 0x40;
        target[1] = payloadLength;
        if (payloadLength === 126) {
            target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
            target[2] = target[3] = 0;
            target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [
            target,
            data
        ];
        target[1] |= 0x80;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [
            target,
            data
        ];
        if (merge) {
            applyMask(data, mask, target, offset, dataLength);
            return [
                target
            ];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [
            target,
            data
        ];
    }
    /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */ close(code, data, mask, cb) {
        let buf;
        if (code === undefined) {
            buf = EMPTY_BUFFER;
        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
            throw new TypeError('First argument must be a valid error code number');
        } else if (data === undefined || !data.length) {
            buf = Buffer.allocUnsafe(2);
            buf.writeUInt16BE(code, 0);
        } else {
            const length = Buffer.byteLength(data);
            if (length > 123) {
                throw new RangeError('The message must not be greater than 123 bytes');
            }
            buf = Buffer.allocUnsafe(2 + length);
            buf.writeUInt16BE(code, 0);
            if (typeof data === 'string') {
                buf.write(data, 2);
            } else {
                buf.set(data, 2);
            }
        }
        const options = {
            [kByteLength]: buf.length,
            fin: true,
            generateMask: this._generateMask,
            mask,
            maskBuffer: this._maskBuffer,
            opcode: 0x08,
            readOnly: false,
            rsv1: false
        };
        if (this._deflating) {
            this.enqueue([
                this.dispatch,
                buf,
                false,
                options,
                cb
            ]);
        } else {
            this.sendFrame(Sender.frame(buf, options), cb);
        }
    }
    /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */ ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === 'string') {
            byteLength = Buffer.byteLength(data);
            readOnly = false;
        } else {
            data = toBuffer(data);
            byteLength = data.length;
            readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
            throw new RangeError('The data size must not be greater than 125 bytes');
        }
        const options = {
            [kByteLength]: byteLength,
            fin: true,
            generateMask: this._generateMask,
            mask,
            maskBuffer: this._maskBuffer,
            opcode: 0x09,
            readOnly,
            rsv1: false
        };
        if (this._deflating) {
            this.enqueue([
                this.dispatch,
                data,
                false,
                options,
                cb
            ]);
        } else {
            this.sendFrame(Sender.frame(data, options), cb);
        }
    }
    /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */ pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === 'string') {
            byteLength = Buffer.byteLength(data);
            readOnly = false;
        } else {
            data = toBuffer(data);
            byteLength = data.length;
            readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
            throw new RangeError('The data size must not be greater than 125 bytes');
        }
        const options = {
            [kByteLength]: byteLength,
            fin: true,
            generateMask: this._generateMask,
            mask,
            maskBuffer: this._maskBuffer,
            opcode: 0x0a,
            readOnly,
            rsv1: false
        };
        if (this._deflating) {
            this.enqueue([
                this.dispatch,
                data,
                false,
                options,
                cb
            ]);
        } else {
            this.sendFrame(Sender.frame(data, options), cb);
        }
    }
    /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */ send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === 'string') {
            byteLength = Buffer.byteLength(data);
            readOnly = false;
        } else {
            data = toBuffer(data);
            byteLength = data.length;
            readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
            this._firstFragment = false;
            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {
                rsv1 = byteLength >= perMessageDeflate._threshold;
            }
            this._compress = rsv1;
        } else {
            rsv1 = false;
            opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
            const opts = {
                [kByteLength]: byteLength,
                fin: options.fin,
                generateMask: this._generateMask,
                mask: options.mask,
                maskBuffer: this._maskBuffer,
                opcode,
                readOnly,
                rsv1
            };
            if (this._deflating) {
                this.enqueue([
                    this.dispatch,
                    data,
                    this._compress,
                    opts,
                    cb
                ]);
            } else {
                this.dispatch(data, this._compress, opts, cb);
            }
        } else {
            this.sendFrame(Sender.frame(data, {
                [kByteLength]: byteLength,
                fin: options.fin,
                generateMask: this._generateMask,
                mask: options.mask,
                maskBuffer: this._maskBuffer,
                opcode,
                readOnly,
                rsv1: false
            }), cb);
        }
    }
    /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */ dispatch(data, compress, options, cb) {
        if (!compress) {
            this.sendFrame(Sender.frame(data, options), cb);
            return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf)=>{
            if (this._socket.destroyed) {
                const err = new Error('The socket was closed while data was being compressed');
                if (typeof cb === 'function') cb(err);
                for(let i = 0; i < this._queue.length; i++){
                    const params = this._queue[i];
                    const callback = params[params.length - 1];
                    if (typeof callback === 'function') callback(err);
                }
                return;
            }
            this._bufferedBytes -= options[kByteLength];
            this._deflating = false;
            options.readOnly = false;
            this.sendFrame(Sender.frame(buf, options), cb);
            this.dequeue();
        });
    }
    /**
   * Executes queued send operations.
   *
   * @private
   */ dequeue() {
        while(!this._deflating && this._queue.length){
            const params = this._queue.shift();
            this._bufferedBytes -= params[3][kByteLength];
            Reflect.apply(params[0], this, params.slice(1));
        }
    }
    /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */ enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
    }
    /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */ sendFrame(list, cb) {
        if (list.length === 2) {
            this._socket.cork();
            this._socket.write(list[0]);
            this._socket.write(list[1], cb);
            this._socket.uncork();
        } else {
            this._socket.write(list[0], cb);
        }
    }
}
module.exports = Sender;
}),
"[project]/node_modules/ws/lib/event-target.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { kForOnEventAttribute, kListener } = __turbopack_context__.r("[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)");
const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');
/**
 * Class representing an event.
 */ class Event {
    /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */ constructor(type){
        this[kTarget] = null;
        this[kType] = type;
    }
    /**
   * @type {*}
   */ get target() {
        return this[kTarget];
    }
    /**
   * @type {String}
   */ get type() {
        return this[kType];
    }
}
Object.defineProperty(Event.prototype, 'target', {
    enumerable: true
});
Object.defineProperty(Event.prototype, 'type', {
    enumerable: true
});
/**
 * Class representing a close event.
 *
 * @extends Event
 */ class CloseEvent extends Event {
    /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */ constructor(type, options = {}){
        super(type);
        this[kCode] = options.code === undefined ? 0 : options.code;
        this[kReason] = options.reason === undefined ? '' : options.reason;
        this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    /**
   * @type {Number}
   */ get code() {
        return this[kCode];
    }
    /**
   * @type {String}
   */ get reason() {
        return this[kReason];
    }
    /**
   * @type {Boolean}
   */ get wasClean() {
        return this[kWasClean];
    }
}
Object.defineProperty(CloseEvent.prototype, 'code', {
    enumerable: true
});
Object.defineProperty(CloseEvent.prototype, 'reason', {
    enumerable: true
});
Object.defineProperty(CloseEvent.prototype, 'wasClean', {
    enumerable: true
});
/**
 * Class representing an error event.
 *
 * @extends Event
 */ class ErrorEvent extends Event {
    /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */ constructor(type, options = {}){
        super(type);
        this[kError] = options.error === undefined ? null : options.error;
        this[kMessage] = options.message === undefined ? '' : options.message;
    }
    /**
   * @type {*}
   */ get error() {
        return this[kError];
    }
    /**
   * @type {String}
   */ get message() {
        return this[kMessage];
    }
}
Object.defineProperty(ErrorEvent.prototype, 'error', {
    enumerable: true
});
Object.defineProperty(ErrorEvent.prototype, 'message', {
    enumerable: true
});
/**
 * Class representing a message event.
 *
 * @extends Event
 */ class MessageEvent extends Event {
    /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */ constructor(type, options = {}){
        super(type);
        this[kData] = options.data === undefined ? null : options.data;
    }
    /**
   * @type {*}
   */ get data() {
        return this[kData];
    }
}
Object.defineProperty(MessageEvent.prototype, 'data', {
    enumerable: true
});
/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */ const EventTarget = {
    /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */ addEventListener (type, handler, options = {}) {
        for (const listener of this.listeners(type)){
            if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                return;
            }
        }
        let wrapper;
        if (type === 'message') {
            wrapper = function onMessage(data, isBinary) {
                const event = new MessageEvent('message', {
                    data: isBinary ? data : data.toString()
                });
                event[kTarget] = this;
                callListener(handler, this, event);
            };
        } else if (type === 'close') {
            wrapper = function onClose(code, message) {
                const event = new CloseEvent('close', {
                    code,
                    reason: message.toString(),
                    wasClean: this._closeFrameReceived && this._closeFrameSent
                });
                event[kTarget] = this;
                callListener(handler, this, event);
            };
        } else if (type === 'error') {
            wrapper = function onError(error) {
                const event = new ErrorEvent('error', {
                    error,
                    message: error.message
                });
                event[kTarget] = this;
                callListener(handler, this, event);
            };
        } else if (type === 'open') {
            wrapper = function onOpen() {
                const event = new Event('open');
                event[kTarget] = this;
                callListener(handler, this, event);
            };
        } else {
            return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
            this.once(type, wrapper);
        } else {
            this.on(type, wrapper);
        }
    },
    /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */ removeEventListener (type, handler) {
        for (const listener of this.listeners(type)){
            if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                this.removeListener(type, listener);
                break;
            }
        }
    }
};
module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
};
/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */ function callListener(listener, thisArg, event) {
    if (typeof listener === 'object' && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
    } else {
        listener.call(thisArg, event);
    }
}
}),
"[project]/node_modules/ws/lib/extension.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { tokenChars } = __turbopack_context__.r("[project]/node_modules/ws/lib/validation.js [app-ssr] (ecmascript)");
/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */ function push(dest, name, elem) {
    if (dest[name] === undefined) dest[name] = [
        elem
    ];
    else dest[name].push(elem);
}
/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */ function parse(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for(; i < header.length; i++){
        code = header.charCodeAt(i);
        if (extensionName === undefined) {
            if (end === -1 && tokenChars[code] === 1) {
                if (start === -1) start = i;
            } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {
                if (end === -1 && start !== -1) end = i;
            } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {
                if (start === -1) {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
                if (end === -1) end = i;
                const name = header.slice(start, end);
                if (code === 0x2c) {
                    push(offers, name, params);
                    params = Object.create(null);
                } else {
                    extensionName = name;
                }
                start = end = -1;
            } else {
                throw new SyntaxError(`Unexpected character at index ${i}`);
            }
        } else if (paramName === undefined) {
            if (end === -1 && tokenChars[code] === 1) {
                if (start === -1) start = i;
            } else if (code === 0x20 || code === 0x09) {
                if (end === -1 && start !== -1) end = i;
            } else if (code === 0x3b || code === 0x2c) {
                if (start === -1) {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
                if (end === -1) end = i;
                push(params, header.slice(start, end), true);
                if (code === 0x2c) {
                    push(offers, extensionName, params);
                    params = Object.create(null);
                    extensionName = undefined;
                }
                start = end = -1;
            } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {
                paramName = header.slice(start, i);
                start = end = -1;
            } else {
                throw new SyntaxError(`Unexpected character at index ${i}`);
            }
        } else {
            //
            // The value of a quoted-string after unescaping must conform to the
            // token ABNF, so only token characters are valid.
            // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
            //
            if (isEscaping) {
                if (tokenChars[code] !== 1) {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
                if (start === -1) start = i;
                else if (!mustUnescape) mustUnescape = true;
                isEscaping = false;
            } else if (inQuotes) {
                if (tokenChars[code] === 1) {
                    if (start === -1) start = i;
                } else if (code === 0x22 /* '"' */  && start !== -1) {
                    inQuotes = false;
                    end = i;
                } else if (code === 0x5c /* '\' */ ) {
                    isEscaping = true;
                } else {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
            } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
                inQuotes = true;
            } else if (end === -1 && tokenChars[code] === 1) {
                if (start === -1) start = i;
            } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
                if (end === -1) end = i;
            } else if (code === 0x3b || code === 0x2c) {
                if (start === -1) {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
                if (end === -1) end = i;
                let value = header.slice(start, end);
                if (mustUnescape) {
                    value = value.replace(/\\/g, '');
                    mustUnescape = false;
                }
                push(params, paramName, value);
                if (code === 0x2c) {
                    push(offers, extensionName, params);
                    params = Object.create(null);
                    extensionName = undefined;
                }
                paramName = undefined;
                start = end = -1;
            } else {
                throw new SyntaxError(`Unexpected character at index ${i}`);
            }
        }
    }
    if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
        throw new SyntaxError('Unexpected end of input');
    }
    if (end === -1) end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
        push(offers, token, params);
    } else {
        if (paramName === undefined) {
            push(params, token, true);
        } else if (mustUnescape) {
            push(params, paramName, token.replace(/\\/g, ''));
        } else {
            push(params, paramName, token);
        }
        push(offers, extensionName, params);
    }
    return offers;
}
/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */ function format(extensions) {
    return Object.keys(extensions).map((extension)=>{
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [
            configurations
        ];
        return configurations.map((params)=>{
            return [
                extension
            ].concat(Object.keys(params).map((k)=>{
                let values = params[k];
                if (!Array.isArray(values)) values = [
                    values
                ];
                return values.map((v)=>v === true ? k : `${k}=${v}`).join('; ');
            })).join('; ');
        }).join(', ');
    }).join(', ');
}
module.exports = {
    format,
    parse
};
}),
"[project]/node_modules/ws/lib/websocket.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */ const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
const http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
const net = __turbopack_context__.r("[externals]/net [external] (net, cjs)");
const tls = __turbopack_context__.r("[externals]/tls [external] (tls, cjs)");
const { randomBytes, createHash } = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const { Duplex, Readable } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { URL } = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const PerMessageDeflate = __turbopack_context__.r("[project]/node_modules/ws/lib/permessage-deflate.js [app-ssr] (ecmascript)");
const Receiver = __turbopack_context__.r("[project]/node_modules/ws/lib/receiver.js [app-ssr] (ecmascript)");
const Sender = __turbopack_context__.r("[project]/node_modules/ws/lib/sender.js [app-ssr] (ecmascript)");
const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = __turbopack_context__.r("[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)");
const { EventTarget: { addEventListener, removeEventListener } } = __turbopack_context__.r("[project]/node_modules/ws/lib/event-target.js [app-ssr] (ecmascript)");
const { format, parse } = __turbopack_context__.r("[project]/node_modules/ws/lib/extension.js [app-ssr] (ecmascript)");
const { toBuffer } = __turbopack_context__.r("[project]/node_modules/ws/lib/buffer-util.js [app-ssr] (ecmascript)");
const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [
    8,
    13
];
const readyStates = [
    'CONNECTING',
    'OPEN',
    'CLOSING',
    'CLOSED'
];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */ class WebSocket extends EventEmitter {
    /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */ constructor(address, protocols, options){
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = '';
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
            this._bufferedAmount = 0;
            this._isServer = false;
            this._redirects = 0;
            if (protocols === undefined) {
                protocols = [];
            } else if (!Array.isArray(protocols)) {
                if (typeof protocols === 'object' && protocols !== null) {
                    options = protocols;
                    protocols = [];
                } else {
                    protocols = [
                        protocols
                    ];
                }
            }
            initAsClient(this, address, protocols, options);
        } else {
            this._autoPong = options.autoPong;
            this._isServer = true;
        }
    }
    /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */ get binaryType() {
        return this._binaryType;
    }
    set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        //
        // Allow to change `binaryType` on the fly.
        //
        if (this._receiver) this._receiver._binaryType = type;
    }
    /**
   * @type {Number}
   */ get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    /**
   * @type {String}
   */ get extensions() {
        return Object.keys(this._extensions).join();
    }
    /**
   * @type {Boolean}
   */ get isPaused() {
        return this._paused;
    }
    /**
   * @type {Function}
   */ /* istanbul ignore next */ get onclose() {
        return null;
    }
    /**
   * @type {Function}
   */ /* istanbul ignore next */ get onerror() {
        return null;
    }
    /**
   * @type {Function}
   */ /* istanbul ignore next */ get onopen() {
        return null;
    }
    /**
   * @type {Function}
   */ /* istanbul ignore next */ get onmessage() {
        return null;
    }
    /**
   * @type {String}
   */ get protocol() {
        return this._protocol;
    }
    /**
   * @type {Number}
   */ get readyState() {
        return this._readyState;
    }
    /**
   * @type {String}
   */ get url() {
        return this._url;
    }
    /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */ setSocket(socket, head, options) {
        const receiver = new Receiver({
            allowSynchronousEvents: options.allowSynchronousEvents,
            binaryType: this.binaryType,
            extensions: this._extensions,
            isServer: this._isServer,
            maxPayload: options.maxPayload,
            skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on('conclude', receiverOnConclude);
        receiver.on('drain', receiverOnDrain);
        receiver.on('error', receiverOnError);
        receiver.on('message', receiverOnMessage);
        receiver.on('ping', receiverOnPing);
        receiver.on('pong', receiverOnPong);
        //
        // These methods may not be available if `socket` is just a `Duplex`.
        //
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on('close', socketOnClose);
        socket.on('data', socketOnData);
        socket.on('end', socketOnEnd);
        socket.on('error', socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit('open');
    }
    /**
   * Emit the `'close'` event.
   *
   * @private
   */ emitClose() {
        if (!this._socket) {
            this._readyState = WebSocket.CLOSED;
            this.emit('close', this._closeCode, this._closeMessage);
            return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
            this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
    }
    /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */ close(code, data) {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
            const msg = 'WebSocket was closed before the connection was established';
            abortHandshake(this, this._req, msg);
            return;
        }
        if (this.readyState === WebSocket.CLOSING) {
            if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
                this._socket.end();
            }
            return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err)=>{
            //
            // This error is handled by the `'error'` listener on the socket. We only
            // want to know if the close frame has been sent here.
            //
            if (err) return;
            this._closeFrameSent = true;
            if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
                this._socket.end();
            }
        });
        //
        // Specify a timeout for the closing handshake to complete.
        //
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    /**
   * Pause the socket.
   *
   * @public
   */ pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
            return;
        }
        this._paused = true;
        this._socket.pause();
    }
    /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */ ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
            throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof data === 'function') {
            cb = data;
            data = mask = undefined;
        } else if (typeof mask === 'function') {
            cb = mask;
            mask = undefined;
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
            sendAfterClose(this, data, cb);
            return;
        }
        if (mask === undefined) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */ pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
            throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof data === 'function') {
            cb = data;
            data = mask = undefined;
        } else if (typeof mask === 'function') {
            cb = mask;
            mask = undefined;
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
            sendAfterClose(this, data, cb);
            return;
        }
        if (mask === undefined) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    /**
   * Resume the socket.
   *
   * @public
   */ resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
            return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
    }
    /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */ send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
            throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
            sendAfterClose(this, data, cb);
            return;
        }
        const opts = {
            binary: typeof data !== 'string',
            mask: !this._isServer,
            compress: true,
            fin: true,
            ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
            opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    /**
   * Forcibly close the connection.
   *
   * @public
   */ terminate() {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
            const msg = 'WebSocket was closed before the connection was established';
            abortHandshake(this, this._req, msg);
            return;
        }
        if (this._socket) {
            this._readyState = WebSocket.CLOSING;
            this._socket.destroy();
        }
    }
}
/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */ Object.defineProperty(WebSocket, 'CONNECTING', {
    enumerable: true,
    value: readyStates.indexOf('CONNECTING')
});
/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */ Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
    enumerable: true,
    value: readyStates.indexOf('CONNECTING')
});
/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */ Object.defineProperty(WebSocket, 'OPEN', {
    enumerable: true,
    value: readyStates.indexOf('OPEN')
});
/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */ Object.defineProperty(WebSocket.prototype, 'OPEN', {
    enumerable: true,
    value: readyStates.indexOf('OPEN')
});
/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */ Object.defineProperty(WebSocket, 'CLOSING', {
    enumerable: true,
    value: readyStates.indexOf('CLOSING')
});
/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */ Object.defineProperty(WebSocket.prototype, 'CLOSING', {
    enumerable: true,
    value: readyStates.indexOf('CLOSING')
});
/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */ Object.defineProperty(WebSocket, 'CLOSED', {
    enumerable: true,
    value: readyStates.indexOf('CLOSED')
});
/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */ Object.defineProperty(WebSocket.prototype, 'CLOSED', {
    enumerable: true,
    value: readyStates.indexOf('CLOSED')
});
[
    'binaryType',
    'bufferedAmount',
    'extensions',
    'isPaused',
    'protocol',
    'readyState',
    'url'
].forEach((property)=>{
    Object.defineProperty(WebSocket.prototype, property, {
        enumerable: true
    });
});
//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
[
    'open',
    'error',
    'close',
    'message'
].forEach((method)=>{
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get () {
            for (const listener of this.listeners(method)){
                if (listener[kForOnEventAttribute]) return listener[kListener];
            }
            return null;
        },
        set (handler) {
            for (const listener of this.listeners(method)){
                if (listener[kForOnEventAttribute]) {
                    this.removeListener(method, listener);
                    break;
                }
            }
            if (typeof handler !== 'function') return;
            this.addEventListener(method, handler, {
                [kForOnEventAttribute]: true
            });
        }
    });
});
WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;
module.exports = WebSocket;
/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */ function initAsClient(websocket, address, protocols, options) {
    const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: undefined,
        hostname: undefined,
        protocol: undefined,
        timeout: undefined,
        method: 'GET',
        host: undefined,
        path: undefined,
        port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);
    }
    let parsedUrl;
    if (address instanceof URL) {
        parsedUrl = address;
    } else {
        try {
            parsedUrl = new URL(address);
        } catch (e) {
            throw new SyntaxError(`Invalid URL: ${address}`);
        }
    }
    if (parsedUrl.protocol === 'http:') {
        parsedUrl.protocol = 'ws:';
    } else if (parsedUrl.protocol === 'https:') {
        parsedUrl.protocol = 'wss:';
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === 'wss:';
    const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
    let invalidUrlMessage;
    if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
        invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", ' + '"http:", "https", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
        invalidUrlMessage = 'The URL contains a fragment identifier';
    }
    if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
            throw err;
        } else {
            emitErrorAndClose(websocket, err);
            return;
        }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString('base64');
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set();
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
        ...opts.headers,
        'Sec-WebSocket-Version': opts.protocolVersion,
        'Sec-WebSocket-Key': key,
        Connection: 'Upgrade',
        Upgrade: 'websocket'
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers['Sec-WebSocket-Extensions'] = format({
            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
    }
    if (protocols.length) {
        for (const protocol of protocols){
            if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
                throw new SyntaxError('An invalid or duplicated subprotocol was specified');
            }
            protocolSet.add(protocol);
        }
        opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
    }
    if (opts.origin) {
        if (opts.protocolVersion < 13) {
            opts.headers['Sec-WebSocket-Origin'] = opts.origin;
        } else {
            opts.headers.Origin = opts.origin;
        }
    }
    if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
        const parts = opts.path.split(':');
        opts.socketPath = parts[0];
        opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
        if (websocket._redirects === 0) {
            websocket._originalIpc = isIpcUrl;
            websocket._originalSecure = isSecure;
            websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
            const headers = options && options.headers;
            //
            // Shallow copy the user provided options so that headers can be changed
            // without mutating the original object.
            //
            options = {
                ...options,
                headers: {}
            };
            if (headers) {
                for (const [key, value] of Object.entries(headers)){
                    options.headers[key.toLowerCase()] = value;
                }
            }
        } else if (websocket.listenerCount('redirect') === 0) {
            const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
            if (!isSameHost || websocket._originalSecure && !isSecure) {
                //
                // Match curl 7.77.0 behavior and drop the following headers. These
                // headers are also dropped when following a redirect to a subdomain.
                //
                delete opts.headers.authorization;
                delete opts.headers.cookie;
                if (!isSameHost) delete opts.headers.host;
                opts.auth = undefined;
            }
        }
        //
        // Match curl 7.77.0 behavior and make the first `Authorization` header win.
        // If the `Authorization` header is set, then there is nothing to do as it
        // will take precedence.
        //
        if (opts.auth && !options.headers.authorization) {
            options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
            //
            // Unlike what is done for the `'upgrade'` event, no early exit is
            // triggered here if the user calls `websocket.close()` or
            // `websocket.terminate()` from a listener of the `'redirect'` event. This
            // is because the user can also call `request.destroy()` with an error
            // before calling `websocket.close()` or `websocket.terminate()` and this
            // would result in an error being emitted on the `request` object with no
            // `'error'` event listeners attached.
            //
            websocket.emit('redirect', websocket.url, req);
        }
    } else {
        req = websocket._req = request(opts);
    }
    if (opts.timeout) {
        req.on('timeout', ()=>{
            abortHandshake(websocket, req, 'Opening handshake has timed out');
        });
    }
    req.on('error', (err)=>{
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
    });
    req.on('response', (res)=>{
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
            if (++websocket._redirects > opts.maxRedirects) {
                abortHandshake(websocket, req, 'Maximum redirects exceeded');
                return;
            }
            req.abort();
            let addr;
            try {
                addr = new URL(location, address);
            } catch (e) {
                const err = new SyntaxError(`Invalid URL: ${location}`);
                emitErrorAndClose(websocket, err);
                return;
            }
            initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit('unexpected-response', req, res)) {
            abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
    });
    req.on('upgrade', (res, socket, head)=>{
        websocket.emit('upgrade', res);
        //
        // The user may have closed the connection from a listener of the
        // `'upgrade'` event.
        //
        if (websocket.readyState !== WebSocket.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
            abortHandshake(websocket, socket, 'Invalid Upgrade header');
            return;
        }
        const digest = createHash('sha1').update(key + GUID).digest('base64');
        if (res.headers['sec-websocket-accept'] !== digest) {
            abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
            return;
        }
        const serverProt = res.headers['sec-websocket-protocol'];
        let protError;
        if (serverProt !== undefined) {
            if (!protocolSet.size) {
                protError = 'Server sent a subprotocol but none was requested';
            } else if (!protocolSet.has(serverProt)) {
                protError = 'Server sent an invalid subprotocol';
            }
        } else if (protocolSet.size) {
            protError = 'Server sent no subprotocol';
        }
        if (protError) {
            abortHandshake(websocket, socket, protError);
            return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers['sec-websocket-extensions'];
        if (secWebSocketExtensions !== undefined) {
            if (!perMessageDeflate) {
                const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
                abortHandshake(websocket, socket, message);
                return;
            }
            let extensions;
            try {
                extensions = parse(secWebSocketExtensions);
            } catch (err) {
                const message = 'Invalid Sec-WebSocket-Extensions header';
                abortHandshake(websocket, socket, message);
                return;
            }
            const extensionNames = Object.keys(extensions);
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
                const message = 'Server indicated an extension that was not requested';
                abortHandshake(websocket, socket, message);
                return;
            }
            try {
                perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
                const message = 'Invalid Sec-WebSocket-Extensions header';
                abortHandshake(websocket, socket, message);
                return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
            allowSynchronousEvents: opts.allowSynchronousEvents,
            generateMask: opts.generateMask,
            maxPayload: opts.maxPayload,
            skipUTF8Validation: opts.skipUTF8Validation
        });
    });
    if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
    } else {
        req.end();
    }
}
/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */ function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
}
/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */ function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
}
/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */ function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== '') {
        options.servername = net.isIP(options.host) ? '' : options.host;
    }
    return tls.connect(options);
}
/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */ function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
            //
            // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
            // called after the request completed. See
            // https://github.com/websockets/ws/issues/1869.
            //
            stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
    } else {
        stream.destroy(err);
        stream.once('error', websocket.emit.bind(websocket, 'error'));
        stream.once('close', websocket.emitClose.bind(websocket));
    }
}
/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */ function sendAfterClose(websocket, data, cb) {
    if (data) {
        const length = toBuffer(data).length;
        //
        // The `_bufferedAmount` property is used only when the peer is a client and
        // the opening handshake fails. Under these circumstances, in fact, the
        // `setSocket()` method is not called, so the `_socket` and `_sender`
        // properties are set to `null`.
        //
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
    }
    if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
        process.nextTick(cb, err);
    }
}
/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */ function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined) return;
    websocket._socket.removeListener('data', socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005) websocket.close();
    else websocket.close(code, reason);
}
/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */ function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused) websocket._socket.resume();
}
/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */ function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
        websocket._socket.removeListener('data', socketOnData);
        //
        // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
        // https://github.com/websockets/ws/issues/1940.
        //
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
    }
    websocket.emit('error', err);
}
/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */ function receiverOnFinish() {
    this[kWebSocket].emitClose();
}
/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */ function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit('message', data, isBinary);
}
/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */ function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
    websocket.emit('ping', data);
}
/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */ function receiverOnPong(data) {
    this[kWebSocket].emit('pong', data);
}
/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */ function resume(stream) {
    stream.resume();
}
/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */ function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener('close', socketOnClose);
    this.removeListener('data', socketOnData);
    this.removeListener('end', socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    //
    // The close frame might not have been received or the `'end'` event emitted,
    // for example, if the socket was destroyed due to an error. Ensure that the
    // `receiver` stream is closed after writing any remaining buffered data to
    // it. If the readable side of the socket is in flowing mode then there is no
    // buffered data as everything has been already written and `readable.read()`
    // will return `null`. If instead, the socket is paused, any possible buffered
    // data will be read as a single chunk.
    //
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
    } else {
        websocket._receiver.on('error', receiverOnFinish);
        websocket._receiver.on('finish', receiverOnFinish);
    }
}
/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */ function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
    }
}
/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */ function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
}
/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */ function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener('error', socketOnError);
    this.on('error', NOOP);
    if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
    }
}
}),
"[project]/node_modules/ws/lib/subprotocol.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { tokenChars } = __turbopack_context__.r("[project]/node_modules/ws/lib/validation.js [app-ssr] (ecmascript)");
/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */ function parse(header) {
    const protocols = new Set();
    let start = -1;
    let end = -1;
    let i = 0;
    for(i; i < header.length; i++){
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
        } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {
            if (end === -1 && start !== -1) end = i;
        } else if (code === 0x2c /* ',' */ ) {
            if (start === -1) {
                throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const protocol = header.slice(start, end);
            if (protocols.has(protocol)) {
                throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
            }
            protocols.add(protocol);
            start = end = -1;
        } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
        }
    }
    if (start === -1 || end !== -1) {
        throw new SyntaxError('Unexpected end of input');
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
}
module.exports = {
    parse
};
}),
"[project]/node_modules/ws/lib/websocket-server.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */ const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
const { Duplex } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { createHash } = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const extension = __turbopack_context__.r("[project]/node_modules/ws/lib/extension.js [app-ssr] (ecmascript)");
const PerMessageDeflate = __turbopack_context__.r("[project]/node_modules/ws/lib/permessage-deflate.js [app-ssr] (ecmascript)");
const subprotocol = __turbopack_context__.r("[project]/node_modules/ws/lib/subprotocol.js [app-ssr] (ecmascript)");
const WebSocket = __turbopack_context__.r("[project]/node_modules/ws/lib/websocket.js [app-ssr] (ecmascript)");
const { GUID, kWebSocket } = __turbopack_context__.r("[project]/node_modules/ws/lib/constants.js [app-ssr] (ecmascript)");
const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;
/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */ class WebSocketServer extends EventEmitter {
    /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */ constructor(options, callback){
        super();
        options = {
            allowSynchronousEvents: true,
            autoPong: true,
            maxPayload: 100 * 1024 * 1024,
            skipUTF8Validation: false,
            perMessageDeflate: false,
            handleProtocols: null,
            clientTracking: true,
            verifyClient: null,
            noServer: false,
            backlog: null,
            server: null,
            host: null,
            path: null,
            port: null,
            WebSocket,
            ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
            throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
        }
        if (options.port != null) {
            this._server = http.createServer((req, res)=>{
                const body = http.STATUS_CODES[426];
                res.writeHead(426, {
                    'Content-Length': body.length,
                    'Content-Type': 'text/plain'
                });
                res.end(body);
            });
            this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
            this._server = options.server;
        }
        if (this._server) {
            const emitConnection = this.emit.bind(this, 'connection');
            this._removeListeners = addListeners(this._server, {
                listening: this.emit.bind(this, 'listening'),
                error: this.emit.bind(this, 'error'),
                upgrade: (req, socket, head)=>{
                    this.handleUpgrade(req, socket, head, emitConnection);
                }
            });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
            this.clients = new Set();
            this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
    }
    /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */ address() {
        if (this.options.noServer) {
            throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
    }
    /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */ close(cb) {
        if (this._state === CLOSED) {
            if (cb) {
                this.once('close', ()=>{
                    cb(new Error('The server is not running'));
                });
            }
            process.nextTick(emitClose, this);
            return;
        }
        if (cb) this.once('close', cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
            if (this._server) {
                this._removeListeners();
                this._removeListeners = this._server = null;
            }
            if (this.clients) {
                if (!this.clients.size) {
                    process.nextTick(emitClose, this);
                } else {
                    this._shouldEmitClose = true;
                }
            } else {
                process.nextTick(emitClose, this);
            }
        } else {
            const server = this._server;
            this._removeListeners();
            this._removeListeners = this._server = null;
            //
            // The HTTP/S server was created internally. Close it, and rely on its
            // `'close'` event.
            //
            server.close(()=>{
                emitClose(this);
            });
        }
    }
    /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */ shouldHandle(req) {
        if (this.options.path) {
            const index = req.url.indexOf('?');
            const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
            if (pathname !== this.options.path) return false;
        }
        return true;
    }
    /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */ handleUpgrade(req, socket, head, cb) {
        socket.on('error', socketOnError);
        const key = req.headers['sec-websocket-key'];
        const upgrade = req.headers.upgrade;
        const version = +req.headers['sec-websocket-version'];
        if (req.method !== 'GET') {
            const message = 'Invalid HTTP method';
            abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
            return;
        }
        if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
            const message = 'Invalid Upgrade header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
        }
        if (key === undefined || !keyRegex.test(key)) {
            const message = 'Missing or invalid Sec-WebSocket-Key header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
        }
        if (version !== 8 && version !== 13) {
            const message = 'Missing or invalid Sec-WebSocket-Version header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
        }
        if (!this.shouldHandle(req)) {
            abortHandshake(socket, 400);
            return;
        }
        const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
        let protocols = new Set();
        if (secWebSocketProtocol !== undefined) {
            try {
                protocols = subprotocol.parse(secWebSocketProtocol);
            } catch (err) {
                const message = 'Invalid Sec-WebSocket-Protocol header';
                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                return;
            }
        }
        const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
            const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
            try {
                const offers = extension.parse(secWebSocketExtensions);
                if (offers[PerMessageDeflate.extensionName]) {
                    perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                }
            } catch (err) {
                const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';
                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                return;
            }
        }
        //
        // Optionally call external client verification handler.
        //
        if (this.options.verifyClient) {
            const info = {
                origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
                secure: !!(req.socket.authorized || req.socket.encrypted),
                req
            };
            if (this.options.verifyClient.length === 2) {
                this.options.verifyClient(info, (verified, code, message, headers)=>{
                    if (!verified) {
                        return abortHandshake(socket, code || 401, message, headers);
                    }
                    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
                });
                return;
            }
            if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */ completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        //
        // Destroy the socket if the client has already sent a FIN packet.
        //
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
            throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash('sha1').update(key + GUID).digest('base64');
        const headers = [
            'HTTP/1.1 101 Switching Protocols',
            'Upgrade: websocket',
            'Connection: Upgrade',
            `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, undefined, this.options);
        if (protocols.size) {
            //
            // Optionally call external protocol selection handler.
            //
            const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
            if (protocol) {
                headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
                ws._protocol = protocol;
            }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
            const params = extensions[PerMessageDeflate.extensionName].params;
            const value = extension.format({
                [PerMessageDeflate.extensionName]: [
                    params
                ]
            });
            headers.push(`Sec-WebSocket-Extensions: ${value}`);
            ws._extensions = extensions;
        }
        //
        // Allow external modification/inspection of handshake headers.
        //
        this.emit('headers', headers, req);
        socket.write(headers.concat('\r\n').join('\r\n'));
        socket.removeListener('error', socketOnError);
        ws.setSocket(socket, head, {
            allowSynchronousEvents: this.options.allowSynchronousEvents,
            maxPayload: this.options.maxPayload,
            skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
            this.clients.add(ws);
            ws.on('close', ()=>{
                this.clients.delete(ws);
                if (this._shouldEmitClose && !this.clients.size) {
                    process.nextTick(emitClose, this);
                }
            });
        }
        cb(ws, req);
    }
}
module.exports = WebSocketServer;
/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */ function addListeners(server, map) {
    for (const event of Object.keys(map))server.on(event, map[event]);
    return function removeListeners() {
        for (const event of Object.keys(map)){
            server.removeListener(event, map[event]);
        }
    };
}
/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */ function emitClose(server) {
    server._state = CLOSED;
    server.emit('close');
}
/**
 * Handle socket errors.
 *
 * @private
 */ function socketOnError() {
    this.destroy();
}
/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */ function abortHandshake(socket, code, message, headers) {
    //
    // The socket is writable unless the user destroyed or ended it before calling
    // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
    // error. Handling this does not make much sense as the worst that can happen
    // is that some of the data written by the user might be discarded due to the
    // call to `socket.end()` below, which triggers an `'error'` event that in
    // turn causes the socket to be destroyed.
    //
    message = message || http.STATUS_CODES[code];
    headers = {
        Connection: 'close',
        'Content-Type': 'text/html',
        'Content-Length': Buffer.byteLength(message),
        ...headers
    };
    socket.once('finish', socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join('\r\n') + '\r\n\r\n' + message);
}
/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */ function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
    if (server.listenerCount('wsClientError')) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit('wsClientError', err, socket, req);
    } else {
        abortHandshake(socket, code, message);
    }
}
}),
"[project]/node_modules/ws/wrapper.mjs [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ws/lib/stream.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$receiver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ws/lib/receiver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$sender$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ws/lib/sender.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ws/lib/websocket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$websocket$2d$server$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ws/lib/websocket-server.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/ws/lib/websocket.js [app-ssr] (ecmascript) <export default as WebSocket>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebSocket",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ws/lib/websocket.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/websocket.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseWS",
    ()=>BaseWS,
    "WS",
    ()=>WS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transport.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$encodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/encodePacket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("engine.io-client:websocket"); // debug()
// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Transport"] {
    get name() {
        return "websocket";
    }
    doOpen() {
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative ? {} : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pick"])(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws = this.createSocket(uri, protocols, opts);
        } catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */ addEventListeners() {
        this.ws.onopen = ()=>{
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent)=>this.onClose({
                description: "websocket connection closed",
                context: closeEvent
            });
        this.ws.onmessage = (ev)=>this.onData(ev.data);
        this.ws.onerror = (e)=>this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for(let i = 0; i < packets.length; i++){
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$encodePacket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodePacket"])(packet, this.supportsBinary, (data)=>{
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    this.doWrite(packet, data);
                } catch (e) {
                    debug("websocket closed before onclose event");
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.onerror = ()=>{};
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */ uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomString"])();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
const WebSocketCtor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"].WebSocket || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["globalThisShim"].MozWebSocket;
class WS extends BaseWS {
    createSocket(uri, protocols, opts) {
        return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
    }
    doWrite(_packet, data) {
        this.ws.send(data);
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WS",
    ()=>WS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$wrapper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/ws/wrapper.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__WebSocket$3e$__ = __turbopack_context__.i("[project]/node_modules/ws/lib/websocket.js [app-ssr] (ecmascript) <export default as WebSocket>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/websocket.js [app-ssr] (ecmascript)");
;
;
class WS extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseWS"] {
    createSocket(uri, protocols, opts) {
        var _a;
        if ((_a = this.socket) === null || _a === void 0 ? void 0 : _a._cookieJar) {
            opts.headers = opts.headers || {};
            opts.headers.cookie = typeof opts.headers.cookie === "string" ? [
                opts.headers.cookie
            ] : opts.headers.cookie || [];
            for (const [name, cookie] of this.socket._cookieJar.cookies){
                opts.headers.cookie.push(`${name}=${cookie.value}`);
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$lib$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__WebSocket$3e$__["WebSocket"](uri, protocols, opts);
    }
    doWrite(packet, data) {
        const opts = {};
        if (packet.options) {
            opts.compress = packet.options.compress;
        }
        if (this.opts.perMessageDeflate) {
            const len = // @ts-ignore
            "string" === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < this.opts.perMessageDeflate.threshold) {
                opts.compress = false;
            }
        }
        this.ws.send(data, opts);
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/webtransport.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WT",
    ()=>WT
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transport.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("engine.io-client:webtransport"); // debug()
class WT extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Transport"] {
    get name() {
        return "webtransport";
    }
    doOpen() {
        try {
            // @ts-ignore
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        } catch (err) {
            return this.emitReserved("error", err);
        }
        this._transport.closed.then(()=>{
            debug("transport closed gracefully");
            this.onClose();
        }).catch((err)=>{
            debug("transport closed due to %s", err);
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this._transport.ready.then(()=>{
            this._transport.createBidirectionalStream().then((stream)=>{
                const decoderStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createPacketDecoderStream"])(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createPacketEncoderStream"])();
                encoderStream.readable.pipeTo(stream.writable);
                this._writer = encoderStream.writable.getWriter();
                const read = ()=>{
                    reader.read().then(({ done, value })=>{
                        if (done) {
                            debug("session is closed");
                            return;
                        }
                        debug("received chunk: %o", value);
                        this.onPacket(value);
                        read();
                    }).catch((err)=>{
                        debug("an error occurred while reading: %s", err);
                    });
                };
                read();
                const packet = {
                    type: "open"
                };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
                this._writer.write(packet).then(()=>this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for(let i = 0; i < packets.length; i++){
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this._writer.write(packet).then(()=>{
                if (lastPacket) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "transports",
    ()=>transports
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$xhr$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$websocket$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$webtransport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/webtransport.js [app-ssr] (ecmascript)");
;
;
;
const transports = {
    websocket: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$websocket$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WS"],
    webtransport: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$webtransport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WT"],
    polling: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$xhr$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XHR"]
};
}),
"[project]/node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */ __turbopack_context__.s([
    "parse",
    ()=>parse
]);
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
    'source',
    'protocol',
    'authority',
    'userInfo',
    'user',
    'password',
    'host',
    'port',
    'relative',
    'path',
    'directory',
    'file',
    'query',
    'anchor'
];
function parse(str) {
    if (str.length > 8000) {
        throw "URI too long";
    }
    const src = str, b = str.indexOf('['), e = str.indexOf(']');
    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }
    let m = re.exec(str || ''), uri = {}, i = 14;
    while(i--){
        uri[parts[i]] = m[i] || '';
    }
    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
}
function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.slice(-1) == '/') {
        names.splice(names.length - 1, 1);
    }
    return names;
}
function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });
    return data;
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/socket.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Socket",
    ()=>Socket,
    "SocketWithUpgrade",
    ()=>SocketWithUpgrade,
    "SocketWithoutUpgrade",
    ()=>SocketWithoutUpgrade
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseqs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseuri$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@socket.io/component-emitter/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-parser/build/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("engine.io-client:socket"); // debug()
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
    // script, so we create one single event listener here which will forward the event to the socket instances
    addEventListener("offline", ()=>{
        debug("closing %d connection(s) because the network was lost", OFFLINE_EVENT_LISTENERS.length);
        OFFLINE_EVENT_LISTENERS.forEach((listener)=>listener());
    }, false);
}
class SocketWithoutUpgrade extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Emitter"] {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */ constructor(uri, opts){
        super();
        this.binaryType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaultBinaryType"];
        this.writeBuffer = [];
        this._prevBufferLen = 0;
        this._pingInterval = -1;
        this._pingTimeout = -1;
        this._maxPayload = -1;
        /**
         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
         */ this._pingTimeoutTime = Infinity;
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            const parsedUri = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseuri$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(uri);
            opts.hostname = parsedUri.host;
            opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
            opts.port = parsedUri.port;
            if (parsedUri.query) opts.query = parsedUri.query;
        } else if (opts.host) {
            opts.hostname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseuri$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(opts.host).host;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["installTimerFunctions"])(this, opts);
        this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
        this.transports = [];
        this._transportsByName = {};
        opts.transports.forEach((t)=>{
            const transportName = t.prototype.name;
            this.transports.push(transportName);
            this._transportsByName[transportName] = t;
        });
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: false
        }, opts);
        this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
            this.opts.query = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseqs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(this.opts.query);
        }
        if (withEventListeners) {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this._beforeunloadEventListener = ()=>{
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener("beforeunload", this._beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
                debug("adding listener for the 'offline' event");
                this._offlineEventListener = ()=>{
                    this._onClose("transport close", {
                        description: "network connection lost"
                    });
                };
                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
            }
        }
        if (this.opts.withCredentials) {
            this._cookieJar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCookieJar"])();
        }
        this._open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */ createTransport(name) {
        debug('creating transport "%s"', name);
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["protocol"];
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id) query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        }, this.opts.transportOptions[name]);
        debug("options: %j", opts);
        return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */ _open() {
        if (this.transports.length === 0) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(()=>{
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
        this.readyState = "opening";
        const transport = this.createTransport(transportName);
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */ setTransport(transport) {
        debug("setting transport %s", transport.name);
        if (this.transport) {
            debug("clearing existing transport %s", this.transport.name);
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason)=>this._onClose("transport close", reason));
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */ onOpen() {
        debug("socket open");
        this.readyState = "open";
        SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */ _onPacket(packet) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            switch(packet.type){
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this._sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    this._resetPingTimeout();
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this._onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        } else {
            debug('packet received with socket readyState "%s"', this.readyState);
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */ onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this._pingInterval = data.pingInterval;
        this._pingTimeout = data.pingTimeout;
        this._maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState) return;
        this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */ _resetPingTimeout() {
        this.clearTimeoutFn(this._pingTimeoutTimer);
        const delay = this._pingInterval + this._pingTimeout;
        this._pingTimeoutTime = Date.now() + delay;
        this._pingTimeoutTimer = this.setTimeoutFn(()=>{
            this._onClose("ping timeout");
        }, delay);
        if (this.opts.autoUnref) {
            this._pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */ _onDrain() {
        this.writeBuffer.splice(0, this._prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this._prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        } else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */ flush() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            const packets = this._getWritablePackets();
            debug("flushing %d packets in socket", packets.length);
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this._prevBufferLen = packets.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */ _getWritablePackets() {
        const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
        }
        let payloadSize = 1; // first packet type
        for(let i = 0; i < this.writeBuffer.length; i++){
            const data = this.writeBuffer[i].data;
            if (data) {
                payloadSize += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteLength"])(data);
            }
            if (i > 0 && payloadSize > this._maxPayload) {
                debug("only send %d out of %d packets", i, this.writeBuffer.length);
                return this.writeBuffer.slice(0, i);
            }
            payloadSize += 2; // separator + packet type
        }
        debug("payload size is %d (max: %d)", payloadSize, this._maxPayload);
        return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */ /* private */ _hasPingExpired() {
        if (!this._pingTimeoutTime) return true;
        const hasExpired = Date.now() > this._pingTimeoutTime;
        if (hasExpired) {
            debug("throttled timer detected, scheduling connection close");
            this._pingTimeoutTime = 0;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                this._onClose("ping timeout");
            }, this.setTimeoutFn);
        }
        return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */ write(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */ send(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */ _sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn) this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */ close() {
        const close = ()=>{
            this._onClose("forced close");
            debug("socket closing - telling transport to close");
            this.transport.close();
        };
        const cleanupAndClose = ()=>{
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = ()=>{
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", ()=>{
                    if (this.upgrading) {
                        waitForUpgrade();
                    } else {
                        close();
                    }
                });
            } else if (this.upgrading) {
                waitForUpgrade();
            } else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */ _onError(err) {
        debug("socket error %j", err);
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
            debug("trying next transport");
            this.transports.shift();
            return this._open();
        }
        this.emitReserved("error", err);
        this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */ _onClose(reason, description) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
            debug('socket close with reason: "%s"', reason);
            // clear timers
            this.clearTimeoutFn(this._pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (withEventListeners) {
                if (this._beforeunloadEventListener) {
                    removeEventListener("beforeunload", this._beforeunloadEventListener, false);
                }
                if (this._offlineEventListener) {
                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
                    if (i !== -1) {
                        debug("removing listener for the 'offline' event");
                        OFFLINE_EVENT_LISTENERS.splice(i, 1);
                    }
                }
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this._prevBufferLen = 0;
        }
    }
}
SocketWithoutUpgrade.protocol = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$parser$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["protocol"];
class SocketWithUpgrade extends SocketWithoutUpgrade {
    constructor(){
        super(...arguments);
        this._upgrades = [];
    }
    onOpen() {
        super.onOpen();
        if ("open" === this.readyState && this.opts.upgrade) {
            debug("starting upgrade probes");
            for(let i = 0; i < this._upgrades.length; i++){
                this._probe(this._upgrades[i]);
            }
        }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */ _probe(name) {
        debug('probing transport "%s"', name);
        let transport = this.createTransport(name);
        let failed = false;
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        const onTransportOpen = ()=>{
            if (failed) return;
            debug('probe transport "%s" opened', name);
            transport.send([
                {
                    type: "ping",
                    data: "probe"
                }
            ]);
            transport.once("packet", (msg)=>{
                if (failed) return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    debug('probe transport "%s" pong', name);
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport) return;
                    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
                    debug('pausing current transport "%s"', this.transport.name);
                    this.transport.pause(()=>{
                        if (failed) return;
                        if ("closed" === this.readyState) return;
                        debug("changing transport and sending upgrade packet");
                        cleanup();
                        this.setTransport(transport);
                        transport.send([
                            {
                                type: "upgrade"
                            }
                        ]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                } else {
                    debug('probe transport "%s" failed', name);
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed) return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err)=>{
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            debug('probe transport "%s" failed because of error: %s', name, err);
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                debug('"%s" works - aborting "%s"', to.name, transport.name);
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = ()=>{
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
            // favor WebTransport
            this.setTimeoutFn(()=>{
                if (!failed) {
                    transport.open();
                }
            }, 200);
        } else {
            transport.open();
        }
    }
    onHandshake(data) {
        this._upgrades = this._filterUpgrades(data.upgrades);
        super.onHandshake(data);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */ _filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        for(let i = 0; i < upgrades.length; i++){
            if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
class Socket extends SocketWithUpgrade {
    constructor(uri, opts = {}){
        const o = typeof uri === "object" ? uri : opts;
        if (!o.transports || o.transports && typeof o.transports[0] === "string") {
            o.transports = (o.transports || [
                "polling",
                "websocket",
                "webtransport"
            ]).map((transportName)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transports"][transportName]).filter((t)=>!!t);
        }
        super(uri, o);
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Fetch",
    ()=>Fetch
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/polling.js [app-ssr] (ecmascript)");
;
class Fetch extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Polling"] {
    doPoll() {
        this._fetch().then((res)=>{
            if (!res.ok) {
                return this.onError("fetch read error", res.status, res);
            }
            res.text().then((data)=>this.onData(data));
        }).catch((err)=>{
            this.onError("fetch read error", err);
        });
    }
    doWrite(data, callback) {
        this._fetch(data).then((res)=>{
            if (!res.ok) {
                return this.onError("fetch write error", res.status, res);
            }
            callback();
        }).catch((err)=>{
            this.onError("fetch write error", err);
        });
    }
    _fetch(data) {
        var _a;
        const isPost = data !== undefined;
        const headers = new Headers(this.opts.extraHeaders);
        if (isPost) {
            headers.set("content-type", "text/plain;charset=UTF-8");
        }
        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
        return fetch(this.uri(), {
            method: isPost ? "POST" : "GET",
            body: isPost ? data : null,
            headers,
            credentials: this.opts.withCredentials ? "include" : "omit"
        }).then((res)=>{
            var _a;
            // @ts-ignore getSetCookie() was added in Node.js v19.7.0
            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());
            return res;
        });
    }
}
}),
"[project]/node_modules/engine.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "protocol",
    ()=>protocol
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/socket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transport.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseuri$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$xhr$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$polling$2d$xhr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$websocket$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$websocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/websocket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$transports$2f$webtransport$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/transports/webtransport.js [app-ssr] (ecmascript)");
;
;
;
const protocol = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Socket"].protocol;
;
;
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/socket.io-client/node_modules/debug/src/common.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-ssr] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) {
                continue;
            }
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
            } else {
                createDebug.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === '*') {
            return true;
        }
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) {
                return false;
            }
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/socket.io-client/node_modules/debug/src/node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-ssr] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-client/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/socket.io-client/node_modules/debug/src/browser.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-client/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/socket.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-client/node_modules/debug/src/browser.js [app-ssr] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-client/node_modules/debug/src/node.js [app-ssr] (ecmascript)");
}
}),
"[project]/node_modules/socket.io-client/build/esm-debug/url.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "url",
    ()=>url
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseuri$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("socket.io-client:url"); // debug()
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || typeof location !== "undefined" && location;
    if (null == uri) uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            } else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            } else {
                uri = "https://" + uri;
            }
        }
        // parse
        debug("parse %s", uri);
        obj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$parseuri$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}
}),
"[project]/node_modules/socket.io-parser/build/esm-debug/is-binary.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasBinary",
    ()=>hasBinary,
    "isBinary",
    ()=>isBinary
]);
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj)=>{
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for(let i = 0, l = obj.length; i < l; i++){
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for(const key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}
}),
"[project]/node_modules/socket.io-parser/build/esm-debug/binary.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deconstructPacket",
    ()=>deconstructPacket,
    "reconstructPacket",
    ()=>reconstructPacket
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$is$2d$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-parser/build/esm-debug/is-binary.js [app-ssr] (ecmascript)");
;
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return {
        packet: pack,
        buffers: buffers
    };
}
function _deconstructPacket(data, buffers) {
    if (!data) return data;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$is$2d$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBinary"])(data)) {
        const placeholder = {
            _placeholder: true,
            num: buffers.length
        };
        buffers.push(data);
        return placeholder;
    } else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for(let i = 0; i < data.length; i++){
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for(const key in data){
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
function _reconstructPacket(data, buffers) {
    if (!data) return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        } else {
            throw new Error("illegal attachments");
        }
    } else if (Array.isArray(data)) {
        for(let i = 0; i < data.length; i++){
            data[i] = _reconstructPacket(data[i], buffers);
        }
    } else if (typeof data === "object") {
        for(const key in data){
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}
}),
"[project]/node_modules/socket.io-parser/node_modules/debug/src/common.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-ssr] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) {
                continue;
            }
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
            } else {
                createDebug.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === '*') {
            return true;
        }
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) {
                return false;
            }
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/socket.io-parser/node_modules/debug/src/node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-ssr] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-parser/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/socket.io-parser/node_modules/debug/src/browser.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-parser/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/socket.io-parser/node_modules/debug/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-parser/node_modules/debug/src/browser.js [app-ssr] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/socket.io-parser/node_modules/debug/src/node.js [app-ssr] (ecmascript)");
}
}),
"[project]/node_modules/socket.io-parser/build/esm-debug/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Decoder",
    ()=>Decoder,
    "Encoder",
    ()=>Encoder,
    "PacketType",
    ()=>PacketType,
    "protocol",
    ()=>protocol
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@socket.io/component-emitter/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-parser/build/esm-debug/binary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$is$2d$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-parser/build/esm-debug/is-binary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-parser/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("socket.io-parser"); // debug()
/**
 * These strings must not be used as event names, as they have a special meaning.
 */ const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
];
const protocol = 5;
var PacketType;
(function(PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */ constructor(replacer){
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */ encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$is$2d$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasBinary"])(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id
                });
            }
        }
        return [
            this.encodeAsString(obj)
        ];
    }
    /**
     * Encode packet as string.
     */ encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */ encodeAsBinary(obj) {
        const deconstruction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deconstructPacket"])(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
class Decoder extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Emitter"] {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */ constructor(reviver){
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */ add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            } else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$is$2d$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBinary"])(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            } else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        } else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */ decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while(str.charAt(++i) !== "-" && i != str.length){}
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while(++i){
                const c = str.charAt(i);
                if ("," === c) break;
                if (i === str.length) break;
            }
            p.nsp = str.substring(start, i);
        } else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while(++i){
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length) break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            } else {
                throw new Error("invalid payload");
            }
        }
        debug("decoded %s as %j", str, p);
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        } catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch(type){
            case PacketType.CONNECT:
                return isObject(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */ destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */ class BinaryReconstructor {
    constructor(packet){
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */ takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$binary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reconstructPacket"])(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */ finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}
}),
"[project]/node_modules/socket.io-client/build/esm-debug/on.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "on",
    ()=>on
]);
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}
}),
"[project]/node_modules/socket.io-client/build/esm-debug/socket.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Socket",
    ()=>Socket
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-parser/build/esm-debug/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/on.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@socket.io/component-emitter/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */ const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1
});
class Socket extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Emitter"] {
    /**
     * `Socket` constructor.
     */ constructor(io, nsp, opts){
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */ this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */ this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */ this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */ this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */ this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */ this._queueSeq = 0;
        this.ids = 0;
        /**
         * A map containing acknowledgement handlers.
         *
         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
         *
         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
         * - `const value = await socket.emitWithAck("test")`
         *
         * From those that don't:
         *
         * - `socket.emit("test", (value) => { ... });`
         *
         * In the first case, the handlers will be called with an error when:
         *
         * - the timeout is reached
         * - the socket gets disconnected
         *
         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
         * an acknowledgement from the server.
         *
         * @private
         */ this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect) this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */ get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */ subEvents() {
        if (this.subs) return;
        const io = this.io;
        this.subs = [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(io, "open", this.onopen.bind(this)),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(io, "packet", this.onpacket.bind(this)),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(io, "error", this.onerror.bind(this)),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(io, "close", this.onclose.bind(this))
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */ get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */ connect() {
        if (this.connected) return this;
        this.subEvents();
        if (!this.io["_reconnecting"]) this.io.open(); // ensure open
        if ("open" === this.io._readyState) this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */ open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */ send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */ emit(ev, ...args) {
        var _a, _b, _c;
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].EVENT,
            data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            debug("emitting packet with ack id %d", id);
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
        const discardPacket = this.flags.volatile && !isTransportWritable;
        if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
        } else if (isConnected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        } else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */ _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(()=>{
            delete this.acks[id];
            for(let i = 0; i < this.sendBuffer.length; i++){
                if (this.sendBuffer[i].id === id) {
                    debug("removing packet with ack id %d from the buffer", id);
                    this.sendBuffer.splice(i, 1);
                }
            }
            debug("event with ack id %d has timed out after %d ms", id, timeout);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = (...args)=>{
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, args);
        };
        fn.withError = true;
        this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */ emitWithAck(ev, ...args) {
        return new Promise((resolve, reject)=>{
            const fn = (arg1, arg2)=>{
                return arg1 ? reject(arg1) : resolve(arg2);
            };
            fn.withError = true;
            args.push(fn);
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */ _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({
                fromQueue: true
            }, this.flags)
        };
        args.push((err, ...responseArgs)=>{
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            } else {
                debug("packet [%d] was successfully sent", packet.id);
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */ _drainQueue(force = false) {
        debug("draining queue");
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        debug("sending packet [%d] (try n°%d)", packet.id, packet.tryCount);
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */ packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */ onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
            this.auth((data)=>{
                this._sendConnectPacket(data);
            });
        } else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */ _sendConnectPacket(data) {
        this.packet({
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].CONNECT,
            data: this._pid ? Object.assign({
                pid: this._pid,
                offset: this._lastOffset
            }, data) : data
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */ onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */ onclose(reason, description) {
        debug("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */ _clearAcks() {
        Object.keys(this.acks).forEach((id)=>{
            const isBuffered = this.sendBuffer.some((packet)=>String(packet.id) === id);
            if (!isBuffered) {
                // note: handlers that do not accept an error as first argument are ignored here
                const ack = this.acks[id];
                delete this.acks[id];
                if (ack.withError) {
                    ack.call(this, new Error("socket has been disconnected"));
                }
            }
        });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */ onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace) return;
        switch(packet.type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                } else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].EVENT:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].BINARY_EVENT:
                this.onevent(packet);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].ACK:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].BINARY_ACK:
                this.onack(packet);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].DISCONNECT:
                this.ondisconnect();
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */ onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        } else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners){
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */ ack(id) {
        const self = this;
        let sent = false;
        return function(...args) {
            // prevent double callbacks
            if (sent) return;
            sent = true;
            debug("sending ack %j", args);
            self.packet({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].ACK,
                id: id,
                data: args
            });
        };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */ onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
            debug("bad ack %s", packet.id);
            return;
        }
        delete this.acks[packet.id];
        debug("calling ack %s with %j", packet.id, packet.data);
        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
        if (ack.withError) {
            packet.data.unshift(null);
        }
        // @ts-ignore
        ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */ onconnect(id, pid) {
        debug("socket connected with id %s", id);
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */ emitBuffered() {
        this.receiveBuffer.forEach((args)=>this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet)=>{
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */ ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */ destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy)=>subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */ disconnect() {
        if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PacketType"].DISCONNECT
            });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */ close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */ compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */ get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */ timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */ onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */ prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */ offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for(let i = 0; i < listeners.length; i++){
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        } else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */ listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */ onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */ prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */ offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for(let i = 0; i < listeners.length; i++){
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        } else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */ listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */ notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners){
                listener.apply(this, packet.data);
            }
        }
    }
}
}),
"[project]/node_modules/socket.io-client/build/esm-debug/contrib/backo2.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */ __turbopack_context__.s([
    "Backoff",
    ()=>Backoff
]);
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */ Backoff.prototype.duration = function() {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */ Backoff.prototype.reset = function() {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */ Backoff.prototype.setMin = function(min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */ Backoff.prototype.setMax = function(max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */ Backoff.prototype.setJitter = function(jitter) {
    this.jitter = jitter;
};
}),
"[project]/node_modules/socket.io-client/build/esm-debug/manager.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Manager",
    ()=>Manager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/socket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/globals.node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/socket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-parser/build/esm-debug/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/on.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$backo2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/contrib/backo2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@socket.io/component-emitter/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
;
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("socket.io-client:manager"); // debug()
class Manager extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$socket$2e$io$2f$component$2d$emitter$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Emitter"] {
    constructor(uri, opts){
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["installTimerFunctions"])(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$contrib$2f$backo2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Backoff"]({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect) this.open();
    }
    reconnection(v) {
        if (!arguments.length) return this._reconnection;
        this._reconnection = !!v;
        if (!v) {
            this.skipReconnect = true;
        }
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined) return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined) return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined) return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined) return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length) return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */ maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */ open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open")) return this;
        debug("opening %s", this.uri);
        this.engine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Socket"](this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(socket, "open", function() {
            self.onopen();
            fn && fn();
        });
        const onError = (err)=>{
            debug("error");
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            } else {
                // Only do this if there is no fn to handle the error
                this.maybeReconnectOnOpen();
            }
        };
        // emit `error`
        const errorSub = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            debug("connect attempt will timeout after %d", timeout);
            // set timer
            const timer = this.setTimeoutFn(()=>{
                debug("connect attempt timed out after %d", timeout);
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(()=>{
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */ connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */ onopen() {
        debug("open");
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(socket, "ping", this.onping.bind(this)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(socket, "data", this.ondata.bind(this)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(socket, "error", this.onerror.bind(this)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(socket, "close", this.onclose.bind(this)), // @ts-ignore
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$on$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["on"])(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */ onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */ ondata(data) {
        try {
            this.decoder.add(data);
        } catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */ ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$globals$2e$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */ onerror(err) {
        debug("error", err);
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */ socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Socket"](this, nsp, opts);
            this.nsps[nsp] = socket;
        } else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */ _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps){
            const socket = this.nsps[nsp];
            if (socket.active) {
                debug("socket %s is still active, skipping close", nsp);
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */ _packet(packet) {
        debug("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for(let i = 0; i < encodedPackets.length; i++){
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */ cleanup() {
        debug("cleanup");
        this.subs.forEach((subDestroy)=>subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */ _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */ disconnect() {
        return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */ onclose(reason, description) {
        var _a;
        debug("closed due to %s", reason);
        this.cleanup();
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */ reconnect() {
        if (this._reconnecting || this.skipReconnect) return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        } else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer = this.setTimeoutFn(()=>{
                if (self.skipReconnect) return;
                debug("attempting reconnect");
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect) return;
                self.open((err)=>{
                    if (err) {
                        debug("reconnect attempt error");
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    } else {
                        debug("reconnect success");
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(()=>{
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */ onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}
}),
"[project]/node_modules/socket.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connect",
    ()=>lookup,
    "default",
    ()=>lookup,
    "io",
    ()=>lookup
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/url.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$manager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/manager.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/socket.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/node_modules/debug/src/index.js [app-ssr] (ecmascript)"); // debug()
/**
 * Protocol version.
 *
 * @public
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$parser$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socket.io-parser/build/esm-debug/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$engine$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/engine.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("socket.io-client"); // debug()
/**
 * Managers cache.
 */ const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["url"])(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$manager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Manager"](source, opts);
    } else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$manager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Manager"](source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$manager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Manager"],
    Socket: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Socket"],
    io: lookup,
    connect: lookup
});
;
;
;
}),
"[project]/node_modules/fabric/dist/index.min.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ActiveSelection",
    ()=>Jo,
    "BaseBrush",
    ()=>eo,
    "BaseFabricObject",
    ()=>$s,
    "Canvas",
    ()=>In,
    "Canvas2dFilterBackend",
    ()=>Qo,
    "CanvasDOMManager",
    ()=>Dn,
    "Circle",
    ()=>ho,
    "CircleBrush",
    ()=>co,
    "ClipPathLayout",
    ()=>Uo,
    "Color",
    ()=>Le,
    "Control",
    ()=>ni,
    "Ellipse",
    ()=>_o,
    "FabricImage",
    ()=>na,
    "FabricObject",
    ()=>ji,
    "FabricText",
    ()=>Eo,
    "FitContentLayout",
    ()=>Br,
    "FixedLayout",
    ()=>qo,
    "Gradient",
    ()=>Zn,
    "Group",
    ()=>Hr,
    "IText",
    ()=>Ho,
    "Image",
    ()=>na,
    "InteractiveFabricObject",
    ()=>Ei,
    "Intersection",
    ()=>Ks,
    "LayoutManager",
    ()=>Vr,
    "LayoutStrategy",
    ()=>Ir,
    "Line",
    ()=>mo,
    "Object",
    ()=>ji,
    "Observable",
    ()=>st,
    "Path",
    ()=>ro,
    "Pattern",
    ()=>to,
    "PatternBrush",
    ()=>uo,
    "PencilBrush",
    ()=>no,
    "Point",
    ()=>ot,
    "Polygon",
    ()=>wo,
    "Polyline",
    ()=>So,
    "Rect",
    ()=>Er,
    "Shadow",
    ()=>Os,
    "SprayBrush",
    ()=>lo,
    "StaticCanvas",
    ()=>se,
    "StaticCanvasDOMManager",
    ()=>te,
    "Text",
    ()=>Eo,
    "Textbox",
    ()=>No,
    "Triangle",
    ()=>vo,
    "WebGLFilterBackend",
    ()=>Zo,
    "cache",
    ()=>_,
    "classRegistry",
    ()=>tt,
    "config",
    ()=>o,
    "controlsUtils",
    ()=>ja,
    "createCollectionMixin",
    ()=>ct,
    "filters",
    ()=>bh,
    "getCSSRules",
    ()=>fa,
    "getEnv",
    ()=>p,
    "getFabricDocument",
    ()=>m,
    "getFabricWindow",
    ()=>v,
    "getFilterBackend",
    ()=>ea,
    "iMatrix",
    ()=>T,
    "initFilterBackend",
    ()=>ta,
    "isPutImageFaster",
    ()=>La,
    "isWebGLPipelineState",
    ()=>Fa,
    "loadSVGFromString",
    ()=>xa,
    "loadSVGFromURL",
    ()=>Ca,
    "parseAttributes",
    ()=>Dr,
    "parseFontDeclaration",
    ()=>wr,
    "parsePointsAttribute",
    ()=>xo,
    "parseSVGDocument",
    ()=>_a,
    "parseStyleAttribute",
    ()=>Or,
    "parseTransformAttribute",
    ()=>br,
    "runningAnimations",
    ()=>et,
    "setEnv",
    ()=>f,
    "setFilterBackend",
    ()=>sa,
    "util",
    ()=>kn,
    "version",
    ()=>x
]);
function t(t, e, s) {
    return (e = function(t) {
        var e = function(t, e) {
            if ("object" != typeof t || !t) return t;
            var s = t[Symbol.toPrimitive];
            if (void 0 !== s) {
                var i = s.call(t, e || "default");
                if ("object" != typeof i) return i;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (("TURBOPACK compile-time truthy", 1) ? String : "TURBOPACK unreachable")(t);
        }(t, "string");
        return "symbol" == typeof e ? e : e + "";
    }(e)) in t ? Object.defineProperty(t, e, {
        value: s,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = s, t;
}
function e(t, e) {
    var s = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(t);
        e && (i = i.filter(function(e) {
            return Object.getOwnPropertyDescriptor(t, e).enumerable;
        })), s.push.apply(s, i);
    }
    return s;
}
function s(s) {
    for(var i = 1; i < arguments.length; i++){
        var r = null != arguments[i] ? arguments[i] : {};
        i % 2 ? e(Object(r), !0).forEach(function(e) {
            t(s, e, r[e]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(r)) : e(Object(r)).forEach(function(t) {
            Object.defineProperty(s, t, Object.getOwnPropertyDescriptor(r, t));
        });
    }
    return s;
}
function i(t, e) {
    if (null == t) return {};
    var s, i, r = function(t, e) {
        if (null == t) return {};
        var s = {};
        for(var i in t)if (({}).hasOwnProperty.call(t, i)) {
            if (e.indexOf(i) >= 0) continue;
            s[i] = t[i];
        }
        return s;
    }(t, e);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        for(i = 0; i < n.length; i++)s = n[i], e.indexOf(s) >= 0 || ({}).propertyIsEnumerable.call(t, s) && (r[s] = t[s]);
    }
    return r;
}
function r(t, e) {
    return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, {
        raw: {
            value: Object.freeze(e)
        }
    }));
}
class n {
    constructor(){
        t(this, "browserShadowBlurConstant", 1), t(this, "DPI", 96), t(this, "devicePixelRatio", ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 1), t(this, "perfLimitSizeTotal", 2097152), t(this, "maxCacheSideLimit", 4096), t(this, "minCacheSideLimit", 256), t(this, "disableStyleCopyPaste", !1), t(this, "enableGLFiltering", !0), t(this, "textureSize", 4096), t(this, "forceGLPutImageData", !1), t(this, "cachesBoundsOfCurve", !1), t(this, "fontPaths", {}), t(this, "NUM_FRACTION_DIGITS", 4);
    }
}
const o = new class extends n {
    constructor(t){
        super(), this.configure(t);
    }
    configure() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        Object.assign(this, t);
    }
    addFonts() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        this.fontPaths = s(s({}, this.fontPaths), t);
    }
    removeFonts() {
        (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((t)=>{
            delete this.fontPaths[t];
        });
    }
    clearFonts() {
        this.fontPaths = {};
    }
    restoreDefaults(t) {
        const e = new n, s = (null == t ? void 0 : t.reduce((t, s)=>(t[s] = e[s], t), {})) || e;
        this.configure(s);
    }
}, a = function(t) {
    for(var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)s[i - 1] = arguments[i];
    return console[t]("fabric", ...s);
};
class h extends Error {
    constructor(t, e){
        super("fabric: ".concat(t), e);
    }
}
class c extends h {
    constructor(t){
        super("".concat(t, " 'options.signal' is in 'aborted' state"));
    }
}
class l {
}
class u extends l {
    testPrecision(t, e) {
        const s = "precision ".concat(e, " float;\nvoid main(){}"), i = t.createShader(t.FRAGMENT_SHADER);
        return !!i && (t.shaderSource(i, s), t.compileShader(i), !!t.getShaderParameter(i, t.COMPILE_STATUS));
    }
    queryWebGL(t) {
        const e = t.getContext("webgl");
        e && (this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.GLPrecision = [
            "highp",
            "mediump",
            "lowp"
        ].find((t)=>this.testPrecision(e, t)), e.getExtension("WEBGL_lose_context").loseContext(), a("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
    }
    isSupported(t) {
        return !!this.maxTextureSize && this.maxTextureSize >= t;
    }
}
const d = {};
let g;
const f = (t)=>{
    g = t;
}, p = ()=>g || (g = {
        document: document,
        window: window,
        isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0,
        WebGLProbe: new u,
        dispose () {},
        copyPasteData: d
    }), m = ()=>p().document, v = ()=>p().window, y = ()=>{
    var t;
    return Math.max(null !== (t = o.devicePixelRatio) && void 0 !== t ? t : v().devicePixelRatio, 1);
};
const _ = new class {
    constructor(){
        t(this, "charWidthsCache", {}), t(this, "boundsOfCurveCache", {});
    }
    getFontCache(t) {
        let { fontFamily: e, fontStyle: s, fontWeight: i } = t;
        e = e.toLowerCase(), this.charWidthsCache[e] || (this.charWidthsCache[e] = {});
        const r = this.charWidthsCache[e], n = "".concat(s.toLowerCase(), "_").concat((i + "").toLowerCase());
        return r[n] || (r[n] = {}), r[n];
    }
    clearFontCache(t) {
        (t = (t || "").toLowerCase()) ? this.charWidthsCache[t] && delete this.charWidthsCache[t] : this.charWidthsCache = {};
    }
    limitDimsByArea(t) {
        const { perfLimitSizeTotal: e } = o, s = Math.sqrt(e * t);
        return [
            Math.floor(s),
            Math.floor(e / s)
        ];
    }
};
const x = "6.7.1";
function C() {}
const b = Math.PI / 2, S = 2 * Math.PI, w = Math.PI / 180, T = Object.freeze([
    1,
    0,
    0,
    1,
    0,
    0
]), O = 16, k = .4477152502, D = "center", M = "left", P = "top", E = "bottom", A = "right", j = "none", F = /\r?\n/, L = "moving", R = "scaling", I = "rotating", B = "rotate", X = "skewing", Y = "resizing", W = "modifyPoly", V = "modifyPath", z = "changed", G = "scale", H = "scaleX", N = "scaleY", U = "skewX", q = "skewY", K = "fill", J = "stroke", Q = "modified", Z = "json", $ = "svg";
const tt = new class {
    constructor(){
        this[Z] = new Map, this[$] = new Map;
    }
    has(t) {
        return this[Z].has(t);
    }
    getClass(t) {
        const e = this[Z].get(t);
        if (!e) throw new h("No class registered for ".concat(t));
        return e;
    }
    setClass(t, e) {
        e ? this[Z].set(e, t) : (this[Z].set(t.type, t), this[Z].set(t.type.toLowerCase(), t));
    }
    getSVGClass(t) {
        return this[$].get(t);
    }
    setSVGClass(t, e) {
        this[$].set(null != e ? e : t.type.toLowerCase(), t);
    }
};
const et = new class extends Array {
    remove(t) {
        const e = this.indexOf(t);
        e > -1 && this.splice(e, 1);
    }
    cancelAll() {
        const t = this.splice(0);
        return t.forEach((t)=>t.abort()), t;
    }
    cancelByCanvas(t) {
        if (!t) return [];
        const e = this.filter((e)=>{
            var s;
            return e.target === t || "object" == typeof e.target && (null === (s = e.target) || void 0 === s ? void 0 : s.canvas) === t;
        });
        return e.forEach((t)=>t.abort()), e;
    }
    cancelByTarget(t) {
        if (!t) return [];
        const e = this.filter((e)=>e.target === t);
        return e.forEach((t)=>t.abort()), e;
    }
};
class st {
    constructor(){
        t(this, "__eventListeners", {});
    }
    on(t, e) {
        if (this.__eventListeners || (this.__eventListeners = {}), "object" == typeof t) return Object.entries(t).forEach((t)=>{
            let [e, s] = t;
            this.on(e, s);
        }), ()=>this.off(t);
        if (e) {
            const s = t;
            return this.__eventListeners[s] || (this.__eventListeners[s] = []), this.__eventListeners[s].push(e), ()=>this.off(s, e);
        }
        return ()=>!1;
    }
    once(t, e) {
        if ("object" == typeof t) {
            const e = [];
            return Object.entries(t).forEach((t)=>{
                let [s, i] = t;
                e.push(this.once(s, i));
            }), ()=>e.forEach((t)=>t());
        }
        if (e) {
            const s = this.on(t, function() {
                for(var t = arguments.length, i = new Array(t), r = 0; r < t; r++)i[r] = arguments[r];
                e.call(this, ...i), s();
            });
            return s;
        }
        return ()=>!1;
    }
    _removeEventListener(t, e) {
        if (this.__eventListeners[t]) if (e) {
            const s = this.__eventListeners[t], i = s.indexOf(e);
            i > -1 && s.splice(i, 1);
        } else this.__eventListeners[t] = [];
    }
    off(t, e) {
        if (this.__eventListeners) if (void 0 === t) for(const t in this.__eventListeners)this._removeEventListener(t);
        else "object" == typeof t ? Object.entries(t).forEach((t)=>{
            let [e, s] = t;
            this._removeEventListener(e, s);
        }) : this._removeEventListener(t, e);
    }
    fire(t, e) {
        var s;
        if (!this.__eventListeners) return;
        const i = null === (s = this.__eventListeners[t]) || void 0 === s ? void 0 : s.concat();
        if (i) for(let t = 0; t < i.length; t++)i[t].call(this, e || {});
    }
}
const it = (t, e)=>{
    const s = t.indexOf(e);
    return -1 !== s && t.splice(s, 1), t;
}, rt = (t)=>{
    if (0 === t) return 1;
    switch(Math.abs(t) / b){
        case 1:
        case 3:
            return 0;
        case 2:
            return -1;
    }
    return Math.cos(t);
}, nt = (t)=>{
    if (0 === t) return 0;
    const e = t / b, s = Math.sign(t);
    switch(e){
        case 1:
            return s;
        case 2:
            return 0;
        case 3:
            return -s;
    }
    return Math.sin(t);
};
class ot {
    constructor(){
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        "object" == typeof t ? (this.x = t.x, this.y = t.y) : (this.x = t, this.y = e);
    }
    add(t) {
        return new ot(this.x + t.x, this.y + t.y);
    }
    addEquals(t) {
        return this.x += t.x, this.y += t.y, this;
    }
    scalarAdd(t) {
        return new ot(this.x + t, this.y + t);
    }
    scalarAddEquals(t) {
        return this.x += t, this.y += t, this;
    }
    subtract(t) {
        return new ot(this.x - t.x, this.y - t.y);
    }
    subtractEquals(t) {
        return this.x -= t.x, this.y -= t.y, this;
    }
    scalarSubtract(t) {
        return new ot(this.x - t, this.y - t);
    }
    scalarSubtractEquals(t) {
        return this.x -= t, this.y -= t, this;
    }
    multiply(t) {
        return new ot(this.x * t.x, this.y * t.y);
    }
    scalarMultiply(t) {
        return new ot(this.x * t, this.y * t);
    }
    scalarMultiplyEquals(t) {
        return this.x *= t, this.y *= t, this;
    }
    divide(t) {
        return new ot(this.x / t.x, this.y / t.y);
    }
    scalarDivide(t) {
        return new ot(this.x / t, this.y / t);
    }
    scalarDivideEquals(t) {
        return this.x /= t, this.y /= t, this;
    }
    eq(t) {
        return this.x === t.x && this.y === t.y;
    }
    lt(t) {
        return this.x < t.x && this.y < t.y;
    }
    lte(t) {
        return this.x <= t.x && this.y <= t.y;
    }
    gt(t) {
        return this.x > t.x && this.y > t.y;
    }
    gte(t) {
        return this.x >= t.x && this.y >= t.y;
    }
    lerp(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5;
        return e = Math.max(Math.min(1, e), 0), new ot(this.x + (t.x - this.x) * e, this.y + (t.y - this.y) * e);
    }
    distanceFrom(t) {
        const e = this.x - t.x, s = this.y - t.y;
        return Math.sqrt(e * e + s * s);
    }
    midPointFrom(t) {
        return this.lerp(t);
    }
    min(t) {
        return new ot(Math.min(this.x, t.x), Math.min(this.y, t.y));
    }
    max(t) {
        return new ot(Math.max(this.x, t.x), Math.max(this.y, t.y));
    }
    toString() {
        return "".concat(this.x, ",").concat(this.y);
    }
    setXY(t, e) {
        return this.x = t, this.y = e, this;
    }
    setX(t) {
        return this.x = t, this;
    }
    setY(t) {
        return this.y = t, this;
    }
    setFromPoint(t) {
        return this.x = t.x, this.y = t.y, this;
    }
    swap(t) {
        const e = this.x, s = this.y;
        this.x = t.x, this.y = t.y, t.x = e, t.y = s;
    }
    clone() {
        return new ot(this.x, this.y);
    }
    rotate(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : at;
        const s = nt(t), i = rt(t), r = this.subtract(e);
        return new ot(r.x * i - r.y * s, r.x * s + r.y * i).add(e);
    }
    transform(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return new ot(t[0] * this.x + t[2] * this.y + (e ? 0 : t[4]), t[1] * this.x + t[3] * this.y + (e ? 0 : t[5]));
    }
}
const at = new ot(0, 0), ht = (t)=>!!t && Array.isArray(t._objects);
function ct(e) {
    class s extends e {
        constructor(){
            super(...arguments), t(this, "_objects", []);
        }
        _onObjectAdded(t) {}
        _onObjectRemoved(t) {}
        _onStackOrderChanged(t) {}
        add() {
            for(var t = arguments.length, e = new Array(t), s = 0; s < t; s++)e[s] = arguments[s];
            const i = this._objects.push(...e);
            return e.forEach((t)=>this._onObjectAdded(t)), i;
        }
        insertAt(t) {
            for(var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)s[i - 1] = arguments[i];
            return this._objects.splice(t, 0, ...s), s.forEach((t)=>this._onObjectAdded(t)), this._objects.length;
        }
        remove() {
            const t = this._objects, e = [];
            for(var s = arguments.length, i = new Array(s), r = 0; r < s; r++)i[r] = arguments[r];
            return i.forEach((s)=>{
                const i = t.indexOf(s);
                -1 !== i && (t.splice(i, 1), e.push(s), this._onObjectRemoved(s));
            }), e;
        }
        forEachObject(t) {
            this.getObjects().forEach((e, s, i)=>t(e, s, i));
        }
        getObjects() {
            for(var t = arguments.length, e = new Array(t), s = 0; s < t; s++)e[s] = arguments[s];
            return 0 === e.length ? [
                ...this._objects
            ] : this._objects.filter((t)=>t.isType(...e));
        }
        item(t) {
            return this._objects[t];
        }
        isEmpty() {
            return 0 === this._objects.length;
        }
        size() {
            return this._objects.length;
        }
        contains(t, e) {
            return !!this._objects.includes(t) || !!e && this._objects.some((e)=>e instanceof s && e.contains(t, !0));
        }
        complexity() {
            return this._objects.reduce((t, e)=>t += e.complexity ? e.complexity() : 0, 0);
        }
        sendObjectToBack(t) {
            return !(!t || t === this._objects[0]) && (it(this._objects, t), this._objects.unshift(t), this._onStackOrderChanged(t), !0);
        }
        bringObjectToFront(t) {
            return !(!t || t === this._objects[this._objects.length - 1]) && (it(this._objects, t), this._objects.push(t), this._onStackOrderChanged(t), !0);
        }
        sendObjectBackwards(t, e) {
            if (!t) return !1;
            const s = this._objects.indexOf(t);
            if (0 !== s) {
                const i = this.findNewLowerIndex(t, s, e);
                return it(this._objects, t), this._objects.splice(i, 0, t), this._onStackOrderChanged(t), !0;
            }
            return !1;
        }
        bringObjectForward(t, e) {
            if (!t) return !1;
            const s = this._objects.indexOf(t);
            if (s !== this._objects.length - 1) {
                const i = this.findNewUpperIndex(t, s, e);
                return it(this._objects, t), this._objects.splice(i, 0, t), this._onStackOrderChanged(t), !0;
            }
            return !1;
        }
        moveObjectTo(t, e) {
            return t !== this._objects[e] && (it(this._objects, t), this._objects.splice(e, 0, t), this._onStackOrderChanged(t), !0);
        }
        findNewLowerIndex(t, e, s) {
            let i;
            if (s) {
                i = e;
                for(let s = e - 1; s >= 0; --s)if (t.isOverlapping(this._objects[s])) {
                    i = s;
                    break;
                }
            } else i = e - 1;
            return i;
        }
        findNewUpperIndex(t, e, s) {
            let i;
            if (s) {
                i = e;
                for(let s = e + 1; s < this._objects.length; ++s)if (t.isOverlapping(this._objects[s])) {
                    i = s;
                    break;
                }
            } else i = e + 1;
            return i;
        }
        collectObjects(t) {
            let { left: e, top: s, width: i, height: r } = t, { includeIntersecting: n = !0 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const o = [], a = new ot(e, s), h = a.add(new ot(i, r));
            for(let t = this._objects.length - 1; t >= 0; t--){
                const e = this._objects[t];
                e.selectable && e.visible && (n && e.intersectsWithRect(a, h) || e.isContainedWithinRect(a, h) || n && e.containsPoint(a) || n && e.containsPoint(h)) && o.push(e);
            }
            return o;
        }
    }
    return s;
}
class lt extends st {
    _setOptions() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        for(const e in t)this.set(e, t[e]);
    }
    _setObject(t) {
        for(const e in t)this._set(e, t[e]);
    }
    set(t, e) {
        return "object" == typeof t ? this._setObject(t) : this._set(t, e), this;
    }
    _set(t, e) {
        this[t] = e;
    }
    toggle(t) {
        const e = this.get(t);
        return "boolean" == typeof e && this.set(t, !e), this;
    }
    get(t) {
        return this[t];
    }
}
function ut(t) {
    return v().requestAnimationFrame(t);
}
function dt(t) {
    return v().cancelAnimationFrame(t);
}
let gt = 0;
const ft = ()=>gt++, pt = ()=>{
    const t = m().createElement("canvas");
    if (!t || void 0 === t.getContext) throw new h("Failed to create `canvas` element");
    return t;
}, mt = ()=>m().createElement("img"), vt = (t)=>{
    const e = pt();
    return e.width = t.width, e.height = t.height, e;
}, yt = (t, e, s)=>t.toDataURL("image/".concat(e), s), _t = (t, e, s)=>new Promise((i, r)=>{
        t.toBlob(i, "image/".concat(e), s);
    }), xt = (t)=>t * w, Ct = (t)=>t / w, bt = (t)=>t.every((t, e)=>t === T[e]), St = (t, e, s)=>new ot(t).transform(e, s), wt = (t)=>{
    const e = 1 / (t[0] * t[3] - t[1] * t[2]), s = [
        e * t[3],
        -e * t[1],
        -e * t[2],
        e * t[0],
        0,
        0
    ], { x: i, y: r } = new ot(t[4], t[5]).transform(s, !0);
    return s[4] = -i, s[5] = -r, s;
}, Tt = (t, e, s)=>[
        t[0] * e[0] + t[2] * e[1],
        t[1] * e[0] + t[3] * e[1],
        t[0] * e[2] + t[2] * e[3],
        t[1] * e[2] + t[3] * e[3],
        s ? 0 : t[0] * e[4] + t[2] * e[5] + t[4],
        s ? 0 : t[1] * e[4] + t[3] * e[5] + t[5]
    ], Ot = (t, e)=>t.reduceRight((t, s)=>s && t ? Tt(s, t, e) : s || t, void 0) || T.concat(), kt = (t)=>{
    let [e, s] = t;
    return Math.atan2(s, e);
}, Dt = (t)=>{
    const e = kt(t), s = Math.pow(t[0], 2) + Math.pow(t[1], 2), i = Math.sqrt(s), r = (t[0] * t[3] - t[2] * t[1]) / i, n = Math.atan2(t[0] * t[2] + t[1] * t[3], s);
    return {
        angle: Ct(e),
        scaleX: i,
        scaleY: r,
        skewX: Ct(n),
        skewY: 0,
        translateX: t[4] || 0,
        translateY: t[5] || 0
    };
}, Mt = function(t) {
    return [
        1,
        0,
        0,
        1,
        t,
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
    ];
};
function Pt() {
    let { angle: t = 0 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { x: e = 0, y: s = 0 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const i = xt(t), r = rt(i), n = nt(i);
    return [
        r,
        n,
        -n,
        r,
        e ? e - (r * e - n * s) : 0,
        s ? s - (n * e + r * s) : 0
    ];
}
const Et = function(t) {
    return [
        t,
        0,
        0,
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t,
        0,
        0
    ];
}, At = (t)=>Math.tan(xt(t)), jt = (t)=>[
        1,
        0,
        At(t),
        1,
        0,
        0
    ], Ft = (t)=>[
        1,
        At(t),
        0,
        1,
        0,
        0
    ], Lt = (t)=>{
    let { scaleX: e = 1, scaleY: s = 1, flipX: i = !1, flipY: r = !1, skewX: n = 0, skewY: o = 0 } = t, a = Et(i ? -e : e, r ? -s : s);
    return n && (a = Tt(a, jt(n), !0)), o && (a = Tt(a, Ft(o), !0)), a;
}, Rt = (t)=>{
    const { translateX: e = 0, translateY: s = 0, angle: i = 0 } = t;
    let r = Mt(e, s);
    i && (r = Tt(r, Pt({
        angle: i
    })));
    const n = Lt(t);
    return bt(n) || (r = Tt(r, n)), r;
}, It = function(t) {
    let { signal: e, crossOrigin: s = null } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return new Promise(function(i, r) {
        if (e && e.aborted) return r(new c("loadImage"));
        const n = mt();
        let o;
        e && (o = function(t) {
            n.src = "", r(t);
        }, e.addEventListener("abort", o, {
            once: !0
        }));
        const a = function() {
            n.onload = n.onerror = null, o && (null == e || e.removeEventListener("abort", o)), i(n);
        };
        t ? (n.onload = a, n.onerror = function() {
            o && (null == e || e.removeEventListener("abort", o)), r(new h("Error loading ".concat(n.src)));
        }, s && (n.crossOrigin = s), n.src = t) : a();
    });
}, Bt = function(t) {
    let { signal: e, reviver: s = C } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return new Promise((i, r)=>{
        const n = [];
        e && e.addEventListener("abort", r, {
            once: !0
        }), Promise.all(t.map((t)=>tt.getClass(t.type).fromObject(t, {
                signal: e
            }).then((e)=>(s(t, e), n.push(e), e)))).then(i).catch((t)=>{
            n.forEach((t)=>{
                t.dispose && t.dispose();
            }), r(t);
        }).finally(()=>{
            e && e.removeEventListener("abort", r);
        });
    });
}, Xt = function(t) {
    let { signal: e } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return new Promise((s, i)=>{
        const r = [];
        e && e.addEventListener("abort", i, {
            once: !0
        });
        const n = Object.values(t).map((t)=>t && t.type && tt.has(t.type) ? Bt([
                t
            ], {
                signal: e
            }).then((t)=>{
                let [e] = t;
                return r.push(e), e;
            }) : t), o = Object.keys(t);
        Promise.all(n).then((t)=>t.reduce((t, e, s)=>(t[o[s]] = e, t), {})).then(s).catch((t)=>{
            r.forEach((t)=>{
                t.dispose && t.dispose();
            }), i(t);
        }).finally(()=>{
            e && e.removeEventListener("abort", i);
        });
    });
}, Yt = function(t) {
    return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []).reduce((e, s)=>(s in t && (e[s] = t[s]), e), {});
}, Wt = (t, e)=>Object.keys(t).reduce((s, i)=>(e(t[i], i, t) && (s[i] = t[i]), s), {}), Vt = (t, e)=>parseFloat(Number(t).toFixed(e)), zt = (t)=>"matrix(" + t.map((t)=>Vt(t, o.NUM_FRACTION_DIGITS)).join(" ") + ")", Gt = (t)=>!!t && void 0 !== t.toLive, Ht = (t)=>!!t && "function" == typeof t.toObject, Nt = (t)=>!!t && void 0 !== t.offsetX && "source" in t, Ut = (t)=>!!t && "multiSelectionStacking" in t;
function qt(t) {
    const e = t && Kt(t);
    let s = 0, i = 0;
    if (!t || !e) return {
        left: s,
        top: i
    };
    let r = t;
    const n = e.documentElement, o = e.body || {
        scrollLeft: 0,
        scrollTop: 0
    };
    for(; r && (r.parentNode || r.host) && (r = r.parentNode || r.host, r === e ? (s = o.scrollLeft || n.scrollLeft || 0, i = o.scrollTop || n.scrollTop || 0) : (s += r.scrollLeft || 0, i += r.scrollTop || 0), 1 !== r.nodeType || "fixed" !== r.style.position););
    return {
        left: s,
        top: i
    };
}
const Kt = (t)=>t.ownerDocument || null, Jt = (t)=>{
    var e;
    return (null === (e = t.ownerDocument) || void 0 === e ? void 0 : e.defaultView) || null;
}, Qt = function(t, e, s) {
    let { width: i, height: r } = s, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    t.width = i, t.height = r, n > 1 && (t.setAttribute("width", (i * n).toString()), t.setAttribute("height", (r * n).toString()), e.scale(n, n));
}, Zt = (t, e)=>{
    let { width: s, height: i } = e;
    s && (t.style.width = "number" == typeof s ? "".concat(s, "px") : s), i && (t.style.height = "number" == typeof i ? "".concat(i, "px") : i);
};
function $t(t) {
    return void 0 !== t.onselectstart && (t.onselectstart = ()=>!1), t.style.userSelect = j, t;
}
class te {
    constructor(e){
        t(this, "_originalCanvasStyle", void 0), t(this, "lower", void 0);
        const s = this.createLowerCanvas(e);
        this.lower = {
            el: s,
            ctx: s.getContext("2d")
        };
    }
    createLowerCanvas(t) {
        const e = (s = t) && void 0 !== s.getContext ? t : t && m().getElementById(t) || pt();
        var s;
        if (e.hasAttribute("data-fabric")) throw new h("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
        return this._originalCanvasStyle = e.style.cssText, e.setAttribute("data-fabric", "main"), e.classList.add("lower-canvas"), e;
    }
    cleanupDOM(t) {
        let { width: e, height: s } = t;
        const { el: i } = this.lower;
        i.classList.remove("lower-canvas"), i.removeAttribute("data-fabric"), i.setAttribute("width", "".concat(e)), i.setAttribute("height", "".concat(s)), i.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
    }
    setDimensions(t, e) {
        const { el: s, ctx: i } = this.lower;
        Qt(s, i, t, e);
    }
    setCSSDimensions(t) {
        Zt(this.lower.el, t);
    }
    calcOffset() {
        return function(t) {
            var e;
            const s = t && Kt(t), i = {
                left: 0,
                top: 0
            };
            if (!s) return i;
            const r = (null === (e = Jt(t)) || void 0 === e ? void 0 : e.getComputedStyle(t, null)) || {};
            i.left += parseInt(r.borderLeftWidth, 10) || 0, i.top += parseInt(r.borderTopWidth, 10) || 0, i.left += parseInt(r.paddingLeft, 10) || 0, i.top += parseInt(r.paddingTop, 10) || 0;
            let n = {
                left: 0,
                top: 0
            };
            const o = s.documentElement;
            void 0 !== t.getBoundingClientRect && (n = t.getBoundingClientRect());
            const a = qt(t);
            return {
                left: n.left + a.left - (o.clientLeft || 0) + i.left,
                top: n.top + a.top - (o.clientTop || 0) + i.top
            };
        }(this.lower.el);
    }
    dispose() {
        p().dispose(this.lower.el), delete this.lower;
    }
}
const ee = {
    backgroundVpt: !0,
    backgroundColor: "",
    overlayVpt: !0,
    overlayColor: "",
    includeDefaultValues: !0,
    svgViewportTransformation: !0,
    renderOnAddRemove: !0,
    skipOffscreen: !0,
    enableRetinaScaling: !0,
    imageSmoothingEnabled: !0,
    controlsAboveOverlay: !1,
    allowTouchScrolling: !1,
    viewportTransform: [
        ...T
    ]
};
class se extends ct(lt) {
    get lowerCanvasEl() {
        var t;
        return null === (t = this.elements.lower) || void 0 === t ? void 0 : t.el;
    }
    get contextContainer() {
        var t;
        return null === (t = this.elements.lower) || void 0 === t ? void 0 : t.ctx;
    }
    static getDefaults() {
        return se.ownDefaults;
    }
    constructor(t){
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(), Object.assign(this, this.constructor.getDefaults()), this.set(e), this.initElements(t), this._setDimensionsImpl({
            width: this.width || this.elements.lower.el.width || 0,
            height: this.height || this.elements.lower.el.height || 0
        }), this.skipControlsDrawing = !1, this.viewportTransform = [
            ...this.viewportTransform
        ], this.calcViewportBoundaries();
    }
    initElements(t) {
        this.elements = new te(t);
    }
    add() {
        const t = super.add(...arguments);
        return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t;
    }
    insertAt(t) {
        for(var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)s[i - 1] = arguments[i];
        const r = super.insertAt(t, ...s);
        return s.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), r;
    }
    remove() {
        const t = super.remove(...arguments);
        return t.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t;
    }
    _onObjectAdded(t) {
        t.canvas && t.canvas !== this && (a("warn", "Canvas is trying to add an object that belongs to a different canvas.\nResulting to default behavior: removing object from previous canvas and adding to new canvas"), t.canvas.remove(t)), t._set("canvas", this), t.setCoords(), this.fire("object:added", {
            target: t
        }), t.fire("added", {
            target: this
        });
    }
    _onObjectRemoved(t) {
        t._set("canvas", void 0), this.fire("object:removed", {
            target: t
        }), t.fire("removed", {
            target: this
        });
    }
    _onStackOrderChanged() {
        this.renderOnAddRemove && this.requestRenderAll();
    }
    getRetinaScaling() {
        return this.enableRetinaScaling ? y() : 1;
    }
    calcOffset() {
        return this._offset = this.elements.calcOffset();
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    setWidth(t, e) {
        return this.setDimensions({
            width: t
        }, e);
    }
    setHeight(t, e) {
        return this.setDimensions({
            height: t
        }, e);
    }
    _setDimensionsImpl(t) {
        let { cssOnly: e = !1, backstoreOnly: i = !1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!e) {
            const e = s({
                width: this.width,
                height: this.height
            }, t);
            this.elements.setDimensions(e, this.getRetinaScaling()), this.hasLostContext = !0, this.width = e.width, this.height = e.height;
        }
        i || this.elements.setCSSDimensions(t), this.calcOffset();
    }
    setDimensions(t, e) {
        this._setDimensionsImpl(t, e), e && e.cssOnly || this.requestRenderAll();
    }
    getZoom() {
        return this.viewportTransform[0];
    }
    setViewportTransform(t) {
        this.viewportTransform = t, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
    }
    zoomToPoint(t, e) {
        const s = t, i = [
            ...this.viewportTransform
        ], r = St(t, wt(i));
        i[0] = e, i[3] = e;
        const n = St(r, i);
        i[4] += s.x - n.x, i[5] += s.y - n.y, this.setViewportTransform(i);
    }
    setZoom(t) {
        this.zoomToPoint(new ot(0, 0), t);
    }
    absolutePan(t) {
        const e = [
            ...this.viewportTransform
        ];
        return e[4] = -t.x, e[5] = -t.y, this.setViewportTransform(e);
    }
    relativePan(t) {
        return this.absolutePan(new ot(-t.x - this.viewportTransform[4], -t.y - this.viewportTransform[5]));
    }
    getElement() {
        return this.elements.lower.el;
    }
    clearContext(t) {
        t.clearRect(0, 0, this.width, this.height);
    }
    getContext() {
        return this.elements.lower.ctx;
    }
    clear() {
        this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
    }
    renderAll() {
        this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
    }
    renderAndReset() {
        this.nextRenderHandle = 0, this.renderAll();
    }
    requestRenderAll() {
        this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = ut(()=>this.renderAndReset()));
    }
    calcViewportBoundaries() {
        const t = this.width, e = this.height, s = wt(this.viewportTransform), i = St({
            x: 0,
            y: 0
        }, s), r = St({
            x: t,
            y: e
        }, s), n = i.min(r), o = i.max(r);
        return this.vptCoords = {
            tl: n,
            tr: new ot(o.x, n.y),
            bl: new ot(n.x, o.y),
            br: o
        };
    }
    cancelRequestedRender() {
        this.nextRenderHandle && (dt(this.nextRenderHandle), this.nextRenderHandle = 0);
    }
    drawControls(t) {}
    renderCanvas(t, e) {
        if (this.destroyed) return;
        const s = this.viewportTransform, i = this.clipPath;
        this.calcViewportBoundaries(), this.clearContext(t), t.imageSmoothingEnabled = this.imageSmoothingEnabled, t.patternQuality = "best", this.fire("before:render", {
            ctx: t
        }), this._renderBackground(t), t.save(), t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this._renderObjects(t, e), t.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(t), i && (i._set("canvas", this), i.shouldCache(), i._transformDone = !0, i.renderCache({
            forClipping: !0
        }), this.drawClipPathOnCanvas(t, i)), this._renderOverlay(t), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(t), this.fire("after:render", {
            ctx: t
        }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
    }
    drawClipPathOnCanvas(t, e) {
        const s = this.viewportTransform;
        t.save(), t.transform(...s), t.globalCompositeOperation = "destination-in", e.transform(t), t.scale(1 / e.zoomX, 1 / e.zoomY), t.drawImage(e._cacheCanvas, -e.cacheTranslationX, -e.cacheTranslationY), t.restore();
    }
    _renderObjects(t, e) {
        for(let s = 0, i = e.length; s < i; ++s)e[s] && e[s].render(t);
    }
    _renderBackgroundOrOverlay(t, e) {
        const s = this["".concat(e, "Color")], i = this["".concat(e, "Image")], r = this.viewportTransform, n = this["".concat(e, "Vpt")];
        if (!s && !i) return;
        const o = Gt(s);
        if (s) {
            if (t.save(), t.beginPath(), t.moveTo(0, 0), t.lineTo(this.width, 0), t.lineTo(this.width, this.height), t.lineTo(0, this.height), t.closePath(), t.fillStyle = o ? s.toLive(t) : s, n && t.transform(...r), o) {
                t.transform(1, 0, 0, 1, s.offsetX || 0, s.offsetY || 0);
                const e = s.gradientTransform || s.patternTransform;
                e && t.transform(...e);
            }
            t.fill(), t.restore();
        }
        if (i) {
            t.save();
            const { skipOffscreen: e } = this;
            this.skipOffscreen = n, n && t.transform(...r), i.render(t), this.skipOffscreen = e, t.restore();
        }
    }
    _renderBackground(t) {
        this._renderBackgroundOrOverlay(t, "background");
    }
    _renderOverlay(t) {
        this._renderBackgroundOrOverlay(t, "overlay");
    }
    getCenter() {
        return {
            top: this.height / 2,
            left: this.width / 2
        };
    }
    getCenterPoint() {
        return new ot(this.width / 2, this.height / 2);
    }
    centerObjectH(t) {
        return this._centerObject(t, new ot(this.getCenterPoint().x, t.getCenterPoint().y));
    }
    centerObjectV(t) {
        return this._centerObject(t, new ot(t.getCenterPoint().x, this.getCenterPoint().y));
    }
    centerObject(t) {
        return this._centerObject(t, this.getCenterPoint());
    }
    viewportCenterObject(t) {
        return this._centerObject(t, this.getVpCenter());
    }
    viewportCenterObjectH(t) {
        return this._centerObject(t, new ot(this.getVpCenter().x, t.getCenterPoint().y));
    }
    viewportCenterObjectV(t) {
        return this._centerObject(t, new ot(t.getCenterPoint().x, this.getVpCenter().y));
    }
    getVpCenter() {
        return St(this.getCenterPoint(), wt(this.viewportTransform));
    }
    _centerObject(t, e) {
        t.setXY(e, D, D), t.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
    }
    toDatalessJSON(t) {
        return this.toDatalessObject(t);
    }
    toObject(t) {
        return this._toObjectMethod("toObject", t);
    }
    toJSON() {
        return this.toObject();
    }
    toDatalessObject(t) {
        return this._toObjectMethod("toDatalessObject", t);
    }
    _toObjectMethod(t, e) {
        const i = this.clipPath, r = i && !i.excludeFromExport ? this._toObject(i, t, e) : null;
        return s(s(s({
            version: x
        }, Yt(this, e)), {}, {
            objects: this._objects.filter((t)=>!t.excludeFromExport).map((s)=>this._toObject(s, t, e))
        }, this.__serializeBgOverlay(t, e)), r ? {
            clipPath: r
        } : null);
    }
    _toObject(t, e, s) {
        let i;
        this.includeDefaultValues || (i = t.includeDefaultValues, t.includeDefaultValues = !1);
        const r = t[e](s);
        return this.includeDefaultValues || (t.includeDefaultValues = !!i), r;
    }
    __serializeBgOverlay(t, e) {
        const s = {}, i = this.backgroundImage, r = this.overlayImage, n = this.backgroundColor, o = this.overlayColor;
        return Gt(n) ? n.excludeFromExport || (s.background = n.toObject(e)) : n && (s.background = n), Gt(o) ? o.excludeFromExport || (s.overlay = o.toObject(e)) : o && (s.overlay = o), i && !i.excludeFromExport && (s.backgroundImage = this._toObject(i, t, e)), r && !r.excludeFromExport && (s.overlayImage = this._toObject(r, t, e)), s;
    }
    toSVG() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
        t.reviver = e;
        const s = [];
        return this._setSVGPreamble(s, t), this._setSVGHeader(s, t), this.clipPath && s.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, ')" >\n')), this._setSVGBgOverlayColor(s, "background"), this._setSVGBgOverlayImage(s, "backgroundImage", e), this._setSVGObjects(s, e), this.clipPath && s.push("</g>\n"), this._setSVGBgOverlayColor(s, "overlay"), this._setSVGBgOverlayImage(s, "overlayImage", e), s.push("</svg>"), s.join("");
    }
    _setSVGPreamble(t, e) {
        e.suppressPreamble || t.push('<?xml version="1.0" encoding="', e.encoding || "UTF-8", '" standalone="no" ?>\n', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n');
    }
    _setSVGHeader(t, e) {
        const s = e.width || "".concat(this.width), i = e.height || "".concat(this.height), r = o.NUM_FRACTION_DIGITS, n = e.viewBox;
        let a;
        if (n) a = 'viewBox="'.concat(n.x, " ").concat(n.y, " ").concat(n.width, " ").concat(n.height, '" ');
        else if (this.svgViewportTransformation) {
            const t = this.viewportTransform;
            a = 'viewBox="'.concat(Vt(-t[4] / t[0], r), " ").concat(Vt(-t[5] / t[3], r), " ").concat(Vt(this.width / t[0], r), " ").concat(Vt(this.height / t[3], r), '" ');
        } else a = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
        t.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', s, '" ', 'height="', i, '" ', a, 'xml:space="preserve">\n', "<desc>Created with Fabric.js ", x, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e), "</defs>\n");
    }
    createSVGClipPathMarkup(t) {
        const e = this.clipPath;
        return e ? (e.clipPathId = "CLIPPATH_".concat(ft()), '<clipPath id="'.concat(e.clipPathId, '" >\n').concat(e.toClipPathSVG(t.reviver), "</clipPath>\n")) : "";
    }
    createSVGRefElementsMarkup() {
        return [
            "background",
            "overlay"
        ].map((t)=>{
            const e = this["".concat(t, "Color")];
            if (Gt(e)) {
                const s = this["".concat(t, "Vpt")], i = this.viewportTransform, r = {
                    isType: ()=>!1,
                    width: this.width / (s ? i[0] : 1),
                    height: this.height / (s ? i[3] : 1)
                };
                return e.toSVG(r, {
                    additionalTransform: s ? zt(i) : ""
                });
            }
        }).join("");
    }
    createSVGFontFacesMarkup() {
        const t = [], e = {}, s = o.fontPaths;
        this._objects.forEach(function e(s) {
            t.push(s), ht(s) && s._objects.forEach(e);
        }), t.forEach((t)=>{
            if (!(i = t) || "function" != typeof i._renderText) return;
            var i;
            const { styles: r, fontFamily: n } = t;
            !e[n] && s[n] && (e[n] = !0, r && Object.values(r).forEach((t)=>{
                Object.values(t).forEach((t)=>{
                    let { fontFamily: i = "" } = t;
                    !e[i] && s[i] && (e[i] = !0);
                });
            }));
        });
        const i = Object.keys(e).map((t)=>"\t\t@font-face {\n\t\t\tfont-family: '".concat(t, "';\n\t\t\tsrc: url('").concat(s[t], "');\n\t\t}\n")).join("");
        return i ? '\t<style type="text/css"><![CDATA[\n'.concat(i, "]]></style>\n") : "";
    }
    _setSVGObjects(t, e) {
        this.forEachObject((s)=>{
            s.excludeFromExport || this._setSVGObject(t, s, e);
        });
    }
    _setSVGObject(t, e, s) {
        t.push(e.toSVG(s));
    }
    _setSVGBgOverlayImage(t, e, s) {
        const i = this[e];
        i && !i.excludeFromExport && i.toSVG && t.push(i.toSVG(s));
    }
    _setSVGBgOverlayColor(t, e) {
        const s = this["".concat(e, "Color")];
        if (s) if (Gt(s)) {
            const i = s.repeat || "", r = this.width, n = this.height, o = this["".concat(e, "Vpt")] ? zt(wt(this.viewportTransform)) : "";
            t.push('<rect transform="'.concat(o, " translate(").concat(r / 2, ",").concat(n / 2, ')" x="').concat(s.offsetX - r / 2, '" y="').concat(s.offsetY - n / 2, '" width="').concat("repeat-y" !== i && "no-repeat" !== i || !Nt(s) ? r : s.source.width, '" height="').concat("repeat-x" !== i && "no-repeat" !== i || !Nt(s) ? n : s.source.height, '" fill="url(#SVGID_').concat(s.id, ')"></rect>\n'));
        } else t.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', s, '"', "></rect>\n");
    }
    loadFromJSON(t, e) {
        let { signal: s } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!t) return Promise.reject(new h("`json` is undefined"));
        const i = "string" == typeof t ? JSON.parse(t) : t, { objects: r = [], backgroundImage: n, background: o, overlayImage: a, overlay: c, clipPath: l } = i, u = this.renderOnAddRemove;
        return this.renderOnAddRemove = !1, Promise.all([
            Bt(r, {
                reviver: e,
                signal: s
            }),
            Xt({
                backgroundImage: n,
                backgroundColor: o,
                overlayImage: a,
                overlayColor: c,
                clipPath: l
            }, {
                signal: s
            })
        ]).then((t)=>{
            let [e, s] = t;
            return this.clear(), this.add(...e), this.set(i), this.set(s), this.renderOnAddRemove = u, this;
        });
    }
    clone(t) {
        const e = this.toObject(t);
        return this.cloneWithoutData().loadFromJSON(e);
    }
    cloneWithoutData() {
        const t = vt(this);
        return new this.constructor(t);
    }
    toDataURL() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const { format: e = "png", quality: s = 1, multiplier: i = 1, enableRetinaScaling: r = !1 } = t, n = i * (r ? this.getRetinaScaling() : 1);
        return yt(this.toCanvasElement(n, t), e, s);
    }
    toBlob() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const { format: e = "png", quality: s = 1, multiplier: i = 1, enableRetinaScaling: r = !1 } = t, n = i * (r ? this.getRetinaScaling() : 1);
        return _t(this.toCanvasElement(n, t), e, s);
    }
    toCanvasElement() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, { width: e, height: s, left: i, top: r, filter: n } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const o = (e || this.width) * t, a = (s || this.height) * t, h = this.getZoom(), c = this.width, l = this.height, u = this.skipControlsDrawing, d = h * t, g = this.viewportTransform, f = [
            d,
            0,
            0,
            d,
            (g[4] - (i || 0)) * t,
            (g[5] - (r || 0)) * t
        ], p = this.enableRetinaScaling, m = vt({
            width: o,
            height: a
        }), v = n ? this._objects.filter((t)=>n(t)) : this._objects;
        return this.enableRetinaScaling = !1, this.viewportTransform = f, this.width = o, this.height = a, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(m.getContext("2d"), v), this.viewportTransform = g, this.width = c, this.height = l, this.calcViewportBoundaries(), this.enableRetinaScaling = p, this.skipControlsDrawing = u, m;
    }
    dispose() {
        return !this.disposed && this.elements.cleanupDOM({
            width: this.width,
            height: this.height
        }), et.cancelByCanvas(this), this.disposed = !0, new Promise((t, e)=>{
            const s = ()=>{
                this.destroy(), t(!0);
            };
            s.kill = e, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? t(!1) : this.nextRenderHandle ? this.__cleanupTask = s : s();
        });
    }
    destroy() {
        this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((t)=>t.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
    }
    toString() {
        return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
    }
}
t(se, "ownDefaults", ee);
const ie = [
    "touchstart",
    "touchmove",
    "touchend"
];
const re = (t)=>{
    const e = qt(t.target), s = function(t) {
        const e = t.changedTouches;
        return e && e[0] ? e[0] : t;
    }(t);
    return new ot(s.clientX + e.left, s.clientY + e.top);
}, ne = (t)=>ie.includes(t.type) || "touch" === t.pointerType, oe = (t)=>{
    t.preventDefault(), t.stopPropagation();
}, ae = (t)=>{
    let e = 0, s = 0, i = 0, r = 0;
    for(let n = 0, o = t.length; n < o; n++){
        const { x: o, y: a } = t[n];
        (o > i || !n) && (i = o), (o < e || !n) && (e = o), (a > r || !n) && (r = a), (a < s || !n) && (s = a);
    }
    return {
        left: e,
        top: s,
        width: i - e,
        height: r - s
    };
}, he = [
    "translateX",
    "translateY",
    "scaleX",
    "scaleY"
], ce = (t, e)=>le(t, Tt(e, t.calcOwnMatrix())), le = (t, e)=>{
    const s = Dt(e), { translateX: r, translateY: n, scaleX: o, scaleY: a } = s, h = i(s, he), c = new ot(r, n);
    t.flipX = !1, t.flipY = !1, Object.assign(t, h), t.set({
        scaleX: o,
        scaleY: a
    }), t.setPositionByOrigin(c, D, D);
}, ue = (t)=>{
    t.scaleX = 1, t.scaleY = 1, t.skewX = 0, t.skewY = 0, t.flipX = !1, t.flipY = !1, t.rotate(0);
}, de = (t)=>({
        scaleX: t.scaleX,
        scaleY: t.scaleY,
        skewX: t.skewX,
        skewY: t.skewY,
        angle: t.angle,
        left: t.left,
        flipX: t.flipX,
        flipY: t.flipY,
        top: t.top
    }), ge = (t, e, s)=>{
    const i = t / 2, r = e / 2, n = [
        new ot(-i, -r),
        new ot(i, -r),
        new ot(-i, r),
        new ot(i, r)
    ].map((t)=>t.transform(s)), o = ae(n);
    return new ot(o.width, o.height);
}, fe = function() {
    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : T;
    return Tt(wt(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : T), t);
}, pe = function(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : T, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : T;
    return t.transform(fe(e, s));
}, me = function(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : T, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : T;
    return t.transform(fe(e, s), !0);
}, ve = (t, e, s)=>{
    const i = fe(e, s);
    return le(t, Tt(i, t.calcOwnMatrix())), i;
}, ye = (t, e)=>{
    var i;
    const { transform: { target: r } } = e;
    null === (i = r.canvas) || void 0 === i || i.fire("object:".concat(t), s(s({}, e), {}, {
        target: r
    })), r.fire(t, e);
}, _e = {
    left: -.5,
    top: -.5,
    center: 0,
    bottom: .5,
    right: .5
}, xe = (t)=>"string" == typeof t ? _e[t] : t - .5, Ce = "not-allowed";
function be(t) {
    return xe(t.originX) === xe(D) && xe(t.originY) === xe(D);
}
function Se(t) {
    return .5 - xe(t);
}
const we = (t, e)=>t[e], Te = (t, e, s, i)=>({
        e: t,
        transform: e,
        pointer: new ot(s, i)
    });
function Oe(t, e) {
    const s = t.getTotalAngle() + Ct(Math.atan2(e.y, e.x)) + 360;
    return Math.round(s % 360 / 45);
}
function ke(t, e, s, i, r) {
    var n;
    let { target: o, corner: a } = t;
    const h = o.controls[a], c = (null === (n = o.canvas) || void 0 === n ? void 0 : n.getZoom()) || 1, l = o.padding / c, u = function(t, e, s, i) {
        const r = t.getRelativeCenterPoint(), n = void 0 !== s && void 0 !== i ? t.translateToGivenOrigin(r, D, D, s, i) : new ot(t.left, t.top);
        return (t.angle ? e.rotate(-xt(t.angle), r) : e).subtract(n);
    }(o, new ot(i, r), e, s);
    return u.x >= l && (u.x -= l), u.x <= -l && (u.x += l), u.y >= l && (u.y -= l), u.y <= l && (u.y += l), u.x -= h.offsetX, u.y -= h.offsetY, u;
}
const De = (t, e, s, i)=>{
    const { target: r, offsetX: n, offsetY: o } = e, a = s - n, h = i - o, c = !we(r, "lockMovementX") && r.left !== a, l = !we(r, "lockMovementY") && r.top !== h;
    return c && r.set(M, a), l && r.set(P, h), (c || l) && ye(L, Te(t, e, s, i)), c || l;
}, Me = {
    aliceblue: "#F0F8FF",
    antiquewhite: "#FAEBD7",
    aqua: "#0FF",
    aquamarine: "#7FFFD4",
    azure: "#F0FFFF",
    beige: "#F5F5DC",
    bisque: "#FFE4C4",
    black: "#000",
    blanchedalmond: "#FFEBCD",
    blue: "#00F",
    blueviolet: "#8A2BE2",
    brown: "#A52A2A",
    burlywood: "#DEB887",
    cadetblue: "#5F9EA0",
    chartreuse: "#7FFF00",
    chocolate: "#D2691E",
    coral: "#FF7F50",
    cornflowerblue: "#6495ED",
    cornsilk: "#FFF8DC",
    crimson: "#DC143C",
    cyan: "#0FF",
    darkblue: "#00008B",
    darkcyan: "#008B8B",
    darkgoldenrod: "#B8860B",
    darkgray: "#A9A9A9",
    darkgrey: "#A9A9A9",
    darkgreen: "#006400",
    darkkhaki: "#BDB76B",
    darkmagenta: "#8B008B",
    darkolivegreen: "#556B2F",
    darkorange: "#FF8C00",
    darkorchid: "#9932CC",
    darkred: "#8B0000",
    darksalmon: "#E9967A",
    darkseagreen: "#8FBC8F",
    darkslateblue: "#483D8B",
    darkslategray: "#2F4F4F",
    darkslategrey: "#2F4F4F",
    darkturquoise: "#00CED1",
    darkviolet: "#9400D3",
    deeppink: "#FF1493",
    deepskyblue: "#00BFFF",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1E90FF",
    firebrick: "#B22222",
    floralwhite: "#FFFAF0",
    forestgreen: "#228B22",
    fuchsia: "#F0F",
    gainsboro: "#DCDCDC",
    ghostwhite: "#F8F8FF",
    gold: "#FFD700",
    goldenrod: "#DAA520",
    gray: "#808080",
    grey: "#808080",
    green: "#008000",
    greenyellow: "#ADFF2F",
    honeydew: "#F0FFF0",
    hotpink: "#FF69B4",
    indianred: "#CD5C5C",
    indigo: "#4B0082",
    ivory: "#FFFFF0",
    khaki: "#F0E68C",
    lavender: "#E6E6FA",
    lavenderblush: "#FFF0F5",
    lawngreen: "#7CFC00",
    lemonchiffon: "#FFFACD",
    lightblue: "#ADD8E6",
    lightcoral: "#F08080",
    lightcyan: "#E0FFFF",
    lightgoldenrodyellow: "#FAFAD2",
    lightgray: "#D3D3D3",
    lightgrey: "#D3D3D3",
    lightgreen: "#90EE90",
    lightpink: "#FFB6C1",
    lightsalmon: "#FFA07A",
    lightseagreen: "#20B2AA",
    lightskyblue: "#87CEFA",
    lightslategray: "#789",
    lightslategrey: "#789",
    lightsteelblue: "#B0C4DE",
    lightyellow: "#FFFFE0",
    lime: "#0F0",
    limegreen: "#32CD32",
    linen: "#FAF0E6",
    magenta: "#F0F",
    maroon: "#800000",
    mediumaquamarine: "#66CDAA",
    mediumblue: "#0000CD",
    mediumorchid: "#BA55D3",
    mediumpurple: "#9370DB",
    mediumseagreen: "#3CB371",
    mediumslateblue: "#7B68EE",
    mediumspringgreen: "#00FA9A",
    mediumturquoise: "#48D1CC",
    mediumvioletred: "#C71585",
    midnightblue: "#191970",
    mintcream: "#F5FFFA",
    mistyrose: "#FFE4E1",
    moccasin: "#FFE4B5",
    navajowhite: "#FFDEAD",
    navy: "#000080",
    oldlace: "#FDF5E6",
    olive: "#808000",
    olivedrab: "#6B8E23",
    orange: "#FFA500",
    orangered: "#FF4500",
    orchid: "#DA70D6",
    palegoldenrod: "#EEE8AA",
    palegreen: "#98FB98",
    paleturquoise: "#AFEEEE",
    palevioletred: "#DB7093",
    papayawhip: "#FFEFD5",
    peachpuff: "#FFDAB9",
    peru: "#CD853F",
    pink: "#FFC0CB",
    plum: "#DDA0DD",
    powderblue: "#B0E0E6",
    purple: "#800080",
    rebeccapurple: "#639",
    red: "#F00",
    rosybrown: "#BC8F8F",
    royalblue: "#4169E1",
    saddlebrown: "#8B4513",
    salmon: "#FA8072",
    sandybrown: "#F4A460",
    seagreen: "#2E8B57",
    seashell: "#FFF5EE",
    sienna: "#A0522D",
    silver: "#C0C0C0",
    skyblue: "#87CEEB",
    slateblue: "#6A5ACD",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#FFFAFA",
    springgreen: "#00FF7F",
    steelblue: "#4682B4",
    tan: "#D2B48C",
    teal: "#008080",
    thistle: "#D8BFD8",
    tomato: "#FF6347",
    turquoise: "#40E0D0",
    violet: "#EE82EE",
    wheat: "#F5DEB3",
    white: "#FFF",
    whitesmoke: "#F5F5F5",
    yellow: "#FF0",
    yellowgreen: "#9ACD32"
}, Pe = (t, e, s)=>(s < 0 && (s += 1), s > 1 && (s -= 1), s < 1 / 6 ? t + 6 * (e - t) * s : s < .5 ? e : s < 2 / 3 ? t + (e - t) * (2 / 3 - s) * 6 : t), Ee = (t, e, s, i)=>{
    t /= 255, e /= 255, s /= 255;
    const r = Math.max(t, e, s), n = Math.min(t, e, s);
    let o, a;
    const h = (r + n) / 2;
    if (r === n) o = a = 0;
    else {
        const i = r - n;
        switch(a = h > .5 ? i / (2 - r - n) : i / (r + n), r){
            case t:
                o = (e - s) / i + (e < s ? 6 : 0);
                break;
            case e:
                o = (s - t) / i + 2;
                break;
            case s:
                o = (t - e) / i + 4;
        }
        o /= 6;
    }
    return [
        Math.round(360 * o),
        Math.round(100 * a),
        Math.round(100 * h),
        i
    ];
}, Ae = function() {
    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "1";
    return parseFloat(t) / (t.endsWith("%") ? 100 : 1);
}, je = (t)=>Math.min(Math.round(t), 255).toString(16).toUpperCase().padStart(2, "0"), Fe = (t)=>{
    let [e, s, i, r = 1] = t;
    const n = Math.round(.3 * e + .59 * s + .11 * i);
    return [
        n,
        n,
        n,
        r
    ];
};
class Le {
    constructor(e){
        if (t(this, "isUnrecognised", !1), e) if (e instanceof Le) this.setSource([
            ...e._source
        ]);
        else if (Array.isArray(e)) {
            const [t, s, i, r = 1] = e;
            this.setSource([
                t,
                s,
                i,
                r
            ]);
        } else this.setSource(this._tryParsingColor(e));
        else this.setSource([
            0,
            0,
            0,
            1
        ]);
    }
    _tryParsingColor(t) {
        return (t = t.toLowerCase()) in Me && (t = Me[t]), "transparent" === t ? [
            255,
            255,
            255,
            0
        ] : Le.sourceFromHex(t) || Le.sourceFromRgb(t) || Le.sourceFromHsl(t) || (this.isUnrecognised = !0) && [
            0,
            0,
            0,
            1
        ];
    }
    getSource() {
        return this._source;
    }
    setSource(t) {
        this._source = t;
    }
    toRgb() {
        const [t, e, s] = this.getSource();
        return "rgb(".concat(t, ",").concat(e, ",").concat(s, ")");
    }
    toRgba() {
        return "rgba(".concat(this.getSource().join(","), ")");
    }
    toHsl() {
        const [t, e, s] = Ee(...this.getSource());
        return "hsl(".concat(t, ",").concat(e, "%,").concat(s, "%)");
    }
    toHsla() {
        const [t, e, s, i] = Ee(...this.getSource());
        return "hsla(".concat(t, ",").concat(e, "%,").concat(s, "%,").concat(i, ")");
    }
    toHex() {
        return this.toHexa().slice(0, 6);
    }
    toHexa() {
        const [t, e, s, i] = this.getSource();
        return "".concat(je(t)).concat(je(e)).concat(je(s)).concat(je(Math.round(255 * i)));
    }
    getAlpha() {
        return this.getSource()[3];
    }
    setAlpha(t) {
        return this._source[3] = t, this;
    }
    toGrayscale() {
        return this.setSource(Fe(this.getSource())), this;
    }
    toBlackWhite(t) {
        const [e, , , s] = Fe(this.getSource()), i = e < (t || 127) ? 0 : 255;
        return this.setSource([
            i,
            i,
            i,
            s
        ]), this;
    }
    overlayWith(t) {
        t instanceof Le || (t = new Le(t));
        const e = this.getSource(), s = t.getSource(), [i, r, n] = e.map((t, e)=>Math.round(.5 * t + .5 * s[e]));
        return this.setSource([
            i,
            r,
            n,
            e[3]
        ]), this;
    }
    static fromRgb(t) {
        return Le.fromRgba(t);
    }
    static fromRgba(t) {
        return new Le(Le.sourceFromRgb(t));
    }
    static sourceFromRgb(t) {
        const e = t.match(/^rgba?\(\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d{0,3}(?:\.\d+)?%?)\s*)?\)$/i);
        if (e) {
            const [t, s, i] = e.slice(1, 4).map((t)=>{
                const e = parseFloat(t);
                return t.endsWith("%") ? Math.round(2.55 * e) : e;
            });
            return [
                t,
                s,
                i,
                Ae(e[4])
            ];
        }
    }
    static fromHsl(t) {
        return Le.fromHsla(t);
    }
    static fromHsla(t) {
        return new Le(Le.sourceFromHsl(t));
    }
    static sourceFromHsl(t) {
        const e = t.match(/^hsla?\(\s*([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d*(?:\.\d+)?%?)\s*)?\)$/i);
        if (!e) return;
        const s = (Le.parseAngletoDegrees(e[1]) % 360 + 360) % 360 / 360, i = parseFloat(e[2]) / 100, r = parseFloat(e[3]) / 100;
        let n, o, a;
        if (0 === i) n = o = a = r;
        else {
            const t = r <= .5 ? r * (i + 1) : r + i - r * i, e = 2 * r - t;
            n = Pe(e, t, s + 1 / 3), o = Pe(e, t, s), a = Pe(e, t, s - 1 / 3);
        }
        return [
            Math.round(255 * n),
            Math.round(255 * o),
            Math.round(255 * a),
            Ae(e[4])
        ];
    }
    static fromHex(t) {
        return new Le(Le.sourceFromHex(t));
    }
    static sourceFromHex(t) {
        if (t.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
            const e = t.slice(t.indexOf("#") + 1);
            let s;
            s = e.length <= 4 ? e.split("").map((t)=>t + t) : e.match(/.{2}/g);
            const [i, r, n, o = 255] = s.map((t)=>parseInt(t, 16));
            return [
                i,
                r,
                n,
                o / 255
            ];
        }
    }
    static parseAngletoDegrees(t) {
        const e = t.toLowerCase(), s = parseFloat(e);
        return e.includes("rad") ? Ct(s) : e.includes("turn") ? 360 * s : s;
    }
}
const Re = function(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O;
    const s = /\D{0,2}$/.exec(t), i = parseFloat(t), r = o.DPI;
    switch(null == s ? void 0 : s[0]){
        case "mm":
            return i * r / 25.4;
        case "cm":
            return i * r / 2.54;
        case "in":
            return i * r;
        case "pt":
            return i * r / 72;
        case "pc":
            return i * r / 72 * 12;
        case "em":
            return i * e;
        default:
            return i;
    }
}, Ie = (t)=>{
    const [e, s] = t.trim().split(" "), [i, r] = (n = e) && n !== j ? [
        n.slice(1, 4),
        n.slice(5, 8)
    ] : n === j ? [
        n,
        n
    ] : [
        "Mid",
        "Mid"
    ];
    var n;
    return {
        meetOrSlice: s || "meet",
        alignX: i,
        alignY: r
    };
}, Be = function(t, e) {
    let s, i, r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    if (e) if (e.toLive) s = "url(#SVGID_".concat(e.id, ")");
    else {
        const t = new Le(e), r = t.getAlpha();
        s = t.toRgb(), 1 !== r && (i = r.toString());
    }
    else s = "none";
    return r ? "".concat(t, ": ").concat(s, "; ").concat(i ? "".concat(t, "-opacity: ").concat(i, "; ") : "") : "".concat(t, '="').concat(s, '" ').concat(i ? "".concat(t, '-opacity="').concat(i, '" ') : "");
};
class Xe {
    getSvgStyles(t) {
        const e = this.fillRule ? this.fillRule : "nonzero", s = this.strokeWidth ? this.strokeWidth : "0", i = this.strokeDashArray ? this.strokeDashArray.join(" ") : j, r = this.strokeDashOffset ? this.strokeDashOffset : "0", n = this.strokeLineCap ? this.strokeLineCap : "butt", o = this.strokeLineJoin ? this.strokeLineJoin : "miter", a = this.strokeMiterLimit ? this.strokeMiterLimit : "4", h = void 0 !== this.opacity ? this.opacity : "1", c = this.visible ? "" : " visibility: hidden;", l = t ? "" : this.getSvgFilter(), u = Be(K, this.fill);
        return [
            Be(J, this.stroke),
            "stroke-width: ",
            s,
            "; ",
            "stroke-dasharray: ",
            i,
            "; ",
            "stroke-linecap: ",
            n,
            "; ",
            "stroke-dashoffset: ",
            r,
            "; ",
            "stroke-linejoin: ",
            o,
            "; ",
            "stroke-miterlimit: ",
            a,
            "; ",
            u,
            "fill-rule: ",
            e,
            "; ",
            "opacity: ",
            h,
            ";",
            l,
            c
        ].join("");
    }
    getSvgFilter() {
        return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
    }
    getSvgCommons() {
        return [
            this.id ? 'id="'.concat(this.id, '" ') : "",
            this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""
        ].join("");
    }
    getSvgTransform(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        const s = t ? this.calcTransformMatrix() : this.calcOwnMatrix(), i = 'transform="'.concat(zt(s));
        return "".concat(i).concat(e, '" ');
    }
    _toSVG(t) {
        return [
            ""
        ];
    }
    toSVG(t) {
        return this._createBaseSVGMarkup(this._toSVG(t), {
            reviver: t
        });
    }
    toClipPathSVG(t) {
        return "\t" + this._createBaseClipPathSVGMarkup(this._toSVG(t), {
            reviver: t
        });
    }
    _createBaseClipPathSVGMarkup(t) {
        let { reviver: e, additionalTransform: s = "" } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i = [
            this.getSvgTransform(!0, s),
            this.getSvgCommons()
        ].join(""), r = t.indexOf("COMMON_PARTS");
        return t[r] = i, e ? e(t.join("")) : t.join("");
    }
    _createBaseSVGMarkup(t) {
        let { noStyle: e, reviver: s, withShadow: i, additionalTransform: r } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const n = e ? "" : 'style="'.concat(this.getSvgStyles(), '" '), o = i ? 'style="'.concat(this.getSvgFilter(), '" ') : "", a = this.clipPath, h = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", c = a && a.absolutePositioned, l = this.stroke, u = this.fill, d = this.shadow, g = [], f = t.indexOf("COMMON_PARTS");
        let p;
        a && (a.clipPathId = "CLIPPATH_".concat(ft()), p = '<clipPath id="'.concat(a.clipPathId, '" >\n').concat(a.toClipPathSVG(s), "</clipPath>\n")), c && g.push("<g ", o, this.getSvgCommons(), " >\n"), g.push("<g ", this.getSvgTransform(!1), c ? "" : o + this.getSvgCommons(), " >\n");
        const m = [
            n,
            h,
            e ? "" : this.addPaintOrder(),
            " ",
            r ? 'transform="'.concat(r, '" ') : ""
        ].join("");
        return t[f] = m, Gt(u) && g.push(u.toSVG(this)), Gt(l) && g.push(l.toSVG(this)), d && g.push(d.toSVG(this)), a && g.push(p), g.push(t.join("")), g.push("</g>\n"), c && g.push("</g>\n"), s ? s(g.join("")) : g.join("");
    }
    addPaintOrder() {
        return this.paintFirst !== K ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
    }
}
function Ye(t) {
    return new RegExp("^(" + t.join("|") + ")\\b", "i");
}
const We = "textDecorationThickness", Ve = [
    "fontSize",
    "fontWeight",
    "fontFamily",
    "fontStyle"
], ze = [
    "underline",
    "overline",
    "linethrough"
], Ge = [
    ...Ve,
    "lineHeight",
    "text",
    "charSpacing",
    "textAlign",
    "styles",
    "path",
    "pathStartOffset",
    "pathSide",
    "pathAlign"
], He = [
    ...Ge,
    ...ze,
    "textBackgroundColor",
    "direction",
    We
], Ne = [
    ...Ve,
    ...ze,
    J,
    "strokeWidth",
    K,
    "deltaY",
    "textBackgroundColor",
    We
], Ue = {
    _reNewline: F,
    _reSpacesAndTabs: /[ \t\r]/g,
    _reSpaceAndTab: /[ \t\r]/,
    _reWords: /\S+/g,
    fontSize: 40,
    fontWeight: "normal",
    fontFamily: "Times New Roman",
    underline: !1,
    overline: !1,
    linethrough: !1,
    textAlign: M,
    fontStyle: "normal",
    lineHeight: 1.16,
    textBackgroundColor: "",
    stroke: null,
    shadow: null,
    path: void 0,
    pathStartOffset: 0,
    pathSide: M,
    pathAlign: "baseline",
    charSpacing: 0,
    deltaY: 0,
    direction: "ltr",
    CACHE_FONT_SIZE: 400,
    MIN_TEXT_WIDTH: 2,
    superscript: {
        size: .6,
        baseline: -.35
    },
    subscript: {
        size: .6,
        baseline: .11
    },
    _fontSizeFraction: .222,
    offsets: {
        underline: .1,
        linethrough: -.28167,
        overline: -.81333
    },
    _fontSizeMult: 1.13,
    [We]: 66.667
}, qe = "justify", Ke = "justify-left", Je = "justify-right", Qe = "justify-center";
var Ze, $e, ts;
const es = String.raw(Ze || (Ze = r([
    "[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?"
], [
    "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?"
]))), ss = String.raw($e || ($e = r([
    "(?:s*,?s+|s*,s*)"
], [
    "(?:\\s*,?\\s+|\\s*,\\s*)"
]))), is = "http://www.w3.org/2000/svg", rs = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + es + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + es + "))?\\s+(.*)"), ns = {
    cx: M,
    x: M,
    r: "radius",
    cy: P,
    y: P,
    display: "visible",
    visibility: "visible",
    transform: "transformMatrix",
    "fill-opacity": "fillOpacity",
    "fill-rule": "fillRule",
    "font-family": "fontFamily",
    "font-size": "fontSize",
    "font-style": "fontStyle",
    "font-weight": "fontWeight",
    "letter-spacing": "charSpacing",
    "paint-order": "paintFirst",
    "stroke-dasharray": "strokeDashArray",
    "stroke-dashoffset": "strokeDashOffset",
    "stroke-linecap": "strokeLineCap",
    "stroke-linejoin": "strokeLineJoin",
    "stroke-miterlimit": "strokeMiterLimit",
    "stroke-opacity": "strokeOpacity",
    "stroke-width": "strokeWidth",
    "text-decoration": "textDecoration",
    "text-anchor": "textAnchor",
    opacity: "opacity",
    "clip-path": "clipPath",
    "clip-rule": "clipRule",
    "vector-effect": "strokeUniform",
    "image-rendering": "imageSmoothing",
    "text-decoration-thickness": We
}, os = "font-size", as = "clip-path", hs = Ye([
    "path",
    "circle",
    "polygon",
    "polyline",
    "ellipse",
    "rect",
    "line",
    "image",
    "text"
]), cs = Ye([
    "symbol",
    "image",
    "marker",
    "pattern",
    "view",
    "svg"
]), ls = Ye([
    "symbol",
    "g",
    "a",
    "svg",
    "clipPath",
    "defs"
]), us = new RegExp(String.raw(ts || (ts = r([
    "^s*(",
    ")",
    "(",
    ")",
    "(",
    ")",
    "(",
    ")s*$"
], [
    "^\\s*(",
    ")",
    "(",
    ")",
    "(",
    ")",
    "(",
    ")\\s*$"
])), es, ss, es, ss, es, ss, es)), ds = new ot(1, 0), gs = new ot, fs = (t, e)=>t.rotate(e), ps = (t, e)=>new ot(e).subtract(t), ms = (t)=>t.distanceFrom(gs), vs = (t, e)=>Math.atan2(Cs(t, e), bs(t, e)), ys = (t)=>vs(ds, t), _s = (t)=>t.eq(gs) ? t : t.scalarDivide(ms(t)), xs = function(t) {
    let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    return _s(new ot(-t.y, t.x).scalarMultiply(e ? 1 : -1));
}, Cs = (t, e)=>t.x * e.y - t.y * e.x, bs = (t, e)=>t.x * e.x + t.y * e.y, Ss = (t, e, s)=>{
    if (t.eq(e) || t.eq(s)) return !0;
    const i = Cs(e, s), r = Cs(e, t), n = Cs(s, t);
    return i >= 0 ? r >= 0 && n <= 0 : !(r <= 0 && n >= 0);
}, ws = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", Ts = new RegExp("(?:\\s|^)" + ws + ws + "(" + es + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class Os {
    constructor(t){
        const e = "string" == typeof t ? Os.parseShadow(t) : t;
        Object.assign(this, Os.ownDefaults, e), this.id = ft();
    }
    static parseShadow(t) {
        const e = t.trim(), [, s = 0, i = 0, r = 0] = (Ts.exec(e) || []).map((t)=>parseFloat(t) || 0);
        return {
            color: (e.replace(Ts, "") || "rgb(0,0,0)").trim(),
            offsetX: s,
            offsetY: i,
            blur: r
        };
    }
    toString() {
        return [
            this.offsetX,
            this.offsetY,
            this.blur,
            this.color
        ].join("px ");
    }
    toSVG(t) {
        const e = fs(new ot(this.offsetX, this.offsetY), xt(-t.angle)), s = new Le(this.color);
        let i = 40, r = 40;
        return t.width && t.height && (i = 100 * Vt((Math.abs(e.x) + this.blur) / t.width, o.NUM_FRACTION_DIGITS) + 20, r = 100 * Vt((Math.abs(e.y) + this.blur) / t.height, o.NUM_FRACTION_DIGITS) + 20), t.flipX && (e.x *= -1), t.flipY && (e.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(r, '%" height="').concat(100 + 2 * r, '%" x="-').concat(i, '%" width="').concat(100 + 2 * i, '%" >\n\t<feGaussianBlur in="SourceAlpha" stdDeviation="').concat(Vt(this.blur ? this.blur / 2 : 0, o.NUM_FRACTION_DIGITS), '"></feGaussianBlur>\n\t<feOffset dx="').concat(Vt(e.x, o.NUM_FRACTION_DIGITS), '" dy="').concat(Vt(e.y, o.NUM_FRACTION_DIGITS), '" result="oBlur" ></feOffset>\n\t<feFlood flood-color="').concat(s.toRgb(), '" flood-opacity="').concat(s.getAlpha(), '"/>\n\t<feComposite in2="oBlur" operator="in" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n\t</feMerge>\n</filter>\n');
    }
    toObject() {
        const t = {
            color: this.color,
            blur: this.blur,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            affectStroke: this.affectStroke,
            nonScaling: this.nonScaling,
            type: this.constructor.type
        }, e = Os.ownDefaults;
        return this.includeDefaultValues ? t : Wt(t, (t, s)=>t !== e[s]);
    }
    static async fromObject(t) {
        return new this(t);
    }
}
t(Os, "ownDefaults", {
    color: "rgb(0,0,0)",
    blur: 0,
    offsetX: 0,
    offsetY: 0,
    affectStroke: !1,
    includeDefaultValues: !0,
    nonScaling: !1
}), t(Os, "type", "shadow"), tt.setClass(Os, "shadow");
const ks = (t, e, s)=>Math.max(t, Math.min(e, s)), Ds = [
    P,
    M,
    H,
    N,
    "flipX",
    "flipY",
    "originX",
    "originY",
    "angle",
    "opacity",
    "globalCompositeOperation",
    "shadow",
    "visible",
    U,
    q
], Ms = [
    K,
    J,
    "strokeWidth",
    "strokeDashArray",
    "width",
    "height",
    "paintFirst",
    "strokeUniform",
    "strokeLineCap",
    "strokeDashOffset",
    "strokeLineJoin",
    "strokeMiterLimit",
    "backgroundColor",
    "clipPath"
], Ps = {
    top: 0,
    left: 0,
    width: 0,
    height: 0,
    angle: 0,
    flipX: !1,
    flipY: !1,
    scaleX: 1,
    scaleY: 1,
    minScaleLimit: 0,
    skewX: 0,
    skewY: 0,
    originX: M,
    originY: P,
    strokeWidth: 1,
    strokeUniform: !1,
    padding: 0,
    opacity: 1,
    paintFirst: K,
    fill: "rgb(0,0,0)",
    fillRule: "nonzero",
    stroke: null,
    strokeDashArray: null,
    strokeDashOffset: 0,
    strokeLineCap: "butt",
    strokeLineJoin: "miter",
    strokeMiterLimit: 4,
    globalCompositeOperation: "source-over",
    backgroundColor: "",
    shadow: null,
    visible: !0,
    includeDefaultValues: !0,
    excludeFromExport: !1,
    objectCaching: !0,
    clipPath: void 0,
    inverted: !1,
    absolutePositioned: !1,
    centeredRotation: !0,
    centeredScaling: !1,
    dirty: !0
}, Es = (t, e, s, i)=>(t < Math.abs(e) ? (t = e, i = s / 4) : i = 0 === e && 0 === t ? s / S * Math.asin(1) : s / S * Math.asin(e / t), {
        a: t,
        c: e,
        p: s,
        s: i
    }), As = (t, e, s, i, r)=>t * Math.pow(2, 10 * (i -= 1)) * Math.sin((i * r - e) * S / s), js = (t, e, s, i)=>-s * Math.cos(t / i * b) + s + e, Fs = (t, e, s, i)=>(t /= i) < 1 / 2.75 ? s * (7.5625 * t * t) + e : t < 2 / 2.75 ? s * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? s * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : s * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e, Ls = (t, e, s, i)=>s - Fs(i - t, 0, s, i) + e;
var Rs = Object.freeze({
    __proto__: null,
    defaultEasing: js,
    easeInBack: function(t, e, s, i) {
        let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1.70158;
        return s * (t /= i) * t * ((r + 1) * t - r) + e;
    },
    easeInBounce: Ls,
    easeInCirc: (t, e, s, i)=>-s * (Math.sqrt(1 - (t /= i) * t) - 1) + e,
    easeInCubic: (t, e, s, i)=>s * (t / i) ** 3 + e,
    easeInElastic: (t, e, s, i)=>{
        const r = s;
        let n = 0;
        if (0 === t) return e;
        if (1 === (t /= i)) return e + s;
        n || (n = .3 * i);
        const { a: o, s: a, p: h } = Es(r, s, n, 1.70158);
        return -As(o, a, h, t, i) + e;
    },
    easeInExpo: (t, e, s, i)=>0 === t ? e : s * 2 ** (10 * (t / i - 1)) + e,
    easeInOutBack: function(t, e, s, i) {
        let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1.70158;
        return (t /= i / 2) < 1 ? s / 2 * (t * t * ((1 + (r *= 1.525)) * t - r)) + e : s / 2 * ((t -= 2) * t * ((1 + (r *= 1.525)) * t + r) + 2) + e;
    },
    easeInOutBounce: (t, e, s, i)=>t < i / 2 ? .5 * Ls(2 * t, 0, s, i) + e : .5 * Fs(2 * t - i, 0, s, i) + .5 * s + e,
    easeInOutCirc: (t, e, s, i)=>(t /= i / 2) < 1 ? -s / 2 * (Math.sqrt(1 - t ** 2) - 1) + e : s / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e,
    easeInOutCubic: (t, e, s, i)=>(t /= i / 2) < 1 ? s / 2 * t ** 3 + e : s / 2 * ((t - 2) ** 3 + 2) + e,
    easeInOutElastic: (t, e, s, i)=>{
        const r = s;
        let n = 0;
        if (0 === t) return e;
        if (2 === (t /= i / 2)) return e + s;
        n || (n = i * (.3 * 1.5));
        const { a: o, s: a, p: h, c: c } = Es(r, s, n, 1.70158);
        return t < 1 ? -.5 * As(o, a, h, t, i) + e : o * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * i - a) * S / h) * .5 + c + e;
    },
    easeInOutExpo: (t, e, s, i)=>0 === t ? e : t === i ? e + s : (t /= i / 2) < 1 ? s / 2 * 2 ** (10 * (t - 1)) + e : s / 2 * -(2 ** (-10 * --t) + 2) + e,
    easeInOutQuad: (t, e, s, i)=>(t /= i / 2) < 1 ? s / 2 * t ** 2 + e : -s / 2 * (--t * (t - 2) - 1) + e,
    easeInOutQuart: (t, e, s, i)=>(t /= i / 2) < 1 ? s / 2 * t ** 4 + e : -s / 2 * ((t -= 2) * t ** 3 - 2) + e,
    easeInOutQuint: (t, e, s, i)=>(t /= i / 2) < 1 ? s / 2 * t ** 5 + e : s / 2 * ((t - 2) ** 5 + 2) + e,
    easeInOutSine: (t, e, s, i)=>-s / 2 * (Math.cos(Math.PI * t / i) - 1) + e,
    easeInQuad: (t, e, s, i)=>s * (t /= i) * t + e,
    easeInQuart: (t, e, s, i)=>s * (t /= i) * t ** 3 + e,
    easeInQuint: (t, e, s, i)=>s * (t / i) ** 5 + e,
    easeInSine: (t, e, s, i)=>-s * Math.cos(t / i * b) + s + e,
    easeOutBack: function(t, e, s, i) {
        let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1.70158;
        return s * ((t = t / i - 1) * t * ((r + 1) * t + r) + 1) + e;
    },
    easeOutBounce: Fs,
    easeOutCirc: (t, e, s, i)=>s * Math.sqrt(1 - (t = t / i - 1) * t) + e,
    easeOutCubic: (t, e, s, i)=>s * ((t / i - 1) ** 3 + 1) + e,
    easeOutElastic: (t, e, s, i)=>{
        const r = s;
        let n = 0;
        if (0 === t) return e;
        if (1 === (t /= i)) return e + s;
        n || (n = .3 * i);
        const { a: o, s: a, p: h, c: c } = Es(r, s, n, 1.70158);
        return o * 2 ** (-10 * t) * Math.sin((t * i - a) * S / h) + c + e;
    },
    easeOutExpo: (t, e, s, i)=>t === i ? e + s : s * -(2 ** (-10 * t / i) + 1) + e,
    easeOutQuad: (t, e, s, i)=>-s * (t /= i) * (t - 2) + e,
    easeOutQuart: (t, e, s, i)=>-s * ((t = t / i - 1) * t ** 3 - 1) + e,
    easeOutQuint: (t, e, s, i)=>s * ((t / i - 1) ** 5 + 1) + e,
    easeOutSine: (t, e, s, i)=>s * Math.sin(t / i * b) + e
});
const Is = ()=>!1;
class Bs {
    constructor(e){
        let { startValue: s, byValue: i, duration: r = 500, delay: n = 0, easing: o = js, onStart: a = C, onChange: h = C, onComplete: c = C, abort: l = Is, target: u } = e;
        t(this, "_state", "pending"), t(this, "durationProgress", 0), t(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = r, this.delay = n, this.easing = o, this._onStart = a, this._onChange = h, this._onComplete = c, this._abort = l, this.target = u, this.startValue = s, this.byValue = i, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
    }
    get state() {
        return this._state;
    }
    isDone() {
        return "aborted" === this._state || "completed" === this._state;
    }
    start() {
        const t = (t)=>{
            "pending" === this._state && (this.startTime = t || +new Date, this._state = "running", this._onStart(), this.tick(this.startTime));
        };
        this.register(), this.delay > 0 ? setTimeout(()=>ut(t), this.delay) : ut(t);
    }
    tick(t) {
        const e = (t || +new Date) - this.startTime, s = Math.min(e, this.duration);
        this.durationProgress = s / this.duration;
        const { value: i, valueProgress: r } = this.calculate(s);
        this.value = Object.freeze(i), this.valueProgress = r, "aborted" !== this._state && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : e >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), ut(this.tick)));
    }
    register() {
        et.push(this);
    }
    unregister() {
        et.remove(this);
    }
    abort() {
        this._state = "aborted", this.unregister();
    }
}
const Xs = [
    "startValue",
    "endValue"
];
class Ys extends Bs {
    constructor(t){
        let { startValue: e = 0, endValue: r = 100 } = t;
        super(s(s({}, i(t, Xs)), {}, {
            startValue: e,
            byValue: r - e
        }));
    }
    calculate(t) {
        const e = this.easing(t, this.startValue, this.byValue, this.duration);
        return {
            value: e,
            valueProgress: Math.abs((e - this.startValue) / this.byValue)
        };
    }
}
const Ws = [
    "startValue",
    "endValue"
];
class Vs extends Bs {
    constructor(t){
        let { startValue: e = [
            0
        ], endValue: r = [
            100
        ] } = t;
        super(s(s({}, i(t, Ws)), {}, {
            startValue: e,
            byValue: r.map((t, s)=>t - e[s])
        }));
    }
    calculate(t) {
        const e = this.startValue.map((e, s)=>this.easing(t, e, this.byValue[s], this.duration, s));
        return {
            value: e,
            valueProgress: Math.abs((e[0] - this.startValue[0]) / this.byValue[0])
        };
    }
}
const zs = [
    "startValue",
    "endValue",
    "easing",
    "onChange",
    "onComplete",
    "abort"
], Gs = (t, e, s, i)=>e + s * (1 - Math.cos(t / i * b)), Hs = (t)=>t && ((e, s, i)=>t(new Le(e).toRgba(), s, i));
class Ns extends Bs {
    constructor(t){
        let { startValue: e, endValue: r, easing: n = Gs, onChange: o, onComplete: a, abort: h } = t, c = i(t, zs);
        const l = new Le(e).getSource(), u = new Le(r).getSource();
        super(s(s({}, c), {}, {
            startValue: l,
            byValue: u.map((t, e)=>t - l[e]),
            easing: n,
            onChange: Hs(o),
            onComplete: Hs(a),
            abort: Hs(h)
        }));
    }
    calculate(t) {
        const [e, s, i, r] = this.startValue.map((e, s)=>this.easing(t, e, this.byValue[s], this.duration, s)), n = [
            ...[
                e,
                s,
                i
            ].map(Math.round),
            ks(0, r, 1)
        ];
        return {
            value: n,
            valueProgress: n.map((t, e)=>0 !== this.byValue[e] ? Math.abs((t - this.startValue[e]) / this.byValue[e]) : 0).find((t)=>0 !== t) || 0
        };
    }
}
function Us(t) {
    const e = ((t)=>Array.isArray(t.startValue) || Array.isArray(t.endValue))(t) ? new Vs(t) : new Ys(t);
    return e.start(), e;
}
function qs(t) {
    const e = new Ns(t);
    return e.start(), e;
}
class Ks {
    constructor(t){
        this.status = t, this.points = [];
    }
    includes(t) {
        return this.points.some((e)=>e.eq(t));
    }
    append() {
        for(var t = arguments.length, e = new Array(t), s = 0; s < t; s++)e[s] = arguments[s];
        return this.points = this.points.concat(e.filter((t)=>!this.includes(t))), this;
    }
    static isPointContained(t, e, s) {
        let i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        if (e.eq(s)) return t.eq(e);
        if (e.x === s.x) return t.x === e.x && (i || t.y >= Math.min(e.y, s.y) && t.y <= Math.max(e.y, s.y));
        if (e.y === s.y) return t.y === e.y && (i || t.x >= Math.min(e.x, s.x) && t.x <= Math.max(e.x, s.x));
        {
            const r = ps(e, s), n = ps(e, t).divide(r);
            return i ? Math.abs(n.x) === Math.abs(n.y) : n.x === n.y && n.x >= 0 && n.x <= 1;
        }
    }
    static isPointInPolygon(t, e) {
        const s = new ot(t).setX(Math.min(t.x - 1, ...e.map((t)=>t.x)));
        let i = 0;
        for(let r = 0; r < e.length; r++){
            const n = this.intersectSegmentSegment(e[r], e[(r + 1) % e.length], t, s);
            if (n.includes(t)) return !0;
            i += Number("Intersection" === n.status);
        }
        return i % 2 == 1;
    }
    static intersectLineLine(t, e, s, i) {
        let r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], n = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5];
        const o = e.x - t.x, a = e.y - t.y, h = i.x - s.x, c = i.y - s.y, l = t.x - s.x, u = t.y - s.y, d = h * u - c * l, g = o * u - a * l, f = c * o - h * a;
        if (0 !== f) {
            const e = d / f, s = g / f;
            return (r || 0 <= e && e <= 1) && (n || 0 <= s && s <= 1) ? new Ks("Intersection").append(new ot(t.x + e * o, t.y + e * a)) : new Ks;
        }
        if (0 === d || 0 === g) {
            const o = r || n || Ks.isPointContained(t, s, i) || Ks.isPointContained(e, s, i) || Ks.isPointContained(s, t, e) || Ks.isPointContained(i, t, e);
            return new Ks(o ? "Coincident" : void 0);
        }
        return new Ks("Parallel");
    }
    static intersectSegmentLine(t, e, s, i) {
        return Ks.intersectLineLine(t, e, s, i, !1, !0);
    }
    static intersectSegmentSegment(t, e, s, i) {
        return Ks.intersectLineLine(t, e, s, i, !1, !1);
    }
    static intersectLinePolygon(t, e, s) {
        let i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        const r = new Ks, n = s.length;
        for(let o, a, h, c = 0; c < n; c++){
            if (o = s[c], a = s[(c + 1) % n], h = Ks.intersectLineLine(t, e, o, a, i, !1), "Coincident" === h.status) return h;
            r.append(...h.points);
        }
        return r.points.length > 0 && (r.status = "Intersection"), r;
    }
    static intersectSegmentPolygon(t, e, s) {
        return Ks.intersectLinePolygon(t, e, s, !1);
    }
    static intersectPolygonPolygon(t, e) {
        const s = new Ks, i = t.length, r = [];
        for(let n = 0; n < i; n++){
            const o = t[n], a = t[(n + 1) % i], h = Ks.intersectSegmentPolygon(o, a, e);
            "Coincident" === h.status ? (r.push(h), s.append(o, a)) : s.append(...h.points);
        }
        return r.length > 0 && r.length === t.length ? new Ks("Coincident") : (s.points.length > 0 && (s.status = "Intersection"), s);
    }
    static intersectPolygonRectangle(t, e, s) {
        const i = e.min(s), r = e.max(s), n = new ot(r.x, i.y), o = new ot(i.x, r.y);
        return Ks.intersectPolygonPolygon(t, [
            i,
            n,
            r,
            o
        ]);
    }
}
class Js extends lt {
    getX() {
        return this.getXY().x;
    }
    setX(t) {
        this.setXY(this.getXY().setX(t));
    }
    getY() {
        return this.getXY().y;
    }
    setY(t) {
        this.setXY(this.getXY().setY(t));
    }
    getRelativeX() {
        return this.left;
    }
    setRelativeX(t) {
        this.left = t;
    }
    getRelativeY() {
        return this.top;
    }
    setRelativeY(t) {
        this.top = t;
    }
    getXY() {
        const t = this.getRelativeXY();
        return this.group ? St(t, this.group.calcTransformMatrix()) : t;
    }
    setXY(t, e, s) {
        this.group && (t = St(t, wt(this.group.calcTransformMatrix()))), this.setRelativeXY(t, e, s);
    }
    getRelativeXY() {
        return new ot(this.left, this.top);
    }
    setRelativeXY(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.originX, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.originY;
        this.setPositionByOrigin(t, e, s);
    }
    isStrokeAccountedForInDimensions() {
        return !1;
    }
    getCoords() {
        const { tl: t, tr: e, br: s, bl: i } = this.aCoords || (this.aCoords = this.calcACoords()), r = [
            t,
            e,
            s,
            i
        ];
        if (this.group) {
            const t = this.group.calcTransformMatrix();
            return r.map((e)=>St(e, t));
        }
        return r;
    }
    intersectsWithRect(t, e) {
        return "Intersection" === Ks.intersectPolygonRectangle(this.getCoords(), t, e).status;
    }
    intersectsWithObject(t) {
        const e = Ks.intersectPolygonPolygon(this.getCoords(), t.getCoords());
        return "Intersection" === e.status || "Coincident" === e.status || t.isContainedWithinObject(this) || this.isContainedWithinObject(t);
    }
    isContainedWithinObject(t) {
        return this.getCoords().every((e)=>t.containsPoint(e));
    }
    isContainedWithinRect(t, e) {
        const { left: s, top: i, width: r, height: n } = this.getBoundingRect();
        return s >= t.x && s + r <= e.x && i >= t.y && i + n <= e.y;
    }
    isOverlapping(t) {
        return this.intersectsWithObject(t) || this.isContainedWithinObject(t) || t.isContainedWithinObject(this);
    }
    containsPoint(t) {
        return Ks.isPointInPolygon(t, this.getCoords());
    }
    isOnScreen() {
        if (!this.canvas) return !1;
        const { tl: t, br: e } = this.canvas.vptCoords;
        return !!this.getCoords().some((s)=>s.x <= e.x && s.x >= t.x && s.y <= e.y && s.y >= t.y) || !!this.intersectsWithRect(t, e) || this.containsPoint(t.midPointFrom(e));
    }
    isPartiallyOnScreen() {
        if (!this.canvas) return !1;
        const { tl: t, br: e } = this.canvas.vptCoords;
        if (this.intersectsWithRect(t, e)) return !0;
        return this.getCoords().every((s)=>(s.x >= e.x || s.x <= t.x) && (s.y >= e.y || s.y <= t.y)) && this.containsPoint(t.midPointFrom(e));
    }
    getBoundingRect() {
        return ae(this.getCoords());
    }
    getScaledWidth() {
        return this._getTransformedDimensions().x;
    }
    getScaledHeight() {
        return this._getTransformedDimensions().y;
    }
    scale(t) {
        this._set(H, t), this._set(N, t), this.setCoords();
    }
    scaleToWidth(t) {
        const e = this.getBoundingRect().width / this.getScaledWidth();
        return this.scale(t / this.width / e);
    }
    scaleToHeight(t) {
        const e = this.getBoundingRect().height / this.getScaledHeight();
        return this.scale(t / this.height / e);
    }
    getCanvasRetinaScaling() {
        var t;
        return (null === (t = this.canvas) || void 0 === t ? void 0 : t.getRetinaScaling()) || 1;
    }
    getTotalAngle() {
        return this.group ? Ct(kt(this.calcTransformMatrix())) : this.angle;
    }
    getViewportTransform() {
        var t;
        return (null === (t = this.canvas) || void 0 === t ? void 0 : t.viewportTransform) || T.concat();
    }
    calcACoords() {
        const t = Pt({
            angle: this.angle
        }), { x: e, y: s } = this.getRelativeCenterPoint(), i = Mt(e, s), r = Tt(i, t), n = this._getTransformedDimensions(), o = n.x / 2, a = n.y / 2;
        return {
            tl: St({
                x: -o,
                y: -a
            }, r),
            tr: St({
                x: o,
                y: -a
            }, r),
            bl: St({
                x: -o,
                y: a
            }, r),
            br: St({
                x: o,
                y: a
            }, r)
        };
    }
    setCoords() {
        this.aCoords = this.calcACoords();
    }
    transformMatrixKey() {
        let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = [];
        return !t && this.group && (e = this.group.transformMatrixKey(t)), e.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, xe(this.originX), xe(this.originY)), e;
    }
    calcTransformMatrix() {
        let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = this.calcOwnMatrix();
        if (t || !this.group) return e;
        const s = this.transformMatrixKey(t), i = this.matrixCache;
        return i && i.key.every((t, e)=>t === s[e]) ? i.value : (this.group && (e = Tt(this.group.calcTransformMatrix(!1), e)), this.matrixCache = {
            key: s,
            value: e
        }, e);
    }
    calcOwnMatrix() {
        const t = this.transformMatrixKey(!0), e = this.ownMatrixCache;
        if (e && e.key === t) return e.value;
        const s = this.getRelativeCenterPoint(), i = {
            angle: this.angle,
            translateX: s.x,
            translateY: s.y,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: this.skewX,
            skewY: this.skewY,
            flipX: this.flipX,
            flipY: this.flipY
        }, r = Rt(i);
        return this.ownMatrixCache = {
            key: t,
            value: r
        }, r;
    }
    _getNonTransformedDimensions() {
        return new ot(this.width, this.height).scalarAdd(this.strokeWidth);
    }
    _calculateCurrentDimensions(t) {
        return this._getTransformedDimensions(t).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
    }
    _getTransformedDimensions() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const e = s({
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: this.skewX,
            skewY: this.skewY,
            width: this.width,
            height: this.height,
            strokeWidth: this.strokeWidth
        }, t), i = e.strokeWidth;
        let r = i, n = 0;
        this.strokeUniform && (r = 0, n = i);
        const o = e.width + r, a = e.height + r;
        let h;
        return h = 0 === e.skewX && 0 === e.skewY ? new ot(o * e.scaleX, a * e.scaleY) : ge(o, a, Lt(e)), h.scalarAdd(n);
    }
    translateToGivenOrigin(t, e, s, i, r) {
        let n = t.x, o = t.y;
        const a = xe(i) - xe(e), h = xe(r) - xe(s);
        if (a || h) {
            const t = this._getTransformedDimensions();
            n += a * t.x, o += h * t.y;
        }
        return new ot(n, o);
    }
    translateToCenterPoint(t, e, s) {
        if (e === D && s === D) return t;
        const i = this.translateToGivenOrigin(t, e, s, D, D);
        return this.angle ? i.rotate(xt(this.angle), t) : i;
    }
    translateToOriginPoint(t, e, s) {
        const i = this.translateToGivenOrigin(t, D, D, e, s);
        return this.angle ? i.rotate(xt(this.angle), t) : i;
    }
    getCenterPoint() {
        const t = this.getRelativeCenterPoint();
        return this.group ? St(t, this.group.calcTransformMatrix()) : t;
    }
    getRelativeCenterPoint() {
        return this.translateToCenterPoint(new ot(this.left, this.top), this.originX, this.originY);
    }
    getPointByOrigin(t, e) {
        return this.translateToOriginPoint(this.getRelativeCenterPoint(), t, e);
    }
    setPositionByOrigin(t, e, s) {
        const i = this.translateToCenterPoint(t, e, s), r = this.translateToOriginPoint(i, this.originX, this.originY);
        this.set({
            left: r.x,
            top: r.y
        });
    }
    _getLeftTopCoords() {
        return this.translateToOriginPoint(this.getRelativeCenterPoint(), M, P);
    }
}
const Qs = [
    "type"
], Zs = [
    "extraParam"
];
let $s = class e extends Js {
    static getDefaults() {
        return e.ownDefaults;
    }
    get type() {
        const t = this.constructor.type;
        return "FabricObject" === t ? "object" : t.toLowerCase();
    }
    set type(t) {
        a("warn", "Setting type has no effect", t);
    }
    constructor(s){
        super(), t(this, "_cacheContext", null), Object.assign(this, e.ownDefaults), this.setOptions(s);
    }
    _createCacheCanvas() {
        this._cacheCanvas = pt(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
    }
    _limitCacheSize(t) {
        const e = t.width, s = t.height, i = o.maxCacheSideLimit, r = o.minCacheSideLimit;
        if (e <= i && s <= i && e * s <= o.perfLimitSizeTotal) return e < r && (t.width = r), s < r && (t.height = r), t;
        const n = e / s, [a, h] = _.limitDimsByArea(n), c = ks(r, a, i), l = ks(r, h, i);
        return e > c && (t.zoomX /= e / c, t.width = c, t.capped = !0), s > l && (t.zoomY /= s / l, t.height = l, t.capped = !0), t;
    }
    _getCacheCanvasDimensions() {
        const t = this.getTotalObjectScaling(), e = this._getTransformedDimensions({
            skewX: 0,
            skewY: 0
        }), s = e.x * t.x / this.scaleX, i = e.y * t.y / this.scaleY;
        return {
            width: Math.ceil(s + 2),
            height: Math.ceil(i + 2),
            zoomX: t.x,
            zoomY: t.y,
            x: s,
            y: i
        };
    }
    _updateCacheCanvas() {
        const t = this._cacheCanvas, e = this._cacheContext, { width: s, height: i, zoomX: r, zoomY: n, x: o, y: a } = this._limitCacheSize(this._getCacheCanvasDimensions()), h = s !== t.width || i !== t.height, c = this.zoomX !== r || this.zoomY !== n;
        if (!t || !e) return !1;
        if (h || c) {
            s !== t.width || i !== t.height ? (t.width = s, t.height = i) : (e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, t.width, t.height));
            const h = o / 2, c = a / 2;
            return this.cacheTranslationX = Math.round(t.width / 2 - h) + h, this.cacheTranslationY = Math.round(t.height / 2 - c) + c, e.translate(this.cacheTranslationX, this.cacheTranslationY), e.scale(r, n), this.zoomX = r, this.zoomY = n, !0;
        }
        return !1;
    }
    setOptions() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        this._setOptions(t);
    }
    transform(t) {
        const e = this.group && !this.group._transformDone || this.group && this.canvas && t === this.canvas.contextTop, s = this.calcTransformMatrix(!e);
        t.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
    }
    getObjectScaling() {
        if (!this.group) return new ot(Math.abs(this.scaleX), Math.abs(this.scaleY));
        const t = Dt(this.calcTransformMatrix());
        return new ot(Math.abs(t.scaleX), Math.abs(t.scaleY));
    }
    getTotalObjectScaling() {
        const t = this.getObjectScaling();
        if (this.canvas) {
            const e = this.canvas.getZoom(), s = this.getCanvasRetinaScaling();
            return t.scalarMultiply(e * s);
        }
        return t;
    }
    getObjectOpacity() {
        let t = this.opacity;
        return this.group && (t *= this.group.getObjectOpacity()), t;
    }
    _constrainScale(t) {
        return Math.abs(t) < this.minScaleLimit ? t < 0 ? -this.minScaleLimit : this.minScaleLimit : 0 === t ? 1e-4 : t;
    }
    _set(t, e) {
        t !== H && t !== N || (e = this._constrainScale(e)), t === H && e < 0 ? (this.flipX = !this.flipX, e *= -1) : "scaleY" === t && e < 0 ? (this.flipY = !this.flipY, e *= -1) : "shadow" !== t || !e || e instanceof Os || (e = new Os(e));
        const s = this[t] !== e;
        return this[t] = e, s && this.constructor.cacheProperties.includes(t) && (this.dirty = !0), this.parent && (this.dirty || s && this.constructor.stateProperties.includes(t)) && this.parent._set("dirty", !0), this;
    }
    isNotVisible() {
        return 0 === this.opacity || !this.width && !this.height && 0 === this.strokeWidth || !this.visible;
    }
    render(t) {
        this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), this.transform(t), this._setOpacity(t), this._setShadow(t), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t)) : (this._removeCacheCanvas(), this.drawObject(t, !1, {}), this.dirty = !1), t.restore());
    }
    drawSelectionBackground(t) {}
    renderCache(t) {
        if (t = t || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
            const { zoomX: e, zoomY: s, cacheTranslationX: i, cacheTranslationY: r } = this, { width: n, height: o } = this._cacheCanvas;
            this.drawObject(this._cacheContext, t.forClipping, {
                zoomX: e,
                zoomY: s,
                cacheTranslationX: i,
                cacheTranslationY: r,
                width: n,
                height: o,
                parentClipPaths: []
            }), this.dirty = !1;
        }
    }
    _removeCacheCanvas() {
        this._cacheCanvas = void 0, this._cacheContext = null;
    }
    hasStroke() {
        return this.stroke && "transparent" !== this.stroke && 0 !== this.strokeWidth;
    }
    hasFill() {
        return this.fill && "transparent" !== this.fill;
    }
    needsItsOwnCache() {
        return !!(this.paintFirst === J && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
    }
    shouldCache() {
        return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
    }
    willDrawShadow() {
        return !!this.shadow && (0 !== this.shadow.offsetX || 0 !== this.shadow.offsetY);
    }
    drawClipPathOnCache(t, e, s) {
        t.save(), e.inverted ? t.globalCompositeOperation = "destination-out" : t.globalCompositeOperation = "destination-in", t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(s, 0, 0), t.restore();
    }
    drawObject(t, e, s) {
        const i = this.fill, r = this.stroke;
        e ? (this.fill = "black", this.stroke = "", this._setClippingProperties(t)) : this._renderBackground(t), this._render(t), this._drawClipPath(t, this.clipPath, s), this.fill = i, this.stroke = r;
    }
    createClipPathLayer(t, e) {
        const s = vt(e), i = s.getContext("2d");
        if (i.translate(e.cacheTranslationX, e.cacheTranslationY), i.scale(e.zoomX, e.zoomY), t._cacheCanvas = s, e.parentClipPaths.forEach((t)=>{
            t.transform(i);
        }), e.parentClipPaths.push(t), t.absolutePositioned) {
            const t = wt(this.calcTransformMatrix());
            i.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
        }
        return t.transform(i), t.drawObject(i, !0, e), s;
    }
    _drawClipPath(t, e, s) {
        if (!e) return;
        e._transformDone = !0;
        const i = this.createClipPathLayer(e, s);
        this.drawClipPathOnCache(t, e, i);
    }
    drawCacheOnCanvas(t) {
        t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
    }
    isCacheDirty() {
        let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        if (this.isNotVisible()) return !1;
        const e = this._cacheCanvas, s = this._cacheContext;
        return !(!e || !s || t || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (e && s && !t && (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, e.width, e.height), s.restore()), !0);
    }
    _renderBackground(t) {
        if (!this.backgroundColor) return;
        const e = this._getNonTransformedDimensions();
        t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t);
    }
    _setOpacity(t) {
        this.group && !this.group._transformDone ? t.globalAlpha = this.getObjectOpacity() : t.globalAlpha *= this.opacity;
    }
    _setStrokeStyles(t, e) {
        const s = e.stroke;
        s && (t.lineWidth = e.strokeWidth, t.lineCap = e.strokeLineCap, t.lineDashOffset = e.strokeDashOffset, t.lineJoin = e.strokeLineJoin, t.miterLimit = e.strokeMiterLimit, Gt(s) ? "percentage" === s.gradientUnits || s.gradientTransform || s.patternTransform ? this._applyPatternForTransformedGradient(t, s) : (t.strokeStyle = s.toLive(t), this._applyPatternGradientTransform(t, s)) : t.strokeStyle = e.stroke);
    }
    _setFillStyles(t, e) {
        let { fill: s } = e;
        s && (Gt(s) ? (t.fillStyle = s.toLive(t), this._applyPatternGradientTransform(t, s)) : t.fillStyle = s);
    }
    _setClippingProperties(t) {
        t.globalAlpha = 1, t.strokeStyle = "transparent", t.fillStyle = "#000000";
    }
    _setLineDash(t, e) {
        e && 0 !== e.length && t.setLineDash(e);
    }
    _setShadow(t) {
        if (!this.shadow) return;
        const e = this.shadow, s = this.canvas, i = this.getCanvasRetinaScaling(), [r, , , n] = (null == s ? void 0 : s.viewportTransform) || T, a = r * i, h = n * i, c = e.nonScaling ? new ot(1, 1) : this.getObjectScaling();
        t.shadowColor = e.color, t.shadowBlur = e.blur * o.browserShadowBlurConstant * (a + h) * (c.x + c.y) / 4, t.shadowOffsetX = e.offsetX * a * c.x, t.shadowOffsetY = e.offsetY * h * c.y;
    }
    _removeShadow(t) {
        this.shadow && (t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0);
    }
    _applyPatternGradientTransform(t, e) {
        if (!Gt(e)) return {
            offsetX: 0,
            offsetY: 0
        };
        const s = e.gradientTransform || e.patternTransform, i = -this.width / 2 + e.offsetX || 0, r = -this.height / 2 + e.offsetY || 0;
        return "percentage" === e.gradientUnits ? t.transform(this.width, 0, 0, this.height, i, r) : t.transform(1, 0, 0, 1, i, r), s && t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), {
            offsetX: i,
            offsetY: r
        };
    }
    _renderPaintInOrder(t) {
        this.paintFirst === J ? (this._renderStroke(t), this._renderFill(t)) : (this._renderFill(t), this._renderStroke(t));
    }
    _render(t) {}
    _renderFill(t) {
        this.fill && (t.save(), this._setFillStyles(t, this), "evenodd" === this.fillRule ? t.fill("evenodd") : t.fill(), t.restore());
    }
    _renderStroke(t) {
        if (this.stroke && 0 !== this.strokeWidth) {
            if (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this.strokeUniform) {
                const e = this.getObjectScaling();
                t.scale(1 / e.x, 1 / e.y);
            }
            this._setLineDash(t, this.strokeDashArray), this._setStrokeStyles(t, this), t.stroke(), t.restore();
        }
    }
    _applyPatternForTransformedGradient(t, e) {
        var s;
        const i = this._limitCacheSize(this._getCacheCanvasDimensions()), r = this.getCanvasRetinaScaling(), n = i.x / this.scaleX / r, o = i.y / this.scaleY / r, a = vt({
            width: Math.ceil(n),
            height: Math.ceil(o)
        }), h = a.getContext("2d");
        h && (h.beginPath(), h.moveTo(0, 0), h.lineTo(n, 0), h.lineTo(n, o), h.lineTo(0, o), h.closePath(), h.translate(n / 2, o / 2), h.scale(i.zoomX / this.scaleX / r, i.zoomY / this.scaleY / r), this._applyPatternGradientTransform(h, e), h.fillStyle = e.toLive(t), h.fill(), t.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), t.scale(r * this.scaleX / i.zoomX, r * this.scaleY / i.zoomY), t.strokeStyle = null !== (s = h.createPattern(a, "no-repeat")) && void 0 !== s ? s : "");
    }
    _findCenterFromElement() {
        return new ot(this.left + this.width / 2, this.top + this.height / 2);
    }
    clone(t) {
        const e = this.toObject(t);
        return this.constructor.fromObject(e);
    }
    cloneAsImage(t) {
        const e = this.toCanvasElement(t);
        return new (tt.getClass("image"))(e);
    }
    toCanvasElement() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const e = de(this), s = this.group, i = this.shadow, r = Math.abs, n = t.enableRetinaScaling ? y() : 1, o = (t.multiplier || 1) * n, a = t.canvasProvider || ((t)=>new se(t, {
                enableRetinaScaling: !1,
                renderOnAddRemove: !1,
                skipOffscreen: !1
            }));
        delete this.group, t.withoutTransform && ue(this), t.withoutShadow && (this.shadow = null), t.viewportTransform && ve(this, this.getViewportTransform()), this.setCoords();
        const h = pt(), c = this.getBoundingRect(), l = this.shadow, u = new ot;
        if (l) {
            const t = l.blur, e = l.nonScaling ? new ot(1, 1) : this.getObjectScaling();
            u.x = 2 * Math.round(r(l.offsetX) + t) * r(e.x), u.y = 2 * Math.round(r(l.offsetY) + t) * r(e.y);
        }
        const d = c.width + u.x, g = c.height + u.y;
        h.width = Math.ceil(d), h.height = Math.ceil(g);
        const f = a(h);
        "jpeg" === t.format && (f.backgroundColor = "#fff"), this.setPositionByOrigin(new ot(f.width / 2, f.height / 2), D, D);
        const p = this.canvas;
        f._objects = [
            this
        ], this.set("canvas", f), this.setCoords();
        const m = f.toCanvasElement(o || 1, t);
        return this.set("canvas", p), this.shadow = i, s && (this.group = s), this.set(e), this.setCoords(), f._objects = [], f.destroy(), m;
    }
    toDataURL() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return yt(this.toCanvasElement(t), t.format || "png", t.quality || 1);
    }
    toBlob() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return _t(this.toCanvasElement(t), t.format || "png", t.quality || 1);
    }
    isType() {
        for(var t = arguments.length, e = new Array(t), s = 0; s < t; s++)e[s] = arguments[s];
        return e.includes(this.constructor.type) || e.includes(this.type);
    }
    complexity() {
        return 1;
    }
    toJSON() {
        return this.toObject();
    }
    rotate(t) {
        const { centeredRotation: e, originX: s, originY: i } = this;
        if (e) {
            const { x: t, y: e } = this.getRelativeCenterPoint();
            this.originX = D, this.originY = D, this.left = t, this.top = e;
        }
        if (this.set("angle", t), e) {
            const { x: t, y: e } = this.translateToOriginPoint(this.getRelativeCenterPoint(), s, i);
            this.left = t, this.top = e, this.originX = s, this.originY = i;
        }
    }
    setOnGroup() {}
    _setupCompositeOperation(t) {
        this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation);
    }
    dispose() {
        et.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && p().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
    }
    animate(t, e) {
        return Object.entries(t).reduce((t, s)=>{
            let [i, r] = s;
            return t[i] = this._animate(i, r, e), t;
        }, {});
    }
    _animate(t, e) {
        let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        const r = t.split("."), n = this.constructor.colorProperties.includes(r[r.length - 1]), { abort: o, startValue: a, onChange: h, onComplete: c } = i, l = s(s({}, i), {}, {
            target: this,
            startValue: null != a ? a : r.reduce((t, e)=>t[e], this),
            endValue: e,
            abort: null == o ? void 0 : o.bind(this),
            onChange: (t, e, s)=>{
                r.reduce((e, s, i)=>(i === r.length - 1 && (e[s] = t), e[s]), this), h && h(t, e, s);
            },
            onComplete: (t, e, s)=>{
                this.setCoords(), c && c(t, e, s);
            }
        });
        return n ? qs(l) : Us(l);
    }
    isDescendantOf(t) {
        const { parent: e, group: s } = this;
        return e === t || s === t || !!e && e.isDescendantOf(t) || !!s && s !== e && s.isDescendantOf(t);
    }
    getAncestors() {
        const t = [];
        let e = this;
        do {
            e = e.parent, e && t.push(e);
        }while (e)
        return t;
    }
    findCommonAncestors(t) {
        if (this === t) return {
            fork: [],
            otherFork: [],
            common: [
                this,
                ...this.getAncestors()
            ]
        };
        const e = this.getAncestors(), s = t.getAncestors();
        if (0 === e.length && s.length > 0 && this === s[s.length - 1]) return {
            fork: [],
            otherFork: [
                t,
                ...s.slice(0, s.length - 1)
            ],
            common: [
                this
            ]
        };
        for(let i, r = 0; r < e.length; r++){
            if (i = e[r], i === t) return {
                fork: [
                    this,
                    ...e.slice(0, r)
                ],
                otherFork: [],
                common: e.slice(r)
            };
            for(let n = 0; n < s.length; n++){
                if (this === s[n]) return {
                    fork: [],
                    otherFork: [
                        t,
                        ...s.slice(0, n)
                    ],
                    common: [
                        this,
                        ...e
                    ]
                };
                if (i === s[n]) return {
                    fork: [
                        this,
                        ...e.slice(0, r)
                    ],
                    otherFork: [
                        t,
                        ...s.slice(0, n)
                    ],
                    common: e.slice(r)
                };
            }
        }
        return {
            fork: [
                this,
                ...e
            ],
            otherFork: [
                t,
                ...s
            ],
            common: []
        };
    }
    hasCommonAncestors(t) {
        const e = this.findCommonAncestors(t);
        return e && !!e.common.length;
    }
    isInFrontOf(t) {
        if (this === t) return;
        const e = this.findCommonAncestors(t);
        if (e.fork.includes(t)) return !0;
        if (e.otherFork.includes(this)) return !1;
        const s = e.common[0] || this.canvas;
        if (!s) return;
        const i = e.fork.pop(), r = e.otherFork.pop(), n = s._objects.indexOf(i), o = s._objects.indexOf(r);
        return n > -1 && n > o;
    }
    toObject() {
        const t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).concat(e.customProperties, this.constructor.customProperties || []);
        let i;
        const r = o.NUM_FRACTION_DIGITS, { clipPath: n, fill: a, stroke: h, shadow: c, strokeDashArray: l, left: u, top: d, originX: g, originY: f, width: p, height: m, strokeWidth: v, strokeLineCap: y, strokeDashOffset: _, strokeLineJoin: C, strokeUniform: b, strokeMiterLimit: S, scaleX: w, scaleY: T, angle: O, flipX: k, flipY: D, opacity: M, visible: P, backgroundColor: E, fillRule: A, paintFirst: j, globalCompositeOperation: F, skewX: L, skewY: R } = this;
        n && !n.excludeFromExport && (i = n.toObject(t.concat("inverted", "absolutePositioned")));
        const I = (t)=>Vt(t, r), B = s(s({}, Yt(this, t)), {}, {
            type: this.constructor.type,
            version: x,
            originX: g,
            originY: f,
            left: I(u),
            top: I(d),
            width: I(p),
            height: I(m),
            fill: Ht(a) ? a.toObject() : a,
            stroke: Ht(h) ? h.toObject() : h,
            strokeWidth: I(v),
            strokeDashArray: l ? l.concat() : l,
            strokeLineCap: y,
            strokeDashOffset: _,
            strokeLineJoin: C,
            strokeUniform: b,
            strokeMiterLimit: I(S),
            scaleX: I(w),
            scaleY: I(T),
            angle: I(O),
            flipX: k,
            flipY: D,
            opacity: I(M),
            shadow: c ? c.toObject() : c,
            visible: P,
            backgroundColor: E,
            fillRule: A,
            paintFirst: j,
            globalCompositeOperation: F,
            skewX: I(L),
            skewY: I(R)
        }, i ? {
            clipPath: i
        } : null);
        return this.includeDefaultValues ? B : this._removeDefaultValues(B);
    }
    toDatalessObject(t) {
        return this.toObject(t);
    }
    _removeDefaultValues(t) {
        const e = this.constructor.getDefaults(), s = Object.keys(e).length > 0 ? e : Object.getPrototypeOf(this);
        return Wt(t, (t, e)=>{
            if (e === M || e === P || "type" === e) return !0;
            const i = s[e];
            return t !== i && !(Array.isArray(t) && Array.isArray(i) && 0 === t.length && 0 === i.length);
        });
    }
    toString() {
        return "#<".concat(this.constructor.type, ">");
    }
    static _fromObject(t) {
        let e = i(t, Qs), s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { extraParam: r } = s, n = i(s, Zs);
        return Xt(e, n).then((t)=>r ? (delete t[r], new this(e[r], t)) : new this(t));
    }
    static fromObject(t, e) {
        return this._fromObject(t, e);
    }
};
t($s, "stateProperties", Ds), t($s, "cacheProperties", Ms), t($s, "ownDefaults", Ps), t($s, "type", "FabricObject"), t($s, "colorProperties", [
    K,
    J,
    "backgroundColor"
]), t($s, "customProperties", []), tt.setClass($s), tt.setClass($s, "object");
const ti = (t, e, i)=>(r, n, o, a)=>{
        const h = e(r, n, o, a);
        return h && ye(t, s(s({}, Te(r, n, o, a)), i)), h;
    };
function ei(t) {
    return (e, s, i, r)=>{
        const { target: n, originX: o, originY: a } = s, h = n.getRelativeCenterPoint(), c = n.translateToOriginPoint(h, o, a), l = t(e, s, i, r);
        return n.setPositionByOrigin(c, s.originX, s.originY), l;
    };
}
const si = ti(Y, ei((t, e, s, i)=>{
    const r = ke(e, e.originX, e.originY, s, i);
    if (xe(e.originX) === xe(D) || xe(e.originX) === xe(A) && r.x < 0 || xe(e.originX) === xe(M) && r.x > 0) {
        const { target: t } = e, s = t.strokeWidth / (t.strokeUniform ? t.scaleX : 1), i = be(e) ? 2 : 1, n = t.width, o = Math.abs(r.x * i / t.scaleX) - s;
        return t.set("width", Math.max(o, 1)), n !== t.width;
    }
    return !1;
}));
function ii(t, e, s, i, r) {
    i = i || {};
    const n = this.sizeX || i.cornerSize || r.cornerSize, o = this.sizeY || i.cornerSize || r.cornerSize, a = void 0 !== i.transparentCorners ? i.transparentCorners : r.transparentCorners, h = a ? J : K, c = !a && (i.cornerStrokeColor || r.cornerStrokeColor);
    let l, u = e, d = s;
    t.save(), t.fillStyle = i.cornerColor || r.cornerColor || "", t.strokeStyle = i.cornerStrokeColor || r.cornerStrokeColor || "", n > o ? (l = n, t.scale(1, o / n), d = s * n / o) : o > n ? (l = o, t.scale(n / o, 1), u = e * o / n) : l = n, t.beginPath(), t.arc(u, d, l / 2, 0, S, !1), t[h](), c && t.stroke(), t.restore();
}
function ri(t, e, s, i, r) {
    i = i || {};
    const n = this.sizeX || i.cornerSize || r.cornerSize, o = this.sizeY || i.cornerSize || r.cornerSize, a = void 0 !== i.transparentCorners ? i.transparentCorners : r.transparentCorners, h = a ? J : K, c = !a && (i.cornerStrokeColor || r.cornerStrokeColor), l = n / 2, u = o / 2;
    t.save(), t.fillStyle = i.cornerColor || r.cornerColor || "", t.strokeStyle = i.cornerStrokeColor || r.cornerStrokeColor || "", t.translate(e, s);
    const d = r.getTotalAngle();
    t.rotate(xt(d)), t["".concat(h, "Rect")](-l, -u, n, o), c && t.strokeRect(-l, -u, n, o), t.restore();
}
class ni {
    constructor(e){
        t(this, "visible", !0), t(this, "actionName", G), t(this, "angle", 0), t(this, "x", 0), t(this, "y", 0), t(this, "offsetX", 0), t(this, "offsetY", 0), t(this, "sizeX", 0), t(this, "sizeY", 0), t(this, "touchSizeX", 0), t(this, "touchSizeY", 0), t(this, "cursorStyle", "crosshair"), t(this, "withConnection", !1), Object.assign(this, e);
    }
    shouldActivate(t, e, s, i) {
        var r;
        let { tl: n, tr: o, br: a, bl: h } = i;
        return (null === (r = e.canvas) || void 0 === r ? void 0 : r.getActiveObject()) === e && e.isControlVisible(t) && Ks.isPointInPolygon(s, [
            n,
            o,
            a,
            h
        ]);
    }
    getActionHandler(t, e, s) {
        return this.actionHandler;
    }
    getMouseDownHandler(t, e, s) {
        return this.mouseDownHandler;
    }
    getMouseUpHandler(t, e, s) {
        return this.mouseUpHandler;
    }
    cursorStyleHandler(t, e, s) {
        return e.cursorStyle;
    }
    getActionName(t, e, s) {
        return e.actionName;
    }
    getVisibility(t, e) {
        var s, i;
        return null !== (s = null === (i = t._controlsVisibility) || void 0 === i ? void 0 : i[e]) && void 0 !== s ? s : this.visible;
    }
    setVisibility(t, e, s) {
        this.visible = t;
    }
    positionHandler(t, e, s, i) {
        return new ot(this.x * t.x + this.offsetX, this.y * t.y + this.offsetY).transform(e);
    }
    calcCornerCoords(t, e, s, i, r, n) {
        const o = Ot([
            Mt(s, i),
            Pt({
                angle: t
            }),
            Et((r ? this.touchSizeX : this.sizeX) || e, (r ? this.touchSizeY : this.sizeY) || e)
        ]);
        return {
            tl: new ot(-.5, -.5).transform(o),
            tr: new ot(.5, -.5).transform(o),
            br: new ot(.5, .5).transform(o),
            bl: new ot(-.5, .5).transform(o)
        };
    }
    render(t, e, s, i, r) {
        if ("circle" === ((i = i || {}).cornerStyle || r.cornerStyle)) ii.call(this, t, e, s, i, r);
        else ri.call(this, t, e, s, i, r);
    }
}
const oi = (t, e, s)=>s.lockRotation ? Ce : e.cursorStyle, ai = ti(I, ei((t, e, s, i)=>{
    let { target: r, ex: n, ey: o, theta: a, originX: h, originY: c } = e;
    const l = r.translateToOriginPoint(r.getRelativeCenterPoint(), h, c);
    if (we(r, "lockRotation")) return !1;
    const u = Math.atan2(o - l.y, n - l.x), d = Math.atan2(i - l.y, s - l.x);
    let g = Ct(d - u + a);
    if (r.snapAngle && r.snapAngle > 0) {
        const t = r.snapAngle, e = r.snapThreshold || t, s = Math.ceil(g / t) * t, i = Math.floor(g / t) * t;
        Math.abs(g - i) < e ? g = i : Math.abs(g - s) < e && (g = s);
    }
    g < 0 && (g = 360 + g), g %= 360;
    const f = r.angle !== g;
    return r.angle = g, f;
}));
function hi(t, e) {
    const s = e.canvas, i = t[s.uniScaleKey];
    return s.uniformScaling && !i || !s.uniformScaling && i;
}
function ci(t, e, s) {
    const i = we(t, "lockScalingX"), r = we(t, "lockScalingY");
    if (i && r) return !0;
    if (!e && (i || r) && s) return !0;
    if (i && "x" === e) return !0;
    if (r && "y" === e) return !0;
    const { width: n, height: o, strokeWidth: a } = t;
    return 0 === n && 0 === a && "y" !== e || 0 === o && 0 === a && "x" !== e;
}
const li = [
    "e",
    "se",
    "s",
    "sw",
    "w",
    "nw",
    "n",
    "ne",
    "e"
], ui = (t, e, s)=>{
    const i = hi(t, s);
    if (ci(s, 0 !== e.x && 0 === e.y ? "x" : 0 === e.x && 0 !== e.y ? "y" : "", i)) return Ce;
    const r = Oe(s, e);
    return "".concat(li[r], "-resize");
};
function di(t, e, s, i) {
    let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
    const n = e.target, o = r.by, a = hi(t, n);
    let h, c, l, u, d, g;
    if (ci(n, o, a)) return !1;
    if (e.gestureScale) c = e.scaleX * e.gestureScale, l = e.scaleY * e.gestureScale;
    else {
        if (h = ke(e, e.originX, e.originY, s, i), d = "y" !== o ? Math.sign(h.x || e.signX || 1) : 1, g = "x" !== o ? Math.sign(h.y || e.signY || 1) : 1, e.signX || (e.signX = d), e.signY || (e.signY = g), we(n, "lockScalingFlip") && (e.signX !== d || e.signY !== g)) return !1;
        if (u = n._getTransformedDimensions(), a && !o) {
            const t = Math.abs(h.x) + Math.abs(h.y), { original: s } = e, i = t / (Math.abs(u.x * s.scaleX / n.scaleX) + Math.abs(u.y * s.scaleY / n.scaleY));
            c = s.scaleX * i, l = s.scaleY * i;
        } else c = Math.abs(h.x * n.scaleX / u.x), l = Math.abs(h.y * n.scaleY / u.y);
        be(e) && (c *= 2, l *= 2), e.signX !== d && "y" !== o && (e.originX = Se(e.originX), c *= -1, e.signX = d), e.signY !== g && "x" !== o && (e.originY = Se(e.originY), l *= -1, e.signY = g);
    }
    const f = n.scaleX, p = n.scaleY;
    return o ? ("x" === o && n.set(H, c), "y" === o && n.set(N, l)) : (!we(n, "lockScalingX") && n.set(H, c), !we(n, "lockScalingY") && n.set(N, l)), f !== n.scaleX || p !== n.scaleY;
}
const gi = ti(R, ei((t, e, s, i)=>di(t, e, s, i))), fi = ti(R, ei((t, e, s, i)=>di(t, e, s, i, {
        by: "x"
    }))), pi = ti(R, ei((t, e, s, i)=>di(t, e, s, i, {
        by: "y"
    }))), mi = [
    "target",
    "ex",
    "ey",
    "skewingSide"
], vi = {
    x: {
        counterAxis: "y",
        scale: H,
        skew: U,
        lockSkewing: "lockSkewingX",
        origin: "originX",
        flip: "flipX"
    },
    y: {
        counterAxis: "x",
        scale: N,
        skew: q,
        lockSkewing: "lockSkewingY",
        origin: "originY",
        flip: "flipY"
    }
}, yi = [
    "ns",
    "nesw",
    "ew",
    "nwse"
], _i = (t, e, s)=>{
    if (0 !== e.x && we(s, "lockSkewingY")) return Ce;
    if (0 !== e.y && we(s, "lockSkewingX")) return Ce;
    const i = Oe(s, e) % 4;
    return "".concat(yi[i], "-resize");
};
function xi(t, e, r, n, o) {
    const { target: a } = r, { counterAxis: h, origin: c, lockSkewing: l, skew: u, flip: d } = vi[t];
    if (we(a, l)) return !1;
    const { origin: g, flip: f } = vi[h], p = xe(r[g]) * (a[f] ? -1 : 1), m = -Math.sign(p) * (a[d] ? -1 : 1), v = .5 * -((0 === a[u] && ke(r, D, D, n, o)[t] > 0 || a[u] > 0 ? 1 : -1) * m) + .5, y = ti(X, ei((e, s, r, n)=>(function(t, e, s) {
            let { target: r, ex: n, ey: o, skewingSide: a } = e, h = i(e, mi);
            const { skew: c } = vi[t], l = s.subtract(new ot(n, o)).divide(new ot(r.scaleX, r.scaleY))[t], u = r[c], d = h[c], g = Math.tan(xt(d)), f = "y" === t ? r._getTransformedDimensions({
                scaleX: 1,
                scaleY: 1,
                skewX: 0
            }).x : r._getTransformedDimensions({
                scaleX: 1,
                scaleY: 1
            }).y, p = 2 * l * a / Math.max(f, 1) + g, m = Ct(Math.atan(p));
            r.set(c, m);
            const v = u !== r[c];
            if (v && "y" === t) {
                const { skewX: t, scaleX: e } = r, s = r._getTransformedDimensions({
                    skewY: u
                }), i = r._getTransformedDimensions(), n = 0 !== t ? s.x / i.x : 1;
                1 !== n && r.set(H, n * e);
            }
            return v;
        })(t, s, new ot(r, n))));
    return y(e, s(s({}, r), {}, {
        [c]: v,
        skewingSide: m
    }), n, o);
}
const Ci = (t, e, s, i)=>xi("x", t, e, s, i), bi = (t, e, s, i)=>xi("y", t, e, s, i);
function Si(t, e) {
    return t[e.canvas.altActionKey];
}
const wi = (t, e, s)=>{
    const i = Si(t, s);
    return 0 === e.x ? i ? U : N : 0 === e.y ? i ? q : H : "";
}, Ti = (t, e, s)=>Si(t, s) ? _i(0, e, s) : ui(t, e, s), Oi = (t, e, s, i)=>Si(t, e.target) ? bi(t, e, s, i) : fi(t, e, s, i), ki = (t, e, s, i)=>Si(t, e.target) ? Ci(t, e, s, i) : pi(t, e, s, i), Di = ()=>({
        ml: new ni({
            x: -.5,
            y: 0,
            cursorStyleHandler: Ti,
            actionHandler: Oi,
            getActionName: wi
        }),
        mr: new ni({
            x: .5,
            y: 0,
            cursorStyleHandler: Ti,
            actionHandler: Oi,
            getActionName: wi
        }),
        mb: new ni({
            x: 0,
            y: .5,
            cursorStyleHandler: Ti,
            actionHandler: ki,
            getActionName: wi
        }),
        mt: new ni({
            x: 0,
            y: -.5,
            cursorStyleHandler: Ti,
            actionHandler: ki,
            getActionName: wi
        }),
        tl: new ni({
            x: -.5,
            y: -.5,
            cursorStyleHandler: ui,
            actionHandler: gi
        }),
        tr: new ni({
            x: .5,
            y: -.5,
            cursorStyleHandler: ui,
            actionHandler: gi
        }),
        bl: new ni({
            x: -.5,
            y: .5,
            cursorStyleHandler: ui,
            actionHandler: gi
        }),
        br: new ni({
            x: .5,
            y: .5,
            cursorStyleHandler: ui,
            actionHandler: gi
        }),
        mtr: new ni({
            x: 0,
            y: -.5,
            actionHandler: ai,
            cursorStyleHandler: oi,
            offsetY: -40,
            withConnection: !0,
            actionName: B
        })
    }), Mi = ()=>({
        mr: new ni({
            x: .5,
            y: 0,
            actionHandler: si,
            cursorStyleHandler: Ti,
            actionName: Y
        }),
        ml: new ni({
            x: -.5,
            y: 0,
            actionHandler: si,
            cursorStyleHandler: Ti,
            actionName: Y
        })
    }), Pi = ()=>s(s({}, Di()), Mi());
class Ei extends $s {
    static getDefaults() {
        return s(s({}, super.getDefaults()), Ei.ownDefaults);
    }
    constructor(t){
        super(), Object.assign(this, this.constructor.createControls(), Ei.ownDefaults), this.setOptions(t);
    }
    static createControls() {
        return {
            controls: Di()
        };
    }
    _updateCacheCanvas() {
        const t = this.canvas;
        if (this.noScaleCache && t && t._currentTransform) {
            const e = t._currentTransform, s = e.target, i = e.action;
            if (this === s && i && i.startsWith(G)) return !1;
        }
        return super._updateCacheCanvas();
    }
    getActiveControl() {
        const t = this.__corner;
        return t ? {
            key: t,
            control: this.controls[t],
            coord: this.oCoords[t]
        } : void 0;
    }
    findControl(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!this.hasControls || !this.canvas) return;
        this.__corner = void 0;
        const s = Object.entries(this.oCoords);
        for(let i = s.length - 1; i >= 0; i--){
            const [r, n] = s[i], o = this.controls[r];
            if (o.shouldActivate(r, this, t, e ? n.touchCorner : n.corner)) return this.__corner = r, {
                key: r,
                control: o,
                coord: this.oCoords[r]
            };
        }
    }
    calcOCoords() {
        const t = this.getViewportTransform(), e = this.getCenterPoint(), s = Mt(e.x, e.y), i = Pt({
            angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0)
        }), r = Tt(s, i), n = Tt(t, r), o = Tt(n, [
            1 / t[0],
            0,
            0,
            1 / t[3],
            0,
            0
        ]), a = this.group ? Dt(this.calcTransformMatrix()) : void 0;
        a && (a.scaleX = Math.abs(a.scaleX), a.scaleY = Math.abs(a.scaleY));
        const h = this._calculateCurrentDimensions(a), c = {};
        return this.forEachControl((t, e)=>{
            const s = t.positionHandler(h, o, this, t);
            c[e] = Object.assign(s, this._calcCornerCoords(t, s));
        }), c;
    }
    _calcCornerCoords(t, e) {
        const s = this.getTotalAngle();
        return {
            corner: t.calcCornerCoords(s, this.cornerSize, e.x, e.y, !1, this),
            touchCorner: t.calcCornerCoords(s, this.touchCornerSize, e.x, e.y, !0, this)
        };
    }
    setCoords() {
        super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
    }
    forEachControl(t) {
        for(const e in this.controls)t(this.controls[e], e, this);
    }
    drawSelectionBackground(t) {
        if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
        t.save();
        const e = this.getRelativeCenterPoint(), s = this._calculateCurrentDimensions(), i = this.getViewportTransform();
        t.translate(e.x, e.y), t.scale(1 / i[0], 1 / i[3]), t.rotate(xt(this.angle)), t.fillStyle = this.selectionBackgroundColor, t.fillRect(-s.x / 2, -s.y / 2, s.x, s.y), t.restore();
    }
    strokeBorders(t, e) {
        t.strokeRect(-e.x / 2, -e.y / 2, e.x, e.y);
    }
    _drawBorders(t, e) {
        let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        const r = s({
            hasControls: this.hasControls,
            borderColor: this.borderColor,
            borderDashArray: this.borderDashArray
        }, i);
        t.save(), t.strokeStyle = r.borderColor, this._setLineDash(t, r.borderDashArray), this.strokeBorders(t, e), r.hasControls && this.drawControlsConnectingLines(t, e), t.restore();
    }
    _renderControls(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const { hasBorders: i, hasControls: r } = this, n = s({
            hasBorders: i,
            hasControls: r
        }, e), o = this.getViewportTransform(), a = n.hasBorders, h = n.hasControls, c = Tt(o, this.calcTransformMatrix()), l = Dt(c);
        t.save(), t.translate(l.translateX, l.translateY), t.lineWidth = this.borderScaleFactor, this.group === this.parent && (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (l.angle -= 180), t.rotate(xt(this.group ? l.angle : this.angle)), a && this.drawBorders(t, l, e), h && this.drawControls(t, e), t.restore();
    }
    drawBorders(t, e, s) {
        let i;
        if (s && s.forActiveSelection || this.group) {
            const t = ge(this.width, this.height, Lt(e)), s = this.isStrokeAccountedForInDimensions() ? at : (this.strokeUniform ? (new ot).scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new ot(e.scaleX, e.scaleY)).scalarMultiply(this.strokeWidth);
            i = t.add(s).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
        } else i = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
        this._drawBorders(t, i, s);
    }
    drawControlsConnectingLines(t, e) {
        let s = !1;
        t.beginPath(), this.forEachControl((i, r)=>{
            i.withConnection && i.getVisibility(this, r) && (s = !0, t.moveTo(i.x * e.x, i.y * e.y), t.lineTo(i.x * e.x + i.offsetX, i.y * e.y + i.offsetY));
        }), s && t.stroke();
    }
    drawControls(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        t.save();
        const i = this.getCanvasRetinaScaling(), { cornerStrokeColor: r, cornerDashArray: n, cornerColor: o } = this, a = s({
            cornerStrokeColor: r,
            cornerDashArray: n,
            cornerColor: o
        }, e);
        t.setTransform(i, 0, 0, i, 0, 0), t.strokeStyle = t.fillStyle = a.cornerColor, this.transparentCorners || (t.strokeStyle = a.cornerStrokeColor), this._setLineDash(t, a.cornerDashArray), this.forEachControl((e, s)=>{
            if (e.getVisibility(this, s)) {
                const i = this.oCoords[s];
                e.render(t, i.x, i.y, a, this);
            }
        }), t.restore();
    }
    isControlVisible(t) {
        return this.controls[t] && this.controls[t].getVisibility(this, t);
    }
    setControlVisible(t, e) {
        this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[t] = e;
    }
    setControlsVisibility() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        Object.entries(t).forEach((t)=>{
            let [e, s] = t;
            return this.setControlVisible(e, s);
        });
    }
    clearContextTop(t) {
        if (!this.canvas) return;
        const e = this.canvas.contextTop;
        if (!e) return;
        const s = this.canvas.viewportTransform;
        e.save(), e.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this.transform(e);
        const i = this.width + 4, r = this.height + 4;
        return e.clearRect(-i / 2, -r / 2, i, r), t || e.restore(), e;
    }
    onDeselect(t) {
        return !1;
    }
    onSelect(t) {
        return !1;
    }
    shouldStartDragging(t) {
        return !1;
    }
    onDragStart(t) {
        return !1;
    }
    canDrop(t) {
        return !1;
    }
    renderDragSourceEffect(t) {}
    renderDropTargetEffect(t) {}
}
function Ai(t, e) {
    return e.forEach((e)=>{
        Object.getOwnPropertyNames(e.prototype).forEach((s)=>{
            "constructor" !== s && Object.defineProperty(t.prototype, s, Object.getOwnPropertyDescriptor(e.prototype, s) || Object.create(null));
        });
    }), t;
}
t(Ei, "ownDefaults", {
    noScaleCache: !0,
    lockMovementX: !1,
    lockMovementY: !1,
    lockRotation: !1,
    lockScalingX: !1,
    lockScalingY: !1,
    lockSkewingX: !1,
    lockSkewingY: !1,
    lockScalingFlip: !1,
    cornerSize: 13,
    touchCornerSize: 24,
    transparentCorners: !0,
    cornerColor: "rgb(178,204,255)",
    cornerStrokeColor: "",
    cornerStyle: "rect",
    cornerDashArray: null,
    hasControls: !0,
    borderColor: "rgb(178,204,255)",
    borderDashArray: null,
    borderOpacityWhenMoving: .4,
    borderScaleFactor: 1,
    hasBorders: !0,
    selectionBackgroundColor: "",
    selectable: !0,
    evented: !0,
    perPixelTargetFind: !1,
    activeOn: "down",
    hoverCursor: null,
    moveCursor: null
});
class ji extends Ei {
}
Ai(ji, [
    Xe
]), tt.setClass(ji), tt.setClass(ji, "object");
const Fi = (t, e, s, i)=>{
    const r = 2 * (i = Math.round(i)) + 1, { data: n } = t.getImageData(e - i, s - i, r, r);
    for(let t = 3; t < n.length; t += 4){
        if (n[t] > 0) return !1;
    }
    return !0;
};
class Li {
    constructor(t){
        this.options = t, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new ot(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new ot(1 / this.options.scaleX, 1 / this.options.scaleY) : new ot(1, 1);
    }
    createSideVector(t, e) {
        const s = ps(t, e);
        return this.options.strokeUniform ? s.multiply(this.scale) : s;
    }
    projectOrthogonally(t, e, s) {
        return this.applySkew(t.add(this.calcOrthogonalProjection(t, e, s)));
    }
    isSkewed() {
        return 0 !== this.options.skewX || 0 !== this.options.skewY;
    }
    applySkew(t) {
        const e = new ot(t);
        return e.y += e.x * Math.tan(xt(this.options.skewY)), e.x += e.y * Math.tan(xt(this.options.skewX)), e;
    }
    scaleUnitVector(t, e) {
        return t.multiply(this.strokeUniformScalar).scalarMultiply(e);
    }
}
const Ri = new ot;
class Ii extends Li {
    static getOrthogonalRotationFactor(t, e) {
        const s = e ? vs(t, e) : ys(t);
        return Math.abs(s) < b ? -1 : 1;
    }
    constructor(e, s, i, r){
        super(r), t(this, "AB", void 0), t(this, "AC", void 0), t(this, "alpha", void 0), t(this, "bisector", void 0), this.A = new ot(e), this.B = new ot(s), this.C = new ot(i), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = vs(this.AB, this.AC), this.bisector = _s(fs(this.AB.eq(Ri) ? this.AC : this.AB, this.alpha / 2));
    }
    calcOrthogonalProjection(t, e) {
        let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.strokeProjectionMagnitude;
        const i = this.createSideVector(t, e), r = xs(i), n = Ii.getOrthogonalRotationFactor(r, this.bisector);
        return this.scaleUnitVector(r, s * n);
    }
    projectBevel() {
        const t = [];
        return (this.alpha % S == 0 ? [
            this.B
        ] : [
            this.B,
            this.C
        ]).forEach((e)=>{
            t.push(this.projectOrthogonally(this.A, e)), t.push(this.projectOrthogonally(this.A, e, -this.strokeProjectionMagnitude));
        }), t;
    }
    projectMiter() {
        const t = [], e = Math.abs(this.alpha), s = 1 / Math.sin(e / 2), i = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * s), r = this.options.strokeUniform ? ms(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
        return ms(i) / this.strokeProjectionMagnitude <= r && t.push(this.applySkew(this.A.add(i))), t.push(...this.projectBevel()), t;
    }
    projectRoundNoSkew(t, e) {
        const s = [], i = new ot(Ii.getOrthogonalRotationFactor(this.bisector), Ii.getOrthogonalRotationFactor(new ot(this.bisector.y, this.bisector.x)));
        return [
            new ot(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i),
            new ot(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i)
        ].forEach((i)=>{
            Ss(i, t, e) && s.push(this.A.add(i));
        }), s;
    }
    projectRoundWithSkew(t, e) {
        const s = [], { skewX: i, skewY: r, scaleX: n, scaleY: o, strokeUniform: a } = this.options, h = new ot(Math.tan(xt(i)), Math.tan(xt(r))), c = this.strokeProjectionMagnitude, l = a ? c / o / Math.sqrt(1 / o ** 2 + 1 / n ** 2 * h.y ** 2) : c / Math.sqrt(1 + h.y ** 2), u = new ot(Math.sqrt(Math.max(c ** 2 - l ** 2, 0)), l), d = a ? c / Math.sqrt(1 + h.x ** 2 * (1 / o) ** 2 / (1 / n + 1 / n * h.x * h.y) ** 2) : c / Math.sqrt(1 + h.x ** 2 / (1 + h.x * h.y) ** 2), g = new ot(d, Math.sqrt(Math.max(c ** 2 - d ** 2, 0)));
        return [
            g,
            g.scalarMultiply(-1),
            u,
            u.scalarMultiply(-1)
        ].map((t)=>this.applySkew(a ? t.multiply(this.strokeUniformScalar) : t)).forEach((i)=>{
            Ss(i, t, e) && s.push(this.applySkew(this.A).add(i));
        }), s;
    }
    projectRound() {
        const t = [];
        t.push(...this.projectBevel());
        const e = this.alpha % S == 0, s = this.applySkew(this.A), i = t[e ? 0 : 2].subtract(s), r = t[e ? 1 : 0].subtract(s), n = e ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), o = Cs(i, n) > 0, a = o ? i : r, h = o ? r : i;
        return this.isSkewed() ? t.push(...this.projectRoundWithSkew(a, h)) : t.push(...this.projectRoundNoSkew(a, h)), t;
    }
    projectPoints() {
        switch(this.options.strokeLineJoin){
            case "miter":
                return this.projectMiter();
            case "round":
                return this.projectRound();
            default:
                return this.projectBevel();
        }
    }
    project() {
        return this.projectPoints().map((t)=>({
                originPoint: this.A,
                projectedPoint: t,
                angle: this.alpha,
                bisector: this.bisector
            }));
    }
}
class Bi extends Li {
    constructor(t, e, s){
        super(s), this.A = new ot(t), this.T = new ot(e);
    }
    calcOrthogonalProjection(t, e) {
        let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.strokeProjectionMagnitude;
        const i = this.createSideVector(t, e);
        return this.scaleUnitVector(xs(i), s);
    }
    projectButt() {
        return [
            this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude),
            this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)
        ];
    }
    projectRound() {
        const t = [];
        if (!this.isSkewed() && this.A.eq(this.T)) {
            const e = new ot(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
            t.push(this.applySkew(this.A.add(e)), this.applySkew(this.A.subtract(e)));
        } else t.push(...new Ii(this.A, this.T, this.T, this.options).projectRound());
        return t;
    }
    projectSquare() {
        const t = [];
        if (this.A.eq(this.T)) {
            const e = new ot(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
            t.push(this.A.add(e), this.A.subtract(e));
        } else {
            const e = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), s = this.scaleUnitVector(_s(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), i = this.A.add(s);
            t.push(i.add(e), i.subtract(e));
        }
        return t.map((t)=>this.applySkew(t));
    }
    projectPoints() {
        switch(this.options.strokeLineCap){
            case "round":
                return this.projectRound();
            case "square":
                return this.projectSquare();
            default:
                return this.projectButt();
        }
    }
    project() {
        return this.projectPoints().map((t)=>({
                originPoint: this.A,
                projectedPoint: t
            }));
    }
}
const Xi = function(t, e) {
    let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const i = [];
    if (0 === t.length) return i;
    const r = t.reduce((t, e)=>(t[t.length - 1].eq(e) || t.push(new ot(e)), t), [
        new ot(t[0])
    ]);
    if (1 === r.length) s = !0;
    else if (!s) {
        const t = r[0], e = ((t, e)=>{
            for(let s = t.length - 1; s >= 0; s--)if (e(t[s], s, t)) return s;
            return -1;
        })(r, (e)=>!e.eq(t));
        r.splice(e + 1);
    }
    return r.forEach((t, r, n)=>{
        let o, a;
        0 === r ? (a = n[1], o = s ? t : n[n.length - 1]) : r === n.length - 1 ? (o = n[r - 1], a = s ? t : n[0]) : (o = n[r - 1], a = n[r + 1]), s && 1 === n.length ? i.push(...new Bi(t, t, e).project()) : !s || 0 !== r && r !== n.length - 1 ? i.push(...new Ii(t, o, a, e).project()) : i.push(...new Bi(t, 0 === r ? a : o, e).project());
    }), i;
}, Yi = (t)=>{
    const e = {};
    return Object.keys(t).forEach((i)=>{
        e[i] = {}, Object.keys(t[i]).forEach((r)=>{
            e[i][r] = s({}, t[i][r]);
        });
    }), e;
}, Wi = (t)=>t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
let Vi;
const zi = (t)=>{
    if (Vi || Vi || (Vi = "Intl" in v() && "Segmenter" in Intl && new Intl.Segmenter(void 0, {
        granularity: "grapheme"
    })), Vi) {
        const e = Vi.segment(t);
        return Array.from(e).map((t)=>{
            let { segment: e } = t;
            return e;
        });
    }
    return Gi(t);
}, Gi = (t)=>{
    const e = [];
    for(let s, i = 0; i < t.length; i++)!1 !== (s = Hi(t, i)) && e.push(s);
    return e;
}, Hi = (t, e)=>{
    const s = t.charCodeAt(e);
    if (isNaN(s)) return "";
    if (s < 55296 || s > 57343) return t.charAt(e);
    if (55296 <= s && s <= 56319) {
        if (t.length <= e + 1) throw "High surrogate without following low surrogate";
        const s = t.charCodeAt(e + 1);
        if (56320 > s || s > 57343) throw "High surrogate without following low surrogate";
        return t.charAt(e) + t.charAt(e + 1);
    }
    if (0 === e) throw "Low surrogate without preceding high surrogate";
    const i = t.charCodeAt(e - 1);
    if (55296 > i || i > 56319) throw "Low surrogate without preceding high surrogate";
    return !1;
};
var Ni = Object.freeze({
    __proto__: null,
    capitalize: function(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return "".concat(t.charAt(0).toUpperCase()).concat(e ? t.slice(1) : t.slice(1).toLowerCase());
    },
    escapeXml: Wi,
    graphemeSplit: zi
});
const Ui = function(t, e) {
    let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return t.fill !== e.fill || t.stroke !== e.stroke || t.strokeWidth !== e.strokeWidth || t.fontSize !== e.fontSize || t.fontFamily !== e.fontFamily || t.fontWeight !== e.fontWeight || t.fontStyle !== e.fontStyle || t.textDecorationThickness !== e.textDecorationThickness || t.textBackgroundColor !== e.textBackgroundColor || t.deltaY !== e.deltaY || s && (t.overline !== e.overline || t.underline !== e.underline || t.linethrough !== e.linethrough);
}, qi = (t, e)=>{
    const s = e.split("\n"), i = [];
    let r = -1, n = {};
    t = Yi(t);
    for(let e = 0; e < s.length; e++){
        const o = zi(s[e]);
        if (t[e]) for(let s = 0; s < o.length; s++){
            r++;
            const o = t[e][s];
            o && Object.keys(o).length > 0 && (Ui(n, o, !0) ? i.push({
                start: r,
                end: r + 1,
                style: o
            }) : i[i.length - 1].end++), n = o || {};
        }
        else r += o.length, n = {};
    }
    return i;
}, Ki = (t, e)=>{
    if (!Array.isArray(t)) return Yi(t);
    const i = e.split(F), r = {};
    let n = -1, o = 0;
    for(let e = 0; e < i.length; e++){
        const a = zi(i[e]);
        for(let i = 0; i < a.length; i++)n++, t[o] && t[o].start <= n && n < t[o].end && (r[e] = r[e] || {}, r[e][i] = s({}, t[o].style), n === t[o].end - 1 && o++);
    }
    return r;
}, Ji = [
    "display",
    "transform",
    K,
    "fill-opacity",
    "fill-rule",
    "opacity",
    J,
    "stroke-dasharray",
    "stroke-linecap",
    "stroke-dashoffset",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "id",
    "paint-order",
    "vector-effect",
    "instantiated_by_use",
    "clip-path"
];
function Qi(t, e) {
    const s = t.nodeName, i = t.getAttribute("class"), r = t.getAttribute("id"), n = "(?![a-zA-Z\\-]+)";
    let o;
    if (o = new RegExp("^" + s, "i"), e = e.replace(o, ""), r && e.length && (o = new RegExp("#" + r + n, "i"), e = e.replace(o, "")), i && e.length) {
        const t = i.split(" ");
        for(let s = t.length; s--;)o = new RegExp("\\." + t[s] + n, "i"), e = e.replace(o, "");
    }
    return 0 === e.length;
}
function Zi(t, e) {
    let s = !0;
    const i = Qi(t, e.pop());
    return i && e.length && (s = function(t, e) {
        let s, i = !0;
        for(; t.parentElement && 1 === t.parentElement.nodeType && e.length;)i && (s = e.pop()), i = Qi(t = t.parentElement, s);
        return 0 === e.length;
    }(t, e)), i && s && 0 === e.length;
}
const $i = (t)=>{
    var e;
    return null !== (e = ns[t]) && void 0 !== e ? e : t;
}, tr = new RegExp("(".concat(es, ")"), "gi"), er = (t)=>t.replace(tr, " $1 ").replace(/,/gi, " ").replace(/\s+/gi, " ");
var sr, ir, rr, nr, or, ar, hr;
const cr = "(".concat(es, ")"), lr = String.raw(sr || (sr = r([
    "(skewX)(",
    ")"
], [
    "(skewX)\\(",
    "\\)"
])), cr), ur = String.raw(ir || (ir = r([
    "(skewY)(",
    ")"
], [
    "(skewY)\\(",
    "\\)"
])), cr), dr = String.raw(rr || (rr = r([
    "(rotate)(",
    "(?: ",
    " ",
    ")?)"
], [
    "(rotate)\\(",
    "(?: ",
    " ",
    ")?\\)"
])), cr, cr, cr), gr = String.raw(nr || (nr = r([
    "(scale)(",
    "(?: ",
    ")?)"
], [
    "(scale)\\(",
    "(?: ",
    ")?\\)"
])), cr, cr), fr = String.raw(or || (or = r([
    "(translate)(",
    "(?: ",
    ")?)"
], [
    "(translate)\\(",
    "(?: ",
    ")?\\)"
])), cr, cr), pr = String.raw(ar || (ar = r([
    "(matrix)(",
    " ",
    " ",
    " ",
    " ",
    " ",
    ")"
], [
    "(matrix)\\(",
    " ",
    " ",
    " ",
    " ",
    " ",
    "\\)"
])), cr, cr, cr, cr, cr, cr), mr = "(?:".concat(pr, "|").concat(fr, "|").concat(dr, "|").concat(gr, "|").concat(lr, "|").concat(ur, ")"), vr = "(?:".concat(mr, "*)"), yr = String.raw(hr || (hr = r([
    "^s*(?:",
    "?)s*$"
], [
    "^\\s*(?:",
    "?)\\s*$"
])), vr), _r = new RegExp(yr), xr = new RegExp(mr), Cr = new RegExp(mr, "g");
function br(t) {
    const e = [];
    if (!(t = er(t).replace(/\s*([()])\s*/gi, "$1")) || t && !_r.test(t)) return [
        ...T
    ];
    for (const s of t.matchAll(Cr)){
        const t = xr.exec(s[0]);
        if (!t) continue;
        let i = T;
        const r = t.filter((t)=>!!t), [, n, ...o] = r, [a, h, c, l, u, d] = o.map((t)=>parseFloat(t));
        switch(n){
            case "translate":
                i = Mt(a, h);
                break;
            case B:
                i = Pt({
                    angle: a
                }, {
                    x: h,
                    y: c
                });
                break;
            case G:
                i = Et(a, h);
                break;
            case U:
                i = jt(a);
                break;
            case q:
                i = Ft(a);
                break;
            case "matrix":
                i = [
                    a,
                    h,
                    c,
                    l,
                    u,
                    d
                ];
        }
        e.push(i);
    }
    return Ot(e);
}
function Sr(t, e, s, i) {
    const r = Array.isArray(e);
    let n, o = e;
    if (t !== K && t !== J || e !== j) {
        if ("strokeUniform" === t) return "non-scaling-stroke" === e;
        if ("strokeDashArray" === t) o = e === j ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
        else if ("transformMatrix" === t) o = s && s.transformMatrix ? Tt(s.transformMatrix, br(e)) : br(e);
        else if ("visible" === t) o = e !== j && "hidden" !== e, s && !1 === s.visible && (o = !1);
        else if ("opacity" === t) o = parseFloat(e), s && void 0 !== s.opacity && (o *= s.opacity);
        else if ("textAnchor" === t) o = "start" === e ? M : "end" === e ? A : D;
        else if ("charSpacing" === t || t === We) n = Re(e, i) / i * 1e3;
        else if ("paintFirst" === t) {
            const t = e.indexOf(K), s = e.indexOf(J);
            o = K, (t > -1 && s > -1 && s < t || -1 === t && s > -1) && (o = J);
        } else {
            if ("href" === t || "xlink:href" === t || "font" === t || "id" === t) return e;
            if ("imageSmoothing" === t) return "optimizeQuality" === e;
            n = r ? e.map(Re) : Re(e, i);
        }
    } else o = "";
    return !r && isNaN(n) ? o : n;
}
function wr(t, e) {
    const s = t.match(rs);
    if (!s) return;
    const i = s[1], r = s[3], n = s[4], o = s[5], a = s[6];
    i && (e.fontStyle = i), r && (e.fontWeight = isNaN(parseFloat(r)) ? r : parseFloat(r)), n && (e.fontSize = Re(n)), a && (e.fontFamily = a), o && (e.lineHeight = "normal" === o ? 1 : o);
}
function Tr(t, e) {
    t.replace(/;\s*$/, "").split(";").forEach((t)=>{
        if (!t) return;
        const [s, i] = t.split(":");
        e[s.trim().toLowerCase()] = i.trim();
    });
}
function Or(t) {
    const e = {}, s = t.getAttribute("style");
    return s ? ("string" == typeof s ? Tr(s, e) : function(t, e) {
        Object.entries(t).forEach((t)=>{
            let [s, i] = t;
            void 0 !== i && (e[s.toLowerCase()] = i);
        });
    }(s, e), e) : e;
}
const kr = {
    stroke: "strokeOpacity",
    fill: "fillOpacity"
};
function Dr(t, e, i) {
    if (!t) return {};
    let r, n = {}, o = O;
    t.parentNode && ls.test(t.parentNode.nodeName) && (n = Dr(t.parentElement, e, i), n.fontSize && (r = o = Re(n.fontSize)));
    const a = s(s(s({}, e.reduce((e, s)=>{
        const i = t.getAttribute(s);
        return i && (e[s] = i), e;
    }, {})), function(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = {};
        for(const r in e)Zi(t, r.split(" ")) && (i = s(s({}, i), e[r]));
        return i;
    }(t, i)), Or(t));
    a[as] && t.setAttribute(as, a[as]), a[os] && (r = Re(a[os], o), a[os] = "".concat(r));
    const h = {};
    for(const t in a){
        const e = $i(t), s = Sr(e, a[t], n, r);
        h[e] = s;
    }
    h && h.font && wr(h.font, h);
    const c = s(s({}, n), h);
    return ls.test(t.nodeName) ? c : function(t) {
        const e = ji.getDefaults();
        return Object.entries(kr).forEach((s)=>{
            let [i, r] = s;
            if (void 0 === t[r] || "" === t[i]) return;
            if (void 0 === t[i]) {
                if (!e[i]) return;
                t[i] = e[i];
            }
            if (0 === t[i].indexOf("url(")) return;
            const n = new Le(t[i]);
            t[i] = n.setAlpha(Vt(n.getAlpha() * t[r], 2)).toRgba();
        }), t;
    }(c);
}
const Mr = [
    "left",
    "top",
    "width",
    "height",
    "visible"
], Pr = [
    "rx",
    "ry"
];
class Er extends ji {
    static getDefaults() {
        return s(s({}, super.getDefaults()), Er.ownDefaults);
    }
    constructor(t){
        super(), Object.assign(this, Er.ownDefaults), this.setOptions(t), this._initRxRy();
    }
    _initRxRy() {
        const { rx: t, ry: e } = this;
        t && !e ? this.ry = t : e && !t && (this.rx = e);
    }
    _render(t) {
        const { width: e, height: s } = this, i = -e / 2, r = -s / 2, n = this.rx ? Math.min(this.rx, e / 2) : 0, o = this.ry ? Math.min(this.ry, s / 2) : 0, a = 0 !== n || 0 !== o;
        t.beginPath(), t.moveTo(i + n, r), t.lineTo(i + e - n, r), a && t.bezierCurveTo(i + e - k * n, r, i + e, r + k * o, i + e, r + o), t.lineTo(i + e, r + s - o), a && t.bezierCurveTo(i + e, r + s - k * o, i + e - k * n, r + s, i + e - n, r + s), t.lineTo(i + n, r + s), a && t.bezierCurveTo(i + k * n, r + s, i, r + s - k * o, i, r + s - o), t.lineTo(i, r + o), a && t.bezierCurveTo(i, r + k * o, i + k * n, r, i + n, r), t.closePath(), this._renderPaintInOrder(t);
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return super.toObject([
            ...Pr,
            ...t
        ]);
    }
    _toSVG() {
        const { width: t, height: e, rx: s, ry: i } = this;
        return [
            "<rect ",
            "COMMON_PARTS",
            'x="'.concat(-t / 2, '" y="').concat(-e / 2, '" rx="').concat(s, '" ry="').concat(i, '" width="').concat(t, '" height="').concat(e, '" />\n')
        ];
    }
    static async fromElement(t, e, r) {
        const n = Dr(t, this.ATTRIBUTE_NAMES, r), { left: o = 0, top: a = 0, width: h = 0, height: c = 0, visible: l = !0 } = n, u = i(n, Mr);
        return new this(s(s(s({}, e), u), {}, {
            left: o,
            top: a,
            width: h,
            height: c,
            visible: Boolean(l && h && c)
        }));
    }
}
t(Er, "type", "Rect"), t(Er, "cacheProperties", [
    ...Ms,
    ...Pr
]), t(Er, "ownDefaults", {
    rx: 0,
    ry: 0
}), t(Er, "ATTRIBUTE_NAMES", [
    ...Ji,
    "x",
    "y",
    "rx",
    "ry",
    "width",
    "height"
]), tt.setClass(Er), tt.setSVGClass(Er);
const Ar = "initialization", jr = "added", Fr = "removed", Lr = "imperative", Rr = (t, e)=>{
    const { strokeUniform: s, strokeWidth: i, width: r, height: n, group: o } = e, a = o && o !== t ? fe(o.calcTransformMatrix(), t.calcTransformMatrix()) : null, h = a ? e.getRelativeCenterPoint().transform(a) : e.getRelativeCenterPoint(), c = !e.isStrokeAccountedForInDimensions(), l = s && c ? me(new ot(i, i), void 0, t.calcTransformMatrix()) : at, u = !s && c ? i : 0, d = ge(r + u, n + u, Ot([
        a,
        e.calcOwnMatrix()
    ], !0)).add(l).scalarDivide(2);
    return [
        h.subtract(d),
        h.add(d)
    ];
};
class Ir {
    calcLayoutResult(t, e) {
        if (this.shouldPerformLayout(t)) return this.calcBoundingBox(e, t);
    }
    shouldPerformLayout(t) {
        let { type: e, prevStrategy: s, strategy: i } = t;
        return e === Ar || e === Lr || !!s && i !== s;
    }
    shouldLayoutClipPath(t) {
        let { type: e, target: { clipPath: s } } = t;
        return e !== Ar && s && !s.absolutePositioned;
    }
    getInitialSize(t, e) {
        return e.size;
    }
    calcBoundingBox(t, e) {
        const { type: s, target: i } = e;
        if (s === Lr && e.overrides) return e.overrides;
        if (0 === t.length) return;
        const { left: r, top: n, width: o, height: a } = ae(t.map((t)=>Rr(i, t)).reduce((t, e)=>t.concat(e), [])), h = new ot(o, a), c = new ot(r, n).add(h.scalarDivide(2));
        if (s === Ar) {
            const t = this.getInitialSize(e, {
                size: h,
                center: c
            });
            return {
                center: c,
                relativeCorrection: new ot(0, 0),
                size: t
            };
        }
        return {
            center: c.transform(i.calcOwnMatrix()),
            size: h
        };
    }
}
t(Ir, "type", "strategy");
class Br extends Ir {
    shouldPerformLayout(t) {
        return !0;
    }
}
t(Br, "type", "fit-content"), tt.setClass(Br);
const Xr = [
    "strategy"
], Yr = [
    "target",
    "strategy",
    "bubbles",
    "prevStrategy"
], Wr = "layoutManager";
class Vr {
    constructor(){
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Br;
        t(this, "strategy", void 0), this.strategy = e, this._subscriptions = new Map;
    }
    performLayout(t) {
        const e = s(s({
            bubbles: !0,
            strategy: this.strategy
        }, t), {}, {
            prevStrategy: this._prevLayoutStrategy,
            stopPropagation () {
                this.bubbles = !1;
            }
        });
        this.onBeforeLayout(e);
        const i = this.getLayoutResult(e);
        i && this.commitLayout(e, i), this.onAfterLayout(e, i), this._prevLayoutStrategy = e.strategy;
    }
    attachHandlers(t, e) {
        const { target: s } = e;
        return [
            Q,
            L,
            Y,
            I,
            R,
            X,
            z,
            W,
            V
        ].map((e)=>t.on(e, (t)=>this.performLayout(e === Q ? {
                    type: "object_modified",
                    trigger: e,
                    e: t,
                    target: s
                } : {
                    type: "object_modifying",
                    trigger: e,
                    e: t,
                    target: s
                })));
    }
    subscribe(t, e) {
        this.unsubscribe(t, e);
        const s = this.attachHandlers(t, e);
        this._subscriptions.set(t, s);
    }
    unsubscribe(t, e) {
        (this._subscriptions.get(t) || []).forEach((t)=>t()), this._subscriptions.delete(t);
    }
    unsubscribeTargets(t) {
        t.targets.forEach((e)=>this.unsubscribe(e, t));
    }
    subscribeTargets(t) {
        t.targets.forEach((e)=>this.subscribe(e, t));
    }
    onBeforeLayout(t) {
        const { target: e, type: r } = t, { canvas: n } = e;
        if (r === Ar || r === jr ? this.subscribeTargets(t) : r === Fr && this.unsubscribeTargets(t), e.fire("layout:before", {
            context: t
        }), n && n.fire("object:layout:before", {
            target: e,
            context: t
        }), r === Lr && t.deep) {
            const r = i(t, Xr);
            e.forEachObject((t)=>t.layoutManager && t.layoutManager.performLayout(s(s({}, r), {}, {
                    bubbles: !1,
                    target: t
                })));
        }
    }
    getLayoutResult(t) {
        const { target: e, strategy: s, type: i } = t, r = s.calcLayoutResult(t, e.getObjects());
        if (!r) return;
        const n = i === Ar ? new ot : e.getRelativeCenterPoint(), { center: o, correction: a = new ot, relativeCorrection: h = new ot } = r, c = n.subtract(o).add(a).transform(i === Ar ? T : wt(e.calcOwnMatrix()), !0).add(h);
        return {
            result: r,
            prevCenter: n,
            nextCenter: o,
            offset: c
        };
    }
    commitLayout(t, e) {
        const { target: s } = t, { result: { size: i }, nextCenter: r } = e;
        var n, o;
        (s.set({
            width: i.x,
            height: i.y
        }), this.layoutObjects(t, e), t.type === Ar) ? s.set({
            left: null !== (n = t.x) && void 0 !== n ? n : r.x + i.x * xe(s.originX),
            top: null !== (o = t.y) && void 0 !== o ? o : r.y + i.y * xe(s.originY)
        }) : (s.setPositionByOrigin(r, D, D), s.setCoords(), s.set("dirty", !0));
    }
    layoutObjects(t, e) {
        const { target: s } = t;
        s.forEachObject((i)=>{
            i.group === s && this.layoutObject(t, e, i);
        }), t.strategy.shouldLayoutClipPath(t) && this.layoutObject(t, e, s.clipPath);
    }
    layoutObject(t, e, s) {
        let { offset: i } = e;
        s.set({
            left: s.left + i.x,
            top: s.top + i.y
        });
    }
    onAfterLayout(t, e) {
        const { target: r, strategy: n, bubbles: o, prevStrategy: a } = t, h = i(t, Yr), { canvas: c } = r;
        r.fire("layout:after", {
            context: t,
            result: e
        }), c && c.fire("object:layout:after", {
            context: t,
            result: e,
            target: r
        });
        const l = r.parent;
        o && null != l && l.layoutManager && ((h.path || (h.path = [])).push(r), l.layoutManager.performLayout(s(s({}, h), {}, {
            target: l
        }))), r.set("dirty", !0);
    }
    dispose() {
        const { _subscriptions: t } = this;
        t.forEach((t)=>t.forEach((t)=>t())), t.clear();
    }
    toObject() {
        return {
            type: Wr,
            strategy: this.strategy.constructor.type
        };
    }
    toJSON() {
        return this.toObject();
    }
}
tt.setClass(Vr, Wr);
const zr = [
    "type",
    "objects",
    "layoutManager"
];
class Gr extends Vr {
    performLayout() {}
}
class Hr extends ct(ji) {
    static getDefaults() {
        return s(s({}, super.getDefaults()), Hr.ownDefaults);
    }
    constructor(){
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(), t(this, "_activeObjects", []), t(this, "__objectSelectionTracker", void 0), t(this, "__objectSelectionDisposer", void 0), Object.assign(this, Hr.ownDefaults), this.setOptions(s), this.groupInit(e, s);
    }
    groupInit(t, e) {
        var s;
        this._objects = [
            ...t
        ], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((t)=>{
            this.enterGroup(t, !1);
        }), this.layoutManager = null !== (s = e.layoutManager) && void 0 !== s ? s : new Vr, this.layoutManager.performLayout({
            type: Ar,
            target: this,
            targets: [
                ...t
            ],
            x: e.left,
            y: e.top
        });
    }
    canEnterGroup(t) {
        return t === this || this.isDescendantOf(t) ? (a("error", "Group: circular object trees are not supported, this call has no effect"), !1) : -1 === this._objects.indexOf(t) || (a("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
    }
    _filterObjectsBeforeEnteringGroup(t) {
        return t.filter((t, e, s)=>this.canEnterGroup(t) && s.indexOf(t) === e);
    }
    add() {
        for(var t = arguments.length, e = new Array(t), s = 0; s < t; s++)e[s] = arguments[s];
        const i = this._filterObjectsBeforeEnteringGroup(e), r = super.add(...i);
        return this._onAfterObjectsChange(jr, i), r;
    }
    insertAt(t) {
        for(var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)s[i - 1] = arguments[i];
        const r = this._filterObjectsBeforeEnteringGroup(s), n = super.insertAt(t, ...r);
        return this._onAfterObjectsChange(jr, r), n;
    }
    remove() {
        const t = super.remove(...arguments);
        return this._onAfterObjectsChange(Fr, t), t;
    }
    _onObjectAdded(t) {
        this.enterGroup(t, !0), this.fire("object:added", {
            target: t
        }), t.fire("added", {
            target: this
        });
    }
    _onObjectRemoved(t, e) {
        this.exitGroup(t, e), this.fire("object:removed", {
            target: t
        }), t.fire("removed", {
            target: this
        });
    }
    _onAfterObjectsChange(t, e) {
        this.layoutManager.performLayout({
            type: t,
            targets: e,
            target: this
        });
    }
    _onStackOrderChanged() {
        this._set("dirty", !0);
    }
    _set(t, e) {
        const s = this[t];
        return super._set(t, e), "canvas" === t && s !== e && (this._objects || []).forEach((s)=>{
            s._set(t, e);
        }), this;
    }
    _shouldSetNestedCoords() {
        return this.subTargetCheck;
    }
    removeAll() {
        return this._activeObjects = [], this.remove(...this._objects);
    }
    __objectSelectionMonitor(t, e) {
        let { target: s } = e;
        const i = this._activeObjects;
        if (t) i.push(s), this._set("dirty", !0);
        else if (i.length > 0) {
            const t = i.indexOf(s);
            t > -1 && (i.splice(t, 1), this._set("dirty", !0));
        }
    }
    _watchObject(t, e) {
        t && this._watchObject(!1, e), t ? (e.on("selected", this.__objectSelectionTracker), e.on("deselected", this.__objectSelectionDisposer)) : (e.off("selected", this.__objectSelectionTracker), e.off("deselected", this.__objectSelectionDisposer));
    }
    enterGroup(t, e) {
        t.group && t.group.remove(t), t._set("parent", this), this._enterGroup(t, e);
    }
    _enterGroup(t, e) {
        e && le(t, Tt(wt(this.calcTransformMatrix()), t.calcTransformMatrix())), this._shouldSetNestedCoords() && t.setCoords(), t._set("group", this), t._set("canvas", this.canvas), this._watchObject(!0, t);
        const s = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
        s && (s === t || t.isDescendantOf(s)) && this._activeObjects.push(t);
    }
    exitGroup(t, e) {
        this._exitGroup(t, e), t._set("parent", void 0), t._set("canvas", void 0);
    }
    _exitGroup(t, e) {
        t._set("group", void 0), e || (le(t, Tt(this.calcTransformMatrix(), t.calcTransformMatrix())), t.setCoords()), this._watchObject(!1, t);
        const s = this._activeObjects.length > 0 ? this._activeObjects.indexOf(t) : -1;
        s > -1 && this._activeObjects.splice(s, 1);
    }
    shouldCache() {
        const t = ji.prototype.shouldCache.call(this);
        if (t) {
            for(let t = 0; t < this._objects.length; t++)if (this._objects[t].willDrawShadow()) return this.ownCaching = !1, !1;
        }
        return t;
    }
    willDrawShadow() {
        if (super.willDrawShadow()) return !0;
        for(let t = 0; t < this._objects.length; t++)if (this._objects[t].willDrawShadow()) return !0;
        return !1;
    }
    isOnACache() {
        return this.ownCaching || !!this.parent && this.parent.isOnACache();
    }
    drawObject(t, e, s) {
        this._renderBackground(t);
        for(let e = 0; e < this._objects.length; e++){
            var i;
            const s = this._objects[e];
            null !== (i = this.canvas) && void 0 !== i && i.preserveObjectStacking && s.group !== this ? (t.save(), t.transform(...wt(this.calcTransformMatrix())), s.render(t), t.restore()) : s.group === this && s.render(t);
        }
        this._drawClipPath(t, this.clipPath, s);
    }
    setCoords() {
        super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((t)=>t.setCoords());
    }
    triggerLayout() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        this.layoutManager.performLayout(s({
            target: this,
            type: Lr
        }, t));
    }
    render(t) {
        this._transformDone = !0, super.render(t), this._transformDone = !1;
    }
    __serializeObjects(t, e) {
        const s = this.includeDefaultValues;
        return this._objects.filter(function(t) {
            return !t.excludeFromExport;
        }).map(function(i) {
            const r = i.includeDefaultValues;
            i.includeDefaultValues = s;
            const n = i[t || "toObject"](e);
            return i.includeDefaultValues = r, n;
        });
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        const e = this.layoutManager.toObject();
        return s(s(s({}, super.toObject([
            "subTargetCheck",
            "interactive",
            ...t
        ])), "fit-content" !== e.strategy || this.includeDefaultValues ? {
            layoutManager: e
        } : {}), {}, {
            objects: this.__serializeObjects("toObject", t)
        });
    }
    toString() {
        return "#<Group: (".concat(this.complexity(), ")>");
    }
    dispose() {
        this.layoutManager.unsubscribeTargets({
            targets: this.getObjects(),
            target: this
        }), this._activeObjects = [], this.forEachObject((t)=>{
            this._watchObject(!1, t), t.dispose();
        }), super.dispose();
    }
    _createSVGBgRect(t) {
        if (!this.backgroundColor) return "";
        const e = Er.prototype._toSVG.call(this), s = e.indexOf("COMMON_PARTS");
        e[s] = 'for="group" ';
        const i = e.join("");
        return t ? t(i) : i;
    }
    _toSVG(t) {
        const e = [
            "<g ",
            "COMMON_PARTS",
            " >\n"
        ], s = this._createSVGBgRect(t);
        s && e.push("\t\t", s);
        for(let s = 0; s < this._objects.length; s++)e.push("\t\t", this._objects[s].toSVG(t));
        return e.push("</g>\n"), e;
    }
    getSvgStyles() {
        const t = void 0 !== this.opacity && 1 !== this.opacity ? "opacity: ".concat(this.opacity, ";") : "", e = this.visible ? "" : " visibility: hidden;";
        return [
            t,
            this.getSvgFilter(),
            e
        ].join("");
    }
    toClipPathSVG(t) {
        const e = [], s = this._createSVGBgRect(t);
        s && e.push("\t", s);
        for(let s = 0; s < this._objects.length; s++)e.push("\t", this._objects[s].toClipPathSVG(t));
        return this._createBaseClipPathSVGMarkup(e, {
            reviver: t
        });
    }
    static fromObject(t, e) {
        let { type: r, objects: n = [], layoutManager: o } = t, a = i(t, zr);
        return Promise.all([
            Bt(n, e),
            Xt(a, e)
        ]).then((t)=>{
            let [e, i] = t;
            const r = new this(e, s(s(s({}, a), i), {}, {
                layoutManager: new Gr
            }));
            if (o) {
                const t = tt.getClass(o.type), e = tt.getClass(o.strategy);
                r.layoutManager = new t(new e);
            } else r.layoutManager = new Vr;
            return r.layoutManager.subscribeTargets({
                type: Ar,
                target: r,
                targets: r.getObjects()
            }), r.setCoords(), r;
        });
    }
}
t(Hr, "type", "Group"), t(Hr, "ownDefaults", {
    strokeWidth: 0,
    subTargetCheck: !1,
    interactive: !1
}), tt.setClass(Hr);
const Nr = (t, e)=>Math.min(e.width / t.width, e.height / t.height), Ur = (t, e)=>Math.max(e.width / t.width, e.height / t.height), qr = "\\s*,?\\s*", Kr = "".concat(qr, "(").concat(es, ")"), Jr = "".concat(Kr).concat(Kr).concat(Kr).concat(qr, "([01])").concat(qr, "([01])").concat(Kr).concat(Kr), Qr = {
    m: "l",
    M: "L"
}, Zr = (t, e, s, i, r, n, o, a, h, c, l)=>{
    const u = rt(t), d = nt(t), g = rt(e), f = nt(e), p = s * r * g - i * n * f + o, m = i * r * g + s * n * f + a;
    return [
        "C",
        c + h * (-s * r * d - i * n * u),
        l + h * (-i * r * d + s * n * u),
        p + h * (s * r * f + i * n * g),
        m + h * (i * r * f - s * n * g),
        p,
        m
    ];
}, $r = (t, e, s, i)=>{
    const r = Math.atan2(e, t), n = Math.atan2(i, s);
    return n >= r ? n - r : 2 * Math.PI - (r - n);
};
function tn(t, e, s, i, r, n, a, h) {
    let c;
    if (o.cachesBoundsOfCurve && (c = [
        ...arguments
    ].join(), _.boundsOfCurveCache[c])) return _.boundsOfCurveCache[c];
    const l = Math.sqrt, u = Math.abs, d = [], g = [
        [
            0,
            0
        ],
        [
            0,
            0
        ]
    ];
    let f = 6 * t - 12 * s + 6 * r, p = -3 * t + 9 * s - 9 * r + 3 * a, m = 3 * s - 3 * t;
    for(let t = 0; t < 2; ++t){
        if (t > 0 && (f = 6 * e - 12 * i + 6 * n, p = -3 * e + 9 * i - 9 * n + 3 * h, m = 3 * i - 3 * e), u(p) < 1e-12) {
            if (u(f) < 1e-12) continue;
            const t = -m / f;
            0 < t && t < 1 && d.push(t);
            continue;
        }
        const s = f * f - 4 * m * p;
        if (s < 0) continue;
        const r = l(s), o = (-f + r) / (2 * p);
        0 < o && o < 1 && d.push(o);
        const a = (-f - r) / (2 * p);
        0 < a && a < 1 && d.push(a);
    }
    let v = d.length;
    const y = v, x = nn(t, e, s, i, r, n, a, h);
    for(; v--;){
        const { x: t, y: e } = x(d[v]);
        g[0][v] = t, g[1][v] = e;
    }
    g[0][y] = t, g[1][y] = e, g[0][y + 1] = a, g[1][y + 1] = h;
    const C = [
        new ot(Math.min(...g[0]), Math.min(...g[1])),
        new ot(Math.max(...g[0]), Math.max(...g[1]))
    ];
    return o.cachesBoundsOfCurve && (_.boundsOfCurveCache[c] = C), C;
}
const en = (t, e, s)=>{
    let [i, r, n, o, a, h, c, l] = s;
    const u = ((t, e, s, i, r, n, o)=>{
        if (0 === s || 0 === i) return [];
        let a = 0, h = 0, c = 0;
        const l = Math.PI, u = o * w, d = nt(u), g = rt(u), f = .5 * (-g * t - d * e), p = .5 * (-g * e + d * t), m = s ** 2, v = i ** 2, y = p ** 2, _ = f ** 2, x = m * v - m * y - v * _;
        let C = Math.abs(s), b = Math.abs(i);
        if (x < 0) {
            const t = Math.sqrt(1 - x / (m * v));
            C *= t, b *= t;
        } else c = (r === n ? -1 : 1) * Math.sqrt(x / (m * y + v * _));
        const S = c * C * p / b, T = -c * b * f / C, O = g * S - d * T + .5 * t, k = d * S + g * T + .5 * e;
        let D = $r(1, 0, (f - S) / C, (p - T) / b), M = $r((f - S) / C, (p - T) / b, (-f - S) / C, (-p - T) / b);
        0 === n && M > 0 ? M -= 2 * l : 1 === n && M < 0 && (M += 2 * l);
        const P = Math.ceil(Math.abs(M / l * 2)), E = [], A = M / P, j = 8 / 3 * Math.sin(A / 4) * Math.sin(A / 4) / Math.sin(A / 2);
        let F = D + A;
        for(let t = 0; t < P; t++)E[t] = Zr(D, F, g, d, C, b, O, k, j, a, h), a = E[t][5], h = E[t][6], D = F, F += A;
        return E;
    })(c - t, l - e, r, n, a, h, o);
    for(let s = 0, i = u.length; s < i; s++)u[s][1] += t, u[s][2] += e, u[s][3] += t, u[s][4] += e, u[s][5] += t, u[s][6] += e;
    return u;
}, sn = (t)=>{
    let e = 0, s = 0, i = 0, r = 0;
    const n = [];
    let o, a = 0, h = 0;
    for (const c of t){
        const t = [
            ...c
        ];
        let l;
        switch(t[0]){
            case "l":
                t[1] += e, t[2] += s;
            case "L":
                e = t[1], s = t[2], l = [
                    "L",
                    e,
                    s
                ];
                break;
            case "h":
                t[1] += e;
            case "H":
                e = t[1], l = [
                    "L",
                    e,
                    s
                ];
                break;
            case "v":
                t[1] += s;
            case "V":
                s = t[1], l = [
                    "L",
                    e,
                    s
                ];
                break;
            case "m":
                t[1] += e, t[2] += s;
            case "M":
                e = t[1], s = t[2], i = t[1], r = t[2], l = [
                    "M",
                    e,
                    s
                ];
                break;
            case "c":
                t[1] += e, t[2] += s, t[3] += e, t[4] += s, t[5] += e, t[6] += s;
            case "C":
                a = t[3], h = t[4], e = t[5], s = t[6], l = [
                    "C",
                    t[1],
                    t[2],
                    a,
                    h,
                    e,
                    s
                ];
                break;
            case "s":
                t[1] += e, t[2] += s, t[3] += e, t[4] += s;
            case "S":
                "C" === o ? (a = 2 * e - a, h = 2 * s - h) : (a = e, h = s), e = t[3], s = t[4], l = [
                    "C",
                    a,
                    h,
                    t[1],
                    t[2],
                    e,
                    s
                ], a = l[3], h = l[4];
                break;
            case "q":
                t[1] += e, t[2] += s, t[3] += e, t[4] += s;
            case "Q":
                a = t[1], h = t[2], e = t[3], s = t[4], l = [
                    "Q",
                    a,
                    h,
                    e,
                    s
                ];
                break;
            case "t":
                t[1] += e, t[2] += s;
            case "T":
                "Q" === o ? (a = 2 * e - a, h = 2 * s - h) : (a = e, h = s), e = t[1], s = t[2], l = [
                    "Q",
                    a,
                    h,
                    e,
                    s
                ];
                break;
            case "a":
                t[6] += e, t[7] += s;
            case "A":
                en(e, s, t).forEach((t)=>n.push(t)), e = t[6], s = t[7];
                break;
            case "z":
            case "Z":
                e = i, s = r, l = [
                    "Z"
                ];
        }
        l ? (n.push(l), o = l[0]) : o = "";
    }
    return n;
}, rn = (t, e, s, i)=>Math.sqrt((s - t) ** 2 + (i - e) ** 2), nn = (t, e, s, i, r, n, o, a)=>(h)=>{
        const c = h ** 3, l = ((t)=>3 * t ** 2 * (1 - t))(h), u = ((t)=>3 * t * (1 - t) ** 2)(h), d = ((t)=>(1 - t) ** 3)(h);
        return new ot(o * c + r * l + s * u + t * d, a * c + n * l + i * u + e * d);
    }, on = (t)=>t ** 2, an = (t)=>2 * t * (1 - t), hn = (t)=>(1 - t) ** 2, cn = (t, e, s, i, r, n, o, a)=>(h)=>{
        const c = on(h), l = an(h), u = hn(h), d = 3 * (u * (s - t) + l * (r - s) + c * (o - r)), g = 3 * (u * (i - e) + l * (n - i) + c * (a - n));
        return Math.atan2(g, d);
    }, ln = (t, e, s, i, r, n)=>(o)=>{
        const a = on(o), h = an(o), c = hn(o);
        return new ot(r * a + s * h + t * c, n * a + i * h + e * c);
    }, un = (t, e, s, i, r, n)=>(o)=>{
        const a = 1 - o, h = 2 * (a * (s - t) + o * (r - s)), c = 2 * (a * (i - e) + o * (n - i));
        return Math.atan2(c, h);
    }, dn = (t, e, s)=>{
    let i = new ot(e, s), r = 0;
    for(let e = 1; e <= 100; e += 1){
        const s = t(e / 100);
        r += rn(i.x, i.y, s.x, s.y), i = s;
    }
    return r;
}, gn = (t, e)=>{
    let i, r = 0, n = 0, o = {
        x: t.x,
        y: t.y
    }, a = s({}, o), h = .01, c = 0;
    const l = t.iterator, u = t.angleFinder;
    for(; n < e && h > 1e-4;)a = l(r), c = r, i = rn(o.x, o.y, a.x, a.y), i + n > e ? (r -= h, h /= 2) : (o = a, r += h, n += i);
    return s(s({}, a), {}, {
        angle: u(c)
    });
}, fn = (t)=>{
    let e, s, i = 0, r = 0, n = 0, o = 0, a = 0;
    const h = [];
    for (const c of t){
        const t = {
            x: r,
            y: n,
            command: c[0],
            length: 0
        };
        switch(c[0]){
            case "M":
                s = t, s.x = o = r = c[1], s.y = a = n = c[2];
                break;
            case "L":
                s = t, s.length = rn(r, n, c[1], c[2]), r = c[1], n = c[2];
                break;
            case "C":
                e = nn(r, n, c[1], c[2], c[3], c[4], c[5], c[6]), s = t, s.iterator = e, s.angleFinder = cn(r, n, c[1], c[2], c[3], c[4], c[5], c[6]), s.length = dn(e, r, n), r = c[5], n = c[6];
                break;
            case "Q":
                e = ln(r, n, c[1], c[2], c[3], c[4]), s = t, s.iterator = e, s.angleFinder = un(r, n, c[1], c[2], c[3], c[4]), s.length = dn(e, r, n), r = c[3], n = c[4];
                break;
            case "Z":
                s = t, s.destX = o, s.destY = a, s.length = rn(r, n, o, a), r = o, n = a;
        }
        i += s.length, h.push(s);
    }
    return h.push({
        length: i,
        x: r,
        y: n
    }), h;
}, pn = function(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : fn(t), r = 0;
    for(; e - i[r].length > 0 && r < i.length - 2;)e -= i[r].length, r++;
    const n = i[r], o = e / n.length, a = t[r];
    switch(n.command){
        case "M":
            return {
                x: n.x,
                y: n.y,
                angle: 0
            };
        case "Z":
            return s(s({}, new ot(n.x, n.y).lerp(new ot(n.destX, n.destY), o)), {}, {
                angle: Math.atan2(n.destY - n.y, n.destX - n.x)
            });
        case "L":
            return s(s({}, new ot(n.x, n.y).lerp(new ot(a[1], a[2]), o)), {}, {
                angle: Math.atan2(a[2] - n.y, a[1] - n.x)
            });
        case "C":
        case "Q":
            return gn(n, e);
    }
}, mn = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), vn = new RegExp(Jr, "g"), yn = new RegExp(es, "gi"), _n = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7
}, xn = (t)=>{
    var e;
    const s = [], i = null !== (e = t.match(mn)) && void 0 !== e ? e : [];
    for (const t of i){
        const e = t[0];
        if ("z" === e || "Z" === e) {
            s.push([
                e
            ]);
            continue;
        }
        const i = _n[e.toLowerCase()];
        let r = [];
        if ("a" === e || "A" === e) {
            vn.lastIndex = 0;
            for(let e = null; e = vn.exec(t);)r.push(...e.slice(1));
        } else r = t.match(yn) || [];
        for(let t = 0; t < r.length; t += i){
            const n = new Array(i), o = Qr[e];
            n[0] = t > 0 && o ? o : e;
            for(let e = 0; e < i; e++)n[e + 1] = parseFloat(r[t + e]);
            s.push(n);
        }
    }
    return s;
}, Cn = function(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, s = new ot(t[0]), i = new ot(t[1]), r = 1, n = 0;
    const o = [], a = t.length, h = a > 2;
    let c;
    for(h && (r = t[2].x < i.x ? -1 : t[2].x === i.x ? 0 : 1, n = t[2].y < i.y ? -1 : t[2].y === i.y ? 0 : 1), o.push([
        "M",
        s.x - r * e,
        s.y - n * e
    ]), c = 1; c < a; c++){
        if (!s.eq(i)) {
            const t = s.midPointFrom(i);
            o.push([
                "Q",
                s.x,
                s.y,
                t.x,
                t.y
            ]);
        }
        s = t[c], c + 1 < t.length && (i = t[c + 1]);
    }
    return h && (r = s.x > t[c - 2].x ? 1 : s.x === t[c - 2].x ? 0 : -1, n = s.y > t[c - 2].y ? 1 : s.y === t[c - 2].y ? 0 : -1), o.push([
        "L",
        s.x + r * e,
        s.y + n * e
    ]), o;
}, bn = (t, e)=>t.map((t)=>t.map((t, s)=>0 === s || void 0 === e ? t : Vt(t, e)).join(" ")).join(" ");
function Sn(t, e) {
    const s = t.style;
    s && e && ("string" == typeof e ? s.cssText += ";" + e : Object.entries(e).forEach((t)=>{
        let [e, i] = t;
        return s.setProperty(e, i);
    }));
}
const wn = (t, e)=>Math.floor(Math.random() * (e - t + 1)) + t;
function Tn(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const s = e.onComplete || C, i = new (v()).XMLHttpRequest, r = e.signal, n = function() {
        i.abort();
    }, o = function() {
        r && r.removeEventListener("abort", n), i.onerror = i.ontimeout = C;
    };
    if (r && r.aborted) throw new c("request");
    return r && r.addEventListener("abort", n, {
        once: !0
    }), i.onreadystatechange = function() {
        4 === i.readyState && (o(), s(i), i.onreadystatechange = C);
    }, i.onerror = i.ontimeout = o, i.open("get", t, !0), i.send(), i;
}
const On = (t, e)=>{
    let s = t._findCenterFromElement();
    t.transformMatrix && (((t)=>{
        if (t.transformMatrix) {
            const { scaleX: e, scaleY: s, angle: i, skewX: r } = Dt(t.transformMatrix);
            t.flipX = !1, t.flipY = !1, t.set(H, e), t.set(N, s), t.angle = i, t.skewX = r, t.skewY = 0;
        }
    })(t), s = s.transform(t.transformMatrix)), delete t.transformMatrix, e && (t.scaleX *= e.scaleX, t.scaleY *= e.scaleY, t.cropX = e.cropX, t.cropY = e.cropY, s.x += e.offsetLeft, s.y += e.offsetTop, t.width = e.width, t.height = e.height), t.setPositionByOrigin(s, D, D);
};
var kn = Object.freeze({
    __proto__: null,
    addTransformToObject: ce,
    animate: Us,
    animateColor: qs,
    applyTransformToObject: le,
    calcAngleBetweenVectors: vs,
    calcDimensionsMatrix: Lt,
    calcPlaneChangeMatrix: fe,
    calcVectorRotation: ys,
    cancelAnimFrame: dt,
    capValue: ks,
    composeMatrix: Rt,
    copyCanvasElement: (t)=>{
        var e;
        const s = vt(t);
        return null === (e = s.getContext("2d")) || void 0 === e || e.drawImage(t, 0, 0), s;
    },
    cos: rt,
    createCanvasElement: pt,
    createImage: mt,
    createRotateMatrix: Pt,
    createScaleMatrix: Et,
    createSkewXMatrix: jt,
    createSkewYMatrix: Ft,
    createTranslateMatrix: Mt,
    createVector: ps,
    crossProduct: Cs,
    degreesToRadians: xt,
    dotProduct: bs,
    ease: Rs,
    enlivenObjectEnlivables: Xt,
    enlivenObjects: Bt,
    findScaleToCover: Ur,
    findScaleToFit: Nr,
    getBoundsOfCurve: tn,
    getOrthonormalVector: xs,
    getPathSegmentsInfo: fn,
    getPointOnPath: pn,
    getPointer: re,
    getRandomInt: wn,
    getRegularPolygonPath: (t, e)=>{
        const s = 2 * Math.PI / t;
        let i = -b;
        t % 2 == 0 && (i += s / 2);
        const r = new Array(t + 1);
        for(let n = 0; n < t; n++){
            const t = n * s + i, { x: o, y: a } = new ot(rt(t), nt(t)).scalarMultiply(e);
            r[n] = [
                0 === n ? "M" : "L",
                o,
                a
            ];
        }
        return r[t] = [
            "Z"
        ], r;
    },
    getSmoothPathFromPoints: Cn,
    getSvgAttributes: (t)=>{
        const e = [
            "instantiated_by_use",
            "style",
            "id",
            "class"
        ];
        switch(t){
            case "linearGradient":
                return e.concat([
                    "x1",
                    "y1",
                    "x2",
                    "y2",
                    "gradientUnits",
                    "gradientTransform"
                ]);
            case "radialGradient":
                return e.concat([
                    "gradientUnits",
                    "gradientTransform",
                    "cx",
                    "cy",
                    "r",
                    "fx",
                    "fy",
                    "fr"
                ]);
            case "stop":
                return e.concat([
                    "offset",
                    "stop-color",
                    "stop-opacity"
                ]);
        }
        return e;
    },
    getUnitVector: _s,
    groupSVGElements: (t, e)=>t && 1 === t.length ? t[0] : new Hr(t, e),
    hasStyleChanged: Ui,
    invertTransform: wt,
    isBetweenVectors: Ss,
    isIdentityMatrix: bt,
    isTouchEvent: ne,
    isTransparent: Fi,
    joinPath: bn,
    loadImage: It,
    magnitude: ms,
    makeBoundingBoxFromPoints: ae,
    makePathSimpler: sn,
    matrixToSVG: zt,
    mergeClipPaths: (t, e)=>{
        var s;
        let i = t, r = e;
        i.inverted && !r.inverted && (i = e, r = t), ve(r, null === (s = r.group) || void 0 === s ? void 0 : s.calcTransformMatrix(), i.calcTransformMatrix());
        const n = i.inverted && r.inverted;
        return n && (i.inverted = r.inverted = !1), new Hr([
            i
        ], {
            clipPath: r,
            inverted: n
        });
    },
    multiplyTransformMatrices: Tt,
    multiplyTransformMatrixArray: Ot,
    parsePath: xn,
    parsePreserveAspectRatioAttribute: Ie,
    parseUnit: Re,
    pick: Yt,
    projectStrokeOnPoints: Xi,
    qrDecompose: Dt,
    radiansToDegrees: Ct,
    removeFromArray: it,
    removeTransformFromObject: (t, e)=>{
        const s = wt(e), i = Tt(s, t.calcOwnMatrix());
        le(t, i);
    },
    removeTransformMatrixForSvgParsing: On,
    request: Tn,
    requestAnimFrame: ut,
    resetObjectTransform: ue,
    rotatePoint: (t, e, s)=>t.rotate(s, e),
    rotateVector: fs,
    saveObjectTransform: de,
    sendObjectToPlane: ve,
    sendPointToPlane: pe,
    sendVectorToPlane: me,
    setStyle: Sn,
    sin: nt,
    sizeAfterTransform: ge,
    string: Ni,
    stylesFromArray: Ki,
    stylesToArray: qi,
    toBlob: _t,
    toDataURL: yt,
    toFixed: Vt,
    transformPath: (t, e, s)=>(s && (e = Tt(e, [
            1,
            0,
            0,
            1,
            -s.x,
            -s.y
        ])), t.map((t)=>{
            const s = [
                ...t
            ];
            for(let i = 1; i < t.length - 1; i += 2){
                const { x: r, y: n } = St({
                    x: t[i],
                    y: t[i + 1]
                }, e);
                s[i] = r, s[i + 1] = n;
            }
            return s;
        })),
    transformPoint: St
});
class Dn extends te {
    constructor(e){
        let { allowTouchScrolling: s = !1, containerClass: i = "" } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(e), t(this, "upper", void 0), t(this, "container", void 0);
        const { el: r } = this.lower, n = this.createUpperCanvas();
        this.upper = {
            el: n,
            ctx: n.getContext("2d")
        }, this.applyCanvasStyle(r, {
            allowTouchScrolling: s
        }), this.applyCanvasStyle(n, {
            allowTouchScrolling: s,
            styles: {
                position: "absolute",
                left: "0",
                top: "0"
            }
        });
        const o = this.createContainerElement();
        o.classList.add(i), r.parentNode && r.parentNode.replaceChild(o, r), o.append(r, n), this.container = o;
    }
    createUpperCanvas() {
        const { el: t } = this.lower, e = pt();
        return e.className = t.className, e.classList.remove("lower-canvas"), e.classList.add("upper-canvas"), e.setAttribute("data-fabric", "top"), e.style.cssText = t.style.cssText, e.setAttribute("draggable", "true"), e;
    }
    createContainerElement() {
        const t = m().createElement("div");
        return t.setAttribute("data-fabric", "wrapper"), Sn(t, {
            position: "relative"
        }), $t(t), t;
    }
    applyCanvasStyle(t, e) {
        const { styles: i, allowTouchScrolling: r } = e;
        Sn(t, s(s({}, i), {}, {
            "touch-action": r ? "manipulation" : j
        })), $t(t);
    }
    setDimensions(t, e) {
        super.setDimensions(t, e);
        const { el: s, ctx: i } = this.upper;
        Qt(s, i, t, e);
    }
    setCSSDimensions(t) {
        super.setCSSDimensions(t), Zt(this.upper.el, t), Zt(this.container, t);
    }
    cleanupDOM(t) {
        const e = this.container, { el: s } = this.lower, { el: i } = this.upper;
        super.cleanupDOM(t), e.removeChild(i), e.removeChild(s), e.parentNode && e.parentNode.replaceChild(s, e);
    }
    dispose() {
        super.dispose(), p().dispose(this.upper.el), delete this.upper, delete this.container;
    }
}
class Mn extends se {
    constructor(){
        super(...arguments), t(this, "targets", []), t(this, "_hoveredTargets", []), t(this, "_objectsToRender", void 0), t(this, "_currentTransform", null), t(this, "_groupSelector", null), t(this, "contextTopDirty", !1);
    }
    static getDefaults() {
        return s(s({}, super.getDefaults()), Mn.ownDefaults);
    }
    get upperCanvasEl() {
        var t;
        return null === (t = this.elements.upper) || void 0 === t ? void 0 : t.el;
    }
    get contextTop() {
        var t;
        return null === (t = this.elements.upper) || void 0 === t ? void 0 : t.ctx;
    }
    get wrapperEl() {
        return this.elements.container;
    }
    initElements(t) {
        this.elements = new Dn(t, {
            allowTouchScrolling: this.allowTouchScrolling,
            containerClass: this.containerClass
        }), this._createCacheCanvas();
    }
    _onObjectAdded(t) {
        this._objectsToRender = void 0, super._onObjectAdded(t);
    }
    _onObjectRemoved(t) {
        this._objectsToRender = void 0, t === this._activeObject && (this.fire("before:selection:cleared", {
            deselected: [
                t
            ]
        }), this._discardActiveObject(), this.fire("selection:cleared", {
            deselected: [
                t
            ]
        }), t.fire("deselected", {
            target: t
        })), t === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(t);
    }
    _onStackOrderChanged() {
        this._objectsToRender = void 0, super._onStackOrderChanged();
    }
    _chooseObjectsToRender() {
        const t = this._activeObject;
        return !this.preserveObjectStacking && t ? this._objects.filter((e)=>!e.group && e !== t).concat(t) : this._objects;
    }
    renderAll() {
        this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
    }
    renderTopLayer(t) {
        t.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(t), this.contextTopDirty = !0), t.restore();
    }
    renderTop() {
        const t = this.contextTop;
        this.clearContext(t), this.renderTopLayer(t), this.fire("after:render", {
            ctx: t
        });
    }
    setTargetFindTolerance(t) {
        t = Math.round(t), this.targetFindTolerance = t;
        const e = this.getRetinaScaling(), s = Math.ceil((2 * t + 1) * e);
        this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = s, this.pixelFindContext.scale(e, e);
    }
    isTargetTransparent(t, e, s) {
        const i = this.targetFindTolerance, r = this.pixelFindContext;
        this.clearContext(r), r.save(), r.translate(-e + i, -s + i), r.transform(...this.viewportTransform);
        const n = t.selectionBackgroundColor;
        t.selectionBackgroundColor = "", t.render(r), t.selectionBackgroundColor = n, r.restore();
        const o = Math.round(i * this.getRetinaScaling());
        return Fi(r, o, o, o);
    }
    _isSelectionKeyPressed(t) {
        const e = this.selectionKey;
        return !!e && (Array.isArray(e) ? !!e.find((e)=>!!e && !0 === t[e]) : t[e]);
    }
    _shouldClearSelection(t, e) {
        const s = this.getActiveObjects(), i = this._activeObject;
        return !!(!e || e && i && s.length > 1 && -1 === s.indexOf(e) && i !== e && !this._isSelectionKeyPressed(t) || e && !e.evented || e && !e.selectable && i && i !== e);
    }
    _shouldCenterTransform(t, e, s) {
        if (!t) return;
        let i;
        return e === G || e === H || e === N || e === Y ? i = this.centeredScaling || t.centeredScaling : e === B && (i = this.centeredRotation || t.centeredRotation), i ? !s : s;
    }
    _getOriginFromCorner(t, e) {
        const s = {
            x: t.originX,
            y: t.originY
        };
        return e ? ([
            "ml",
            "tl",
            "bl"
        ].includes(e) ? s.x = A : [
            "mr",
            "tr",
            "br"
        ].includes(e) && (s.x = M), [
            "tl",
            "mt",
            "tr"
        ].includes(e) ? s.y = E : [
            "bl",
            "mb",
            "br"
        ].includes(e) && (s.y = P), s) : s;
    }
    _setupCurrentTransform(t, e, i) {
        var r;
        const n = e.group ? pe(this.getScenePoint(t), void 0, e.group.calcTransformMatrix()) : this.getScenePoint(t), { key: o = "", control: a } = e.getActiveControl() || {}, h = i && a ? null === (r = a.getActionHandler(t, e, a)) || void 0 === r ? void 0 : r.bind(a) : De, c = ((t, e, s, i)=>{
            if (!e || !t) return "drag";
            const r = i.controls[e];
            return r.getActionName(s, r, i);
        })(i, o, t, e), l = t[this.centeredKey], u = this._shouldCenterTransform(e, c, l) ? {
            x: D,
            y: D
        } : this._getOriginFromCorner(e, o), d = {
            target: e,
            action: c,
            actionHandler: h,
            actionPerformed: !1,
            corner: o,
            scaleX: e.scaleX,
            scaleY: e.scaleY,
            skewX: e.skewX,
            skewY: e.skewY,
            offsetX: n.x - e.left,
            offsetY: n.y - e.top,
            originX: u.x,
            originY: u.y,
            ex: n.x,
            ey: n.y,
            lastX: n.x,
            lastY: n.y,
            theta: xt(e.angle),
            width: e.width,
            height: e.height,
            shiftKey: t.shiftKey,
            altKey: l,
            original: s(s({}, de(e)), {}, {
                originX: u.x,
                originY: u.y
            })
        };
        this._currentTransform = d, this.fire("before:transform", {
            e: t,
            transform: d
        });
    }
    setCursor(t) {
        this.upperCanvasEl.style.cursor = t;
    }
    _drawSelection(t) {
        const { x: e, y: s, deltaX: i, deltaY: r } = this._groupSelector, n = new ot(e, s).transform(this.viewportTransform), o = new ot(e + i, s + r).transform(this.viewportTransform), a = this.selectionLineWidth / 2;
        let h = Math.min(n.x, o.x), c = Math.min(n.y, o.y), l = Math.max(n.x, o.x), u = Math.max(n.y, o.y);
        this.selectionColor && (t.fillStyle = this.selectionColor, t.fillRect(h, c, l - h, u - c)), this.selectionLineWidth && this.selectionBorderColor && (t.lineWidth = this.selectionLineWidth, t.strokeStyle = this.selectionBorderColor, h += a, c += a, l -= a, u -= a, ji.prototype._setLineDash.call(this, t, this.selectionDashArray), t.strokeRect(h, c, l - h, u - c));
    }
    findTarget(t) {
        if (this.skipTargetFind) return;
        const e = this.getViewportPoint(t), s = this._activeObject, i = this.getActiveObjects();
        if (this.targets = [], s && i.length >= 1) {
            if (s.findControl(e, ne(t))) return s;
            if (i.length > 1 && this.searchPossibleTargets([
                s
            ], e)) return s;
            if (s === this.searchPossibleTargets([
                s
            ], e)) {
                if (this.preserveObjectStacking) {
                    const i = this.targets;
                    this.targets = [];
                    const r = this.searchPossibleTargets(this._objects, e);
                    return t[this.altSelectionKey] && r && r !== s ? (this.targets = i, s) : r;
                }
                return s;
            }
        }
        return this.searchPossibleTargets(this._objects, e);
    }
    _pointIsInObjectSelectionArea(t, e) {
        let s = t.getCoords();
        const i = this.getZoom(), r = t.padding / i;
        if (r) {
            const [t, e, i, n] = s, o = Math.atan2(e.y - t.y, e.x - t.x), a = rt(o) * r, h = nt(o) * r, c = a + h, l = a - h;
            s = [
                new ot(t.x - l, t.y - c),
                new ot(e.x + c, e.y - l),
                new ot(i.x + l, i.y + c),
                new ot(n.x - c, n.y + l)
            ];
        }
        return Ks.isPointInPolygon(e, s);
    }
    _checkTarget(t, e) {
        if (t && t.visible && t.evented && this._pointIsInObjectSelectionArea(t, pe(e, void 0, this.viewportTransform))) {
            if (!this.perPixelTargetFind && !t.perPixelTargetFind || t.isEditing) return !0;
            if (!this.isTargetTransparent(t, e.x, e.y)) return !0;
        }
        return !1;
    }
    _searchPossibleTargets(t, e) {
        let s = t.length;
        for(; s--;){
            const i = t[s];
            if (this._checkTarget(i, e)) {
                if (ht(i) && i.subTargetCheck) {
                    const t = this._searchPossibleTargets(i._objects, e);
                    t && this.targets.push(t);
                }
                return i;
            }
        }
    }
    searchPossibleTargets(t, e) {
        const s = this._searchPossibleTargets(t, e);
        if (s && ht(s) && s.interactive && this.targets[0]) {
            const t = this.targets;
            for(let e = t.length - 1; e > 0; e--){
                const s = t[e];
                if (!ht(s) || !s.interactive) return s;
            }
            return t[0];
        }
        return s;
    }
    getViewportPoint(t) {
        return this._pointer ? this._pointer : this.getPointer(t, !0);
    }
    getScenePoint(t) {
        return this._absolutePointer ? this._absolutePointer : this.getPointer(t);
    }
    getPointer(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const s = this.upperCanvasEl, i = s.getBoundingClientRect();
        let r = re(t), n = i.width || 0, o = i.height || 0;
        n && o || (P in i && E in i && (o = Math.abs(i.top - i.bottom)), A in i && M in i && (n = Math.abs(i.right - i.left))), this.calcOffset(), r.x = r.x - this._offset.left, r.y = r.y - this._offset.top, e || (r = pe(r, void 0, this.viewportTransform));
        const a = this.getRetinaScaling();
        1 !== a && (r.x /= a, r.y /= a);
        const h = 0 === n || 0 === o ? new ot(1, 1) : new ot(s.width / n, s.height / o);
        return r.multiply(h);
    }
    _setDimensionsImpl(t, e) {
        this._resetTransformEventData(), super._setDimensionsImpl(t, e), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
    }
    _createCacheCanvas() {
        this.pixelFindCanvasEl = pt(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", {
            willReadFrequently: !0
        }), this.setTargetFindTolerance(this.targetFindTolerance);
    }
    getTopContext() {
        return this.elements.upper.ctx;
    }
    getSelectionContext() {
        return this.elements.upper.ctx;
    }
    getSelectionElement() {
        return this.elements.upper.el;
    }
    getActiveObject() {
        return this._activeObject;
    }
    getActiveObjects() {
        const t = this._activeObject;
        return Ut(t) ? t.getObjects() : t ? [
            t
        ] : [];
    }
    _fireSelectionEvents(t, e) {
        let s = !1, i = !1;
        const r = this.getActiveObjects(), n = [], o = [];
        t.forEach((t)=>{
            r.includes(t) || (s = !0, t.fire("deselected", {
                e: e,
                target: t
            }), o.push(t));
        }), r.forEach((i)=>{
            t.includes(i) || (s = !0, i.fire("selected", {
                e: e,
                target: i
            }), n.push(i));
        }), t.length > 0 && r.length > 0 ? (i = !0, s && this.fire("selection:updated", {
            e: e,
            selected: n,
            deselected: o
        })) : r.length > 0 ? (i = !0, this.fire("selection:created", {
            e: e,
            selected: n
        })) : t.length > 0 && (i = !0, this.fire("selection:cleared", {
            e: e,
            deselected: o
        })), i && (this._objectsToRender = void 0);
    }
    setActiveObject(t, e) {
        const s = this.getActiveObjects(), i = this._setActiveObject(t, e);
        return this._fireSelectionEvents(s, e), i;
    }
    _setActiveObject(t, e) {
        const s = this._activeObject;
        return s !== t && !(!this._discardActiveObject(e, t) && this._activeObject) && !t.onSelect({
            e: e
        }) && (this._activeObject = t, Ut(t) && s !== t && t.set("canvas", this), t.setCoords(), !0);
    }
    _discardActiveObject(t, e) {
        const s = this._activeObject;
        return !!s && !s.onDeselect({
            e: t,
            object: e
        }) && (this._currentTransform && this._currentTransform.target === s && this.endCurrentTransform(t), Ut(s) && s === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
    }
    discardActiveObject(t) {
        const e = this.getActiveObjects(), s = this.getActiveObject();
        e.length && this.fire("before:selection:cleared", {
            e: t,
            deselected: [
                s
            ]
        });
        const i = this._discardActiveObject(t);
        return this._fireSelectionEvents(e, t), i;
    }
    endCurrentTransform(t) {
        const e = this._currentTransform;
        this._finalizeCurrentTransform(t), e && e.target && (e.target.isMoving = !1), this._currentTransform = null;
    }
    _finalizeCurrentTransform(t) {
        const e = this._currentTransform, s = e.target, i = {
            e: t,
            target: s,
            transform: e,
            action: e.action
        };
        s._scaling && (s._scaling = !1), s.setCoords(), e.actionPerformed && (this.fire("object:modified", i), s.fire(Q, i));
    }
    setViewportTransform(t) {
        super.setViewportTransform(t);
        const e = this._activeObject;
        e && e.setCoords();
    }
    destroy() {
        const t = this._activeObject;
        Ut(t) && (t.removeAll(), t.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
    }
    clear() {
        this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
    }
    drawControls(t) {
        const e = this._activeObject;
        e && e._renderControls(t);
    }
    _toObject(t, e, s) {
        const i = this._realizeGroupTransformOnObject(t), r = super._toObject(t, e, s);
        return t.set(i), r;
    }
    _realizeGroupTransformOnObject(t) {
        const { group: e } = t;
        if (e && Ut(e) && this._activeObject === e) {
            const s = Yt(t, [
                "angle",
                "flipX",
                "flipY",
                M,
                H,
                N,
                U,
                q,
                P
            ]);
            return ce(t, e.calcOwnMatrix()), s;
        }
        return {};
    }
    _setSVGObject(t, e, s) {
        const i = this._realizeGroupTransformOnObject(e);
        super._setSVGObject(t, e, s), e.set(i);
    }
}
t(Mn, "ownDefaults", {
    uniformScaling: !0,
    uniScaleKey: "shiftKey",
    centeredScaling: !1,
    centeredRotation: !1,
    centeredKey: "altKey",
    altActionKey: "shiftKey",
    selection: !0,
    selectionKey: "shiftKey",
    selectionColor: "rgba(100, 100, 255, 0.3)",
    selectionDashArray: [],
    selectionBorderColor: "rgba(255, 255, 255, 0.3)",
    selectionLineWidth: 1,
    selectionFullyContained: !1,
    hoverCursor: "move",
    moveCursor: "move",
    defaultCursor: "default",
    freeDrawingCursor: "crosshair",
    notAllowedCursor: "not-allowed",
    perPixelTargetFind: !1,
    targetFindTolerance: 0,
    skipTargetFind: !1,
    stopContextMenu: !1,
    fireRightClick: !1,
    fireMiddleClick: !1,
    enablePointerEvents: !1,
    containerClass: "canvas-container",
    preserveObjectStacking: !1
});
class Pn {
    constructor(e){
        t(this, "targets", []), t(this, "__disposer", void 0);
        const s = ()=>{
            const { hiddenTextarea: t } = e.getActiveObject() || {};
            t && t.focus();
        }, i = e.upperCanvasEl;
        i.addEventListener("click", s), this.__disposer = ()=>i.removeEventListener("click", s);
    }
    exitTextEditing() {
        this.target = void 0, this.targets.forEach((t)=>{
            t.isEditing && t.exitEditing();
        });
    }
    add(t) {
        this.targets.push(t);
    }
    remove(t) {
        this.unregister(t), it(this.targets, t);
    }
    register(t) {
        this.target = t;
    }
    unregister(t) {
        t === this.target && (this.target = void 0);
    }
    onMouseMove(t) {
        var e;
        (null === (e = this.target) || void 0 === e ? void 0 : e.isEditing) && this.target.updateSelectionOnMouseMove(t);
    }
    clear() {
        this.targets = [], this.target = void 0;
    }
    dispose() {
        this.clear(), this.__disposer(), delete this.__disposer;
    }
}
const En = [
    "target",
    "oldTarget",
    "fireCanvas",
    "e"
], An = {
    passive: !1
}, jn = (t, e)=>{
    const s = t.getViewportPoint(e), i = t.getScenePoint(e);
    return {
        viewportPoint: s,
        scenePoint: i,
        pointer: s,
        absolutePointer: i
    };
}, Fn = function(t) {
    for(var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)s[i - 1] = arguments[i];
    return t.addEventListener(...s);
}, Ln = function(t) {
    for(var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)s[i - 1] = arguments[i];
    return t.removeEventListener(...s);
}, Rn = {
    mouse: {
        in: "over",
        out: "out",
        targetIn: "mouseover",
        targetOut: "mouseout",
        canvasIn: "mouse:over",
        canvasOut: "mouse:out"
    },
    drag: {
        in: "enter",
        out: "leave",
        targetIn: "dragenter",
        targetOut: "dragleave",
        canvasIn: "drag:enter",
        canvasOut: "drag:leave"
    }
};
class In extends Mn {
    constructor(e){
        super(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}), t(this, "_isClick", void 0), t(this, "textEditingManager", new Pn(this)), [
            "_onMouseDown",
            "_onTouchStart",
            "_onMouseMove",
            "_onMouseUp",
            "_onTouchEnd",
            "_onResize",
            "_onMouseWheel",
            "_onMouseOut",
            "_onMouseEnter",
            "_onContextMenu",
            "_onClick",
            "_onDragStart",
            "_onDragEnd",
            "_onDragProgress",
            "_onDragOver",
            "_onDragEnter",
            "_onDragLeave",
            "_onDrop"
        ].forEach((t)=>{
            this[t] = this[t].bind(this);
        }), this.addOrRemove(Fn, "add");
    }
    _getEventPrefix() {
        return this.enablePointerEvents ? "pointer" : "mouse";
    }
    addOrRemove(t, e) {
        const s = this.upperCanvasEl, i = this._getEventPrefix();
        t(Jt(s), "resize", this._onResize), t(s, i + "down", this._onMouseDown), t(s, "".concat(i, "move"), this._onMouseMove, An), t(s, "".concat(i, "out"), this._onMouseOut), t(s, "".concat(i, "enter"), this._onMouseEnter), t(s, "wheel", this._onMouseWheel), t(s, "contextmenu", this._onContextMenu), t(s, "click", this._onClick), t(s, "dblclick", this._onClick), t(s, "dragstart", this._onDragStart), t(s, "dragend", this._onDragEnd), t(s, "dragover", this._onDragOver), t(s, "dragenter", this._onDragEnter), t(s, "dragleave", this._onDragLeave), t(s, "drop", this._onDrop), this.enablePointerEvents || t(s, "touchstart", this._onTouchStart, An);
    }
    removeListeners() {
        this.addOrRemove(Ln, "remove");
        const t = this._getEventPrefix(), e = Kt(this.upperCanvasEl);
        Ln(e, "".concat(t, "up"), this._onMouseUp), Ln(e, "touchend", this._onTouchEnd, An), Ln(e, "".concat(t, "move"), this._onMouseMove, An), Ln(e, "touchmove", this._onMouseMove, An), clearTimeout(this._willAddMouseDown);
    }
    _onMouseWheel(t) {
        this.__onMouseWheel(t);
    }
    _onMouseOut(t) {
        const e = this._hoveredTarget, i = s({
            e: t
        }, jn(this, t));
        this.fire("mouse:out", s(s({}, i), {}, {
            target: e
        })), this._hoveredTarget = void 0, e && e.fire("mouseout", s({}, i)), this._hoveredTargets.forEach((t)=>{
            this.fire("mouse:out", s(s({}, i), {}, {
                target: t
            })), t && t.fire("mouseout", s({}, i));
        }), this._hoveredTargets = [];
    }
    _onMouseEnter(t) {
        this._currentTransform || this.findTarget(t) || (this.fire("mouse:over", s({
            e: t
        }, jn(this, t))), this._hoveredTarget = void 0, this._hoveredTargets = []);
    }
    _onDragStart(t) {
        this._isClick = !1;
        const e = this.getActiveObject();
        if (e && e.onDragStart(t)) {
            this._dragSource = e;
            const s = {
                e: t,
                target: e
            };
            return this.fire("dragstart", s), e.fire("dragstart", s), void Fn(this.upperCanvasEl, "drag", this._onDragProgress);
        }
        oe(t);
    }
    _renderDragEffects(t, e, s) {
        let i = !1;
        const r = this._dropTarget;
        r && r !== e && r !== s && (r.clearContextTop(), i = !0), null == e || e.clearContextTop(), s !== e && (null == s || s.clearContextTop());
        const n = this.contextTop;
        n.save(), n.transform(...this.viewportTransform), e && (n.save(), e.transform(n), e.renderDragSourceEffect(t), n.restore(), i = !0), s && (n.save(), s.transform(n), s.renderDropTargetEffect(t), n.restore(), i = !0), n.restore(), i && (this.contextTopDirty = !0);
    }
    _onDragEnd(t) {
        const e = !!t.dataTransfer && t.dataTransfer.dropEffect !== j, s = e ? this._activeObject : void 0, i = {
            e: t,
            target: this._dragSource,
            subTargets: this.targets,
            dragSource: this._dragSource,
            didDrop: e,
            dropTarget: s
        };
        Ln(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", i), this._dragSource && this._dragSource.fire("dragend", i), delete this._dragSource, this._onMouseUp(t);
    }
    _onDragProgress(t) {
        const e = {
            e: t,
            target: this._dragSource,
            dragSource: this._dragSource,
            dropTarget: this._draggedoverTarget
        };
        this.fire("drag", e), this._dragSource && this._dragSource.fire("drag", e);
    }
    findDragTargets(t) {
        this.targets = [];
        return {
            target: this._searchPossibleTargets(this._objects, this.getViewportPoint(t)),
            targets: [
                ...this.targets
            ]
        };
    }
    _onDragOver(t) {
        const e = "dragover", { target: s, targets: i } = this.findDragTargets(t), r = this._dragSource, n = {
            e: t,
            target: s,
            subTargets: i,
            dragSource: r,
            canDrop: !1,
            dropTarget: void 0
        };
        let o;
        this.fire(e, n), this._fireEnterLeaveEvents(s, n), s && (s.canDrop(t) && (o = s), s.fire(e, n));
        for(let s = 0; s < i.length; s++){
            const r = i[s];
            r.canDrop(t) && (o = r), r.fire(e, n);
        }
        this._renderDragEffects(t, r, o), this._dropTarget = o;
    }
    _onDragEnter(t) {
        const { target: e, targets: s } = this.findDragTargets(t), i = {
            e: t,
            target: e,
            subTargets: s,
            dragSource: this._dragSource
        };
        this.fire("dragenter", i), this._fireEnterLeaveEvents(e, i);
    }
    _onDragLeave(t) {
        const e = {
            e: t,
            target: this._draggedoverTarget,
            subTargets: this.targets,
            dragSource: this._dragSource
        };
        this.fire("dragleave", e), this._fireEnterLeaveEvents(void 0, e), this._renderDragEffects(t, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
    }
    _onDrop(t) {
        const { target: e, targets: i } = this.findDragTargets(t), r = this._basicEventHandler("drop:before", s({
            e: t,
            target: e,
            subTargets: i,
            dragSource: this._dragSource
        }, jn(this, t)));
        r.didDrop = !1, r.dropTarget = void 0, this._basicEventHandler("drop", r), this.fire("drop:after", r);
    }
    _onContextMenu(t) {
        const e = this.findTarget(t), s = this.targets || [], i = this._basicEventHandler("contextmenu:before", {
            e: t,
            target: e,
            subTargets: s
        });
        return this.stopContextMenu && oe(t), this._basicEventHandler("contextmenu", i), !1;
    }
    _onClick(t) {
        const e = t.detail;
        e > 3 || e < 2 || (this._cacheTransformEventData(t), 2 == e && "dblclick" === t.type && this._handleEvent(t, "dblclick"), 3 == e && this._handleEvent(t, "tripleclick"), this._resetTransformEventData());
    }
    getPointerId(t) {
        const e = t.changedTouches;
        return e ? e[0] && e[0].identifier : this.enablePointerEvents ? t.pointerId : -1;
    }
    _isMainEvent(t) {
        return !0 === t.isPrimary || !1 !== t.isPrimary && ("touchend" === t.type && 0 === t.touches.length || !t.changedTouches || t.changedTouches[0].identifier === this.mainTouchId);
    }
    _onTouchStart(t) {
        let e = !this.allowTouchScrolling;
        const s = this._activeObject;
        void 0 === this.mainTouchId && (this.mainTouchId = this.getPointerId(t)), this.__onMouseDown(t), (this.isDrawingMode || s && this._target === s) && (e = !0), e && t.preventDefault(), this._resetTransformEventData();
        const i = this.upperCanvasEl, r = this._getEventPrefix(), n = Kt(i);
        Fn(n, "touchend", this._onTouchEnd, An), e && Fn(n, "touchmove", this._onMouseMove, An), Ln(i, "".concat(r, "down"), this._onMouseDown);
    }
    _onMouseDown(t) {
        this.__onMouseDown(t), this._resetTransformEventData();
        const e = this.upperCanvasEl, s = this._getEventPrefix();
        Ln(e, "".concat(s, "move"), this._onMouseMove, An);
        const i = Kt(e);
        Fn(i, "".concat(s, "up"), this._onMouseUp), Fn(i, "".concat(s, "move"), this._onMouseMove, An);
    }
    _onTouchEnd(t) {
        if (t.touches.length > 0) return;
        this.__onMouseUp(t), this._resetTransformEventData(), delete this.mainTouchId;
        const e = this._getEventPrefix(), s = Kt(this.upperCanvasEl);
        Ln(s, "touchend", this._onTouchEnd, An), Ln(s, "touchmove", this._onMouseMove, An), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(()=>{
            Fn(this.upperCanvasEl, "".concat(e, "down"), this._onMouseDown), this._willAddMouseDown = 0;
        }, 400);
    }
    _onMouseUp(t) {
        this.__onMouseUp(t), this._resetTransformEventData();
        const e = this.upperCanvasEl, s = this._getEventPrefix();
        if (this._isMainEvent(t)) {
            const t = Kt(this.upperCanvasEl);
            Ln(t, "".concat(s, "up"), this._onMouseUp), Ln(t, "".concat(s, "move"), this._onMouseMove, An), Fn(e, "".concat(s, "move"), this._onMouseMove, An);
        }
    }
    _onMouseMove(t) {
        const e = this.getActiveObject();
        !this.allowTouchScrolling && (!e || !e.shouldStartDragging(t)) && t.preventDefault && t.preventDefault(), this.__onMouseMove(t);
    }
    _onResize() {
        this.calcOffset(), this._resetTransformEventData();
    }
    _shouldRender(t) {
        const e = this.getActiveObject();
        return !!e != !!t || e && t && e !== t;
    }
    __onMouseUp(t) {
        var e;
        this._cacheTransformEventData(t), this._handleEvent(t, "up:before");
        const s = this._currentTransform, i = this._isClick, r = this._target, { button: n } = t;
        if (n) return (this.fireMiddleClick && 1 === n || this.fireRightClick && 2 === n) && this._handleEvent(t, "up"), void this._resetTransformEventData();
        if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(t);
        if (!this._isMainEvent(t)) return;
        let o, a, h = !1;
        if (s && (this._finalizeCurrentTransform(t), h = s.actionPerformed), !i) {
            const e = r === this._activeObject;
            this.handleSelection(t), h || (h = this._shouldRender(r) || !e && r === this._activeObject);
        }
        if (r) {
            const e = r.findControl(this.getViewportPoint(t), ne(t)), { key: i, control: n } = e || {};
            if (a = i, r.selectable && r !== this._activeObject && "up" === r.activeOn) this.setActiveObject(r, t), h = !0;
            else if (n) {
                const e = n.getMouseUpHandler(t, r, n);
                e && (o = this.getScenePoint(t), e.call(n, t, s, o.x, o.y));
            }
            r.isMoving = !1;
        }
        if (s && (s.target !== r || s.corner !== a)) {
            const e = s.target && s.target.controls[s.corner], i = e && e.getMouseUpHandler(t, s.target, e);
            o = o || this.getScenePoint(t), i && i.call(e, t, s, o.x, o.y);
        }
        this._setCursorFromEvent(t, r), this._handleEvent(t, "up"), this._groupSelector = null, this._currentTransform = null, r && (r.__corner = void 0), h ? this.requestRenderAll() : i || null !== (e = this._activeObject) && void 0 !== e && e.isEditing || this.renderTop();
    }
    _basicEventHandler(t, e) {
        const { target: s, subTargets: i = [] } = e;
        this.fire(t, e), s && s.fire(t, e);
        for(let r = 0; r < i.length; r++)i[r] !== s && i[r].fire(t, e);
        return e;
    }
    _handleEvent(t, e, i) {
        const r = this._target, n = this.targets || [], o = s(s(s({
            e: t,
            target: r,
            subTargets: n
        }, jn(this, t)), {}, {
            transform: this._currentTransform
        }, "up:before" === e || "up" === e ? {
            isClick: this._isClick,
            currentTarget: this.findTarget(t),
            currentSubTargets: this.targets
        } : {}), "down:before" === e || "down" === e ? i : {});
        this.fire("mouse:".concat(e), o), r && r.fire("mouse".concat(e), o);
        for(let t = 0; t < n.length; t++)n[t] !== r && n[t].fire("mouse".concat(e), o);
    }
    _onMouseDownInDrawingMode(t) {
        this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(t), this.requestRenderAll());
        const e = this.getScenePoint(t);
        this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(e, {
            e: t,
            pointer: e
        }), this._handleEvent(t, "down", {
            alreadySelected: !1
        });
    }
    _onMouseMoveInDrawingMode(t) {
        if (this._isCurrentlyDrawing) {
            const e = this.getScenePoint(t);
            this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(e, {
                e: t,
                pointer: e
            });
        }
        this.setCursor(this.freeDrawingCursor), this._handleEvent(t, "move");
    }
    _onMouseUpInDrawingMode(t) {
        const e = this.getScenePoint(t);
        this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({
            e: t,
            pointer: e
        }) : this._isCurrentlyDrawing = !1, this._handleEvent(t, "up");
    }
    __onMouseDown(t) {
        this._isClick = !0, this._cacheTransformEventData(t), this._handleEvent(t, "down:before");
        let e = this._target, s = !!e && e === this._activeObject;
        const { button: i } = t;
        if (i) return (this.fireMiddleClick && 1 === i || this.fireRightClick && 2 === i) && this._handleEvent(t, "down", {
            alreadySelected: s
        }), void this._resetTransformEventData();
        if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(t);
        if (!this._isMainEvent(t)) return;
        if (this._currentTransform) return;
        let r = this._shouldRender(e), n = !1;
        if (this.handleMultiSelection(t, e) ? (e = this._activeObject, n = !0, r = !0) : this._shouldClearSelection(t, e) && this.discardActiveObject(t), this.selection && (!e || !e.selectable && !e.isEditing && e !== this._activeObject)) {
            const e = this.getScenePoint(t);
            this._groupSelector = {
                x: e.x,
                y: e.y,
                deltaY: 0,
                deltaX: 0
            };
        }
        if (s = !!e && e === this._activeObject, e) {
            e.selectable && "down" === e.activeOn && this.setActiveObject(e, t);
            const i = e.findControl(this.getViewportPoint(t), ne(t));
            if (e === this._activeObject && (i || !n)) {
                this._setupCurrentTransform(t, e, s);
                const r = i ? i.control : void 0, n = this.getScenePoint(t), o = r && r.getMouseDownHandler(t, e, r);
                o && o.call(r, t, this._currentTransform, n.x, n.y);
            }
        }
        r && (this._objectsToRender = void 0), this._handleEvent(t, "down", {
            alreadySelected: s
        }), r && this.requestRenderAll();
    }
    _resetTransformEventData() {
        this._target = this._pointer = this._absolutePointer = void 0;
    }
    _cacheTransformEventData(t) {
        this._resetTransformEventData(), this._pointer = this.getViewportPoint(t), this._absolutePointer = pe(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t);
    }
    __onMouseMove(t) {
        if (this._isClick = !1, this._cacheTransformEventData(t), this._handleEvent(t, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(t);
        if (!this._isMainEvent(t)) return;
        const e = this._groupSelector;
        if (e) {
            const s = this.getScenePoint(t);
            e.deltaX = s.x - e.x, e.deltaY = s.y - e.y, this.renderTop();
        } else if (this._currentTransform) this._transformObject(t);
        else {
            const e = this.findTarget(t);
            this._setCursorFromEvent(t, e), this._fireOverOutEvents(t, e);
        }
        this.textEditingManager.onMouseMove(t), this._handleEvent(t, "move"), this._resetTransformEventData();
    }
    _fireOverOutEvents(t, e) {
        const s = this._hoveredTarget, i = this._hoveredTargets, r = this.targets, n = Math.max(i.length, r.length);
        this.fireSyntheticInOutEvents("mouse", {
            e: t,
            target: e,
            oldTarget: s,
            fireCanvas: !0
        });
        for(let e = 0; e < n; e++)this.fireSyntheticInOutEvents("mouse", {
            e: t,
            target: r[e],
            oldTarget: i[e]
        });
        this._hoveredTarget = e, this._hoveredTargets = this.targets.concat();
    }
    _fireEnterLeaveEvents(t, e) {
        const i = this._draggedoverTarget, r = this._hoveredTargets, n = this.targets, o = Math.max(r.length, n.length);
        this.fireSyntheticInOutEvents("drag", s(s({}, e), {}, {
            target: t,
            oldTarget: i,
            fireCanvas: !0
        }));
        for(let t = 0; t < o; t++)this.fireSyntheticInOutEvents("drag", s(s({}, e), {}, {
            target: n[t],
            oldTarget: r[t]
        }));
        this._draggedoverTarget = t;
    }
    fireSyntheticInOutEvents(t, e) {
        let { target: r, oldTarget: n, fireCanvas: o, e: a } = e, h = i(e, En);
        const { targetIn: c, targetOut: l, canvasIn: u, canvasOut: d } = Rn[t], g = n !== r;
        if (n && g) {
            const t = s(s({}, h), {}, {
                e: a,
                target: n,
                nextTarget: r
            }, jn(this, a));
            o && this.fire(d, t), n.fire(l, t);
        }
        if (r && g) {
            const t = s(s({}, h), {}, {
                e: a,
                target: r,
                previousTarget: n
            }, jn(this, a));
            o && this.fire(u, t), r.fire(c, t);
        }
    }
    __onMouseWheel(t) {
        this._cacheTransformEventData(t), this._handleEvent(t, "wheel"), this._resetTransformEventData();
    }
    _transformObject(t) {
        const e = this.getScenePoint(t), s = this._currentTransform, i = s.target, r = i.group ? pe(e, void 0, i.group.calcTransformMatrix()) : e;
        s.shiftKey = t.shiftKey, s.altKey = !!this.centeredKey && t[this.centeredKey], this._performTransformAction(t, s, r), s.actionPerformed && this.requestRenderAll();
    }
    _performTransformAction(t, e, s) {
        const { action: i, actionHandler: r, target: n } = e, o = !!r && r(t, e, s.x, s.y);
        o && n.setCoords(), "drag" === i && o && (e.target.isMoving = !0, this.setCursor(e.target.moveCursor || this.moveCursor)), e.actionPerformed = e.actionPerformed || o;
    }
    _setCursorFromEvent(t, e) {
        if (!e) return void this.setCursor(this.defaultCursor);
        let s = e.hoverCursor || this.hoverCursor;
        const i = Ut(this._activeObject) ? this._activeObject : null, r = (!i || e.group !== i) && e.findControl(this.getViewportPoint(t));
        if (r) {
            const s = r.control;
            this.setCursor(s.cursorStyleHandler(t, s, e));
        } else e.subTargetCheck && this.targets.concat().reverse().map((t)=>{
            s = t.hoverCursor || s;
        }), this.setCursor(s);
    }
    handleMultiSelection(t, e) {
        const s = this._activeObject, i = Ut(s);
        if (s && this._isSelectionKeyPressed(t) && this.selection && e && e.selectable && (s !== e || i) && (i || !e.isDescendantOf(s) && !s.isDescendantOf(e)) && !e.onSelect({
            e: t
        }) && !s.getActiveControl()) {
            if (i) {
                const i = s.getObjects();
                if (e === s) {
                    const s = this.getViewportPoint(t);
                    if (!(e = this.searchPossibleTargets(i, s) || this.searchPossibleTargets(this._objects, s)) || !e.selectable) return !1;
                }
                e.group === s ? (s.remove(e), this._hoveredTarget = e, this._hoveredTargets = [
                    ...this.targets
                ], 1 === s.size() && this._setActiveObject(s.item(0), t)) : (s.multiSelectAdd(e), this._hoveredTarget = s, this._hoveredTargets = [
                    ...this.targets
                ]), this._fireSelectionEvents(i, t);
            } else {
                s.isEditing && s.exitEditing();
                const i = new (tt.getClass("ActiveSelection"))([], {
                    canvas: this
                });
                i.multiSelectAdd(s, e), this._hoveredTarget = i, this._setActiveObject(i, t), this._fireSelectionEvents([
                    s
                ], t);
            }
            return !0;
        }
        return !1;
    }
    handleSelection(t) {
        if (!this.selection || !this._groupSelector) return !1;
        const { x: e, y: s, deltaX: i, deltaY: r } = this._groupSelector, n = new ot(e, s), o = n.add(new ot(i, r)), a = n.min(o), h = n.max(o).subtract(a), c = this.collectObjects({
            left: a.x,
            top: a.y,
            width: h.x,
            height: h.y
        }, {
            includeIntersecting: !this.selectionFullyContained
        }), l = n.eq(o) ? c[0] ? [
            c[0]
        ] : [] : c.length > 1 ? c.filter((e)=>!e.onSelect({
                e: t
            })).reverse() : c;
        if (1 === l.length) this.setActiveObject(l[0], t);
        else if (l.length > 1) {
            const e = tt.getClass("ActiveSelection");
            this.setActiveObject(new e(l, {
                canvas: this
            }), t);
        }
        return this._groupSelector = null, !0;
    }
    clear() {
        this.textEditingManager.clear(), super.clear();
    }
    destroy() {
        this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
    }
}
const Bn = {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0
}, Xn = s(s({}, Bn), {}, {
    r1: 0,
    r2: 0
}), Yn = (t, e)=>isNaN(t) && "number" == typeof e ? e : t, Wn = /^(\d+\.\d+)%|(\d+)%$/;
function Vn(t) {
    return t && Wn.test(t);
}
function zn(t, e) {
    const s = "number" == typeof t ? t : "string" == typeof t ? parseFloat(t) / (Vn(t) ? 100 : 1) : NaN;
    return ks(0, Yn(s, e), 1);
}
const Gn = /\s*;\s*/, Hn = /\s*:\s*/;
function Nn(t, e) {
    let s, i;
    const r = t.getAttribute("style");
    if (r) {
        const t = r.split(Gn);
        "" === t[t.length - 1] && t.pop();
        for(let e = t.length; e--;){
            const [r, n] = t[e].split(Hn).map((t)=>t.trim());
            "stop-color" === r ? s = n : "stop-opacity" === r && (i = n);
        }
    }
    const n = new Le(s || t.getAttribute("stop-color") || "rgb(0,0,0)");
    return {
        offset: zn(t.getAttribute("offset"), 0),
        color: n.toRgb(),
        opacity: Yn(parseFloat(i || t.getAttribute("stop-opacity") || ""), 1) * n.getAlpha() * e
    };
}
function Un(t, e) {
    const s = [], i = t.getElementsByTagName("stop"), r = zn(e, 1);
    for(let t = i.length; t--;)s.push(Nn(i[t], r));
    return s;
}
function qn(t) {
    return "linearGradient" === t.nodeName || "LINEARGRADIENT" === t.nodeName ? "linear" : "radial";
}
function Kn(t) {
    return "userSpaceOnUse" === t.getAttribute("gradientUnits") ? "pixels" : "percentage";
}
function Jn(t, e) {
    return t.getAttribute(e);
}
function Qn(t, e) {
    return function(t, e) {
        let s, { width: i, height: r, gradientUnits: n } = e;
        return Object.keys(t).reduce((e, o)=>{
            const a = t[o];
            return "Infinity" === a ? s = 1 : "-Infinity" === a ? s = 0 : (s = "string" == typeof a ? parseFloat(a) : a, "string" == typeof a && Vn(a) && (s *= .01, "pixels" === n && ("x1" !== o && "x2" !== o && "r2" !== o || (s *= i), "y1" !== o && "y2" !== o || (s *= r)))), e[o] = s, e;
        }, {});
    }("linear" === qn(t) ? function(t) {
        return {
            x1: Jn(t, "x1") || 0,
            y1: Jn(t, "y1") || 0,
            x2: Jn(t, "x2") || "100%",
            y2: Jn(t, "y2") || 0
        };
    }(t) : function(t) {
        return {
            x1: Jn(t, "fx") || Jn(t, "cx") || "50%",
            y1: Jn(t, "fy") || Jn(t, "cy") || "50%",
            r1: 0,
            x2: Jn(t, "cx") || "50%",
            y2: Jn(t, "cy") || "50%",
            r2: Jn(t, "r") || "50%"
        };
    }(t), s(s({}, e), {}, {
        gradientUnits: Kn(t)
    }));
}
class Zn {
    constructor(t){
        const { type: e = "linear", gradientUnits: i = "pixels", coords: r = {}, colorStops: n = [], offsetX: o = 0, offsetY: a = 0, gradientTransform: h, id: c } = t || {};
        Object.assign(this, {
            type: e,
            gradientUnits: i,
            coords: s(s({}, "radial" === e ? Xn : Bn), r),
            colorStops: n,
            offsetX: o,
            offsetY: a,
            gradientTransform: h,
            id: c ? "".concat(c, "_").concat(ft()) : ft()
        });
    }
    addColorStop(t) {
        for(const e in t){
            const s = new Le(t[e]);
            this.colorStops.push({
                offset: parseFloat(e),
                color: s.toRgb(),
                opacity: s.getAlpha()
            });
        }
        return this;
    }
    toObject(t) {
        return s(s({}, Yt(this, t)), {}, {
            type: this.type,
            coords: s({}, this.coords),
            colorStops: this.colorStops.map((t)=>s({}, t)),
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            gradientUnits: this.gradientUnits,
            gradientTransform: this.gradientTransform ? [
                ...this.gradientTransform
            ] : void 0
        });
    }
    toSVG(t) {
        let { additionalTransform: e } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i = [], r = this.gradientTransform ? this.gradientTransform.concat() : T.concat(), n = "pixels" === this.gradientUnits ? "userSpaceOnUse" : "objectBoundingBox", o = this.colorStops.map((t)=>s({}, t)).sort((t, e)=>t.offset - e.offset);
        let a = -this.offsetX, h = -this.offsetY;
        var c;
        "objectBoundingBox" === n ? (a /= t.width, h /= t.height) : (a += t.width / 2, h += t.height / 2), (c = t) && "function" == typeof c._renderPathCommands && "percentage" !== this.gradientUnits && (a -= t.pathOffset.x, h -= t.pathOffset.y), r[4] -= a, r[5] -= h;
        const l = [
            'id="SVGID_'.concat(this.id, '"'),
            'gradientUnits="'.concat(n, '"'),
            'gradientTransform="'.concat(e ? e + " " : "").concat(zt(r), '"'),
            ""
        ].join(" ");
        if ("linear" === this.type) {
            const { x1: t, y1: e, x2: s, y2: r } = this.coords;
            i.push("<linearGradient ", l, ' x1="', t, '" y1="', e, '" x2="', s, '" y2="', r, '">\n');
        } else if ("radial" === this.type) {
            const { x1: t, y1: e, x2: s, y2: r, r1: n, r2: a } = this.coords, h = n > a;
            i.push("<radialGradient ", l, ' cx="', h ? t : s, '" cy="', h ? e : r, '" r="', h ? n : a, '" fx="', h ? s : t, '" fy="', h ? r : e, '">\n'), h && (o.reverse(), o.forEach((t)=>{
                t.offset = 1 - t.offset;
            }));
            const c = Math.min(n, a);
            if (c > 0) {
                const t = c / Math.max(n, a);
                o.forEach((e)=>{
                    e.offset += t * (1 - e.offset);
                });
            }
        }
        return o.forEach((t)=>{
            let { color: e, offset: s, opacity: r } = t;
            i.push("<stop ", 'offset="', 100 * s + "%", '" style="stop-color:', e, void 0 !== r ? ";stop-opacity: " + r : ";", '"/>\n');
        }), i.push("linear" === this.type ? "</linearGradient>" : "</radialGradient>", "\n"), i.join("");
    }
    toLive(t) {
        const { x1: e, y1: s, x2: i, y2: r, r1: n, r2: o } = this.coords, a = "linear" === this.type ? t.createLinearGradient(e, s, i, r) : t.createRadialGradient(e, s, n, i, r, o);
        return this.colorStops.forEach((t)=>{
            let { color: e, opacity: s, offset: i } = t;
            a.addColorStop(i, void 0 !== s ? new Le(e).setAlpha(s).toRgba() : e);
        }), a;
    }
    static async fromObject(t) {
        const { colorStops: e, gradientTransform: i } = t;
        return new this(s(s({}, t), {}, {
            colorStops: e ? e.map((t)=>s({}, t)) : void 0,
            gradientTransform: i ? [
                ...i
            ] : void 0
        }));
    }
    static fromElement(t, e, i) {
        const r = Kn(t), n = e._findCenterFromElement();
        return new this(s({
            id: t.getAttribute("id") || void 0,
            type: qn(t),
            coords: Qn(t, {
                width: i.viewBoxWidth || i.width,
                height: i.viewBoxHeight || i.height
            }),
            colorStops: Un(t, i.opacity),
            gradientUnits: r,
            gradientTransform: br(t.getAttribute("gradientTransform") || "")
        }, "pixels" === r ? {
            offsetX: e.width / 2 - n.x,
            offsetY: e.height / 2 - n.y
        } : {
            offsetX: 0,
            offsetY: 0
        }));
    }
}
t(Zn, "type", "Gradient"), tt.setClass(Zn, "gradient"), tt.setClass(Zn, "linear"), tt.setClass(Zn, "radial");
const $n = [
    "type",
    "source",
    "patternTransform"
];
class to {
    get type() {
        return "pattern";
    }
    set type(t) {
        a("warn", "Setting type has no effect", t);
    }
    constructor(e){
        t(this, "repeat", "repeat"), t(this, "offsetX", 0), t(this, "offsetY", 0), t(this, "crossOrigin", ""), this.id = ft(), Object.assign(this, e);
    }
    isImageSource() {
        return !!this.source && "string" == typeof this.source.src;
    }
    isCanvasSource() {
        return !!this.source && !!this.source.toDataURL;
    }
    sourceToString() {
        return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
    }
    toLive(t) {
        return this.source && (!this.isImageSource() || this.source.complete && 0 !== this.source.naturalWidth && 0 !== this.source.naturalHeight) ? t.createPattern(this.source, this.repeat) : null;
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        const { repeat: e, crossOrigin: i } = this;
        return s(s({}, Yt(this, t)), {}, {
            type: "pattern",
            source: this.sourceToString(),
            repeat: e,
            crossOrigin: i,
            offsetX: Vt(this.offsetX, o.NUM_FRACTION_DIGITS),
            offsetY: Vt(this.offsetY, o.NUM_FRACTION_DIGITS),
            patternTransform: this.patternTransform ? [
                ...this.patternTransform
            ] : null
        });
    }
    toSVG(t) {
        let { width: e, height: s } = t;
        const { source: i, repeat: r, id: n } = this, o = Yn(this.offsetX / e, 0), a = Yn(this.offsetY / s, 0), h = "repeat-y" === r || "no-repeat" === r ? 1 + Math.abs(o || 0) : Yn(i.width / e, 0), c = "repeat-x" === r || "no-repeat" === r ? 1 + Math.abs(a || 0) : Yn(i.height / s, 0);
        return [
            '<pattern id="SVGID_'.concat(n, '" x="').concat(o, '" y="').concat(a, '" width="').concat(h, '" height="').concat(c, '">'),
            '<image x="0" y="0" width="'.concat(i.width, '" height="').concat(i.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'),
            "</pattern>",
            ""
        ].join("\n");
    }
    static async fromObject(t, e) {
        let { type: r, source: n, patternTransform: o } = t, a = i(t, $n);
        const h = await It(n, s(s({}, e), {}, {
            crossOrigin: a.crossOrigin
        }));
        return new this(s(s({}, a), {}, {
            patternTransform: o && o.slice(0),
            source: h
        }));
    }
}
t(to, "type", "Pattern"), tt.setClass(to), tt.setClass(to, "pattern");
class eo {
    constructor(e){
        t(this, "color", "rgb(0, 0, 0)"), t(this, "width", 1), t(this, "shadow", null), t(this, "strokeLineCap", "round"), t(this, "strokeLineJoin", "round"), t(this, "strokeMiterLimit", 10), t(this, "strokeDashArray", null), t(this, "limitedToCanvasSize", !1), this.canvas = e;
    }
    _setBrushStyles(t) {
        t.strokeStyle = this.color, t.lineWidth = this.width, t.lineCap = this.strokeLineCap, t.miterLimit = this.strokeMiterLimit, t.lineJoin = this.strokeLineJoin, t.setLineDash(this.strokeDashArray || []);
    }
    _saveAndTransform(t) {
        const e = this.canvas.viewportTransform;
        t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
    }
    needsFullRender() {
        return new Le(this.color).getAlpha() < 1 || !!this.shadow;
    }
    _setShadow() {
        if (!this.shadow || !this.canvas) return;
        const t = this.canvas, e = this.shadow, s = t.contextTop, i = t.getZoom() * t.getRetinaScaling();
        s.shadowColor = e.color, s.shadowBlur = e.blur * i, s.shadowOffsetX = e.offsetX * i, s.shadowOffsetY = e.offsetY * i;
    }
    _resetShadow() {
        const t = this.canvas.contextTop;
        t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0;
    }
    _isOutSideCanvas(t) {
        return t.x < 0 || t.x > this.canvas.getWidth() || t.y < 0 || t.y > this.canvas.getHeight();
    }
}
const so = [
    "path",
    "left",
    "top"
], io = [
    "d"
];
class ro extends ji {
    constructor(t){
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { path: s, left: r, top: n } = e, o = i(e, so);
        super(), Object.assign(this, ro.ownDefaults), this.setOptions(o), this._setPath(t || [], !0), "number" == typeof r && this.set(M, r), "number" == typeof n && this.set(P, n);
    }
    _setPath(t, e) {
        this.path = sn(Array.isArray(t) ? t : xn(t)), this.setBoundingBox(e);
    }
    _findCenterFromElement() {
        const t = this._calcBoundsFromPath();
        return new ot(t.left + t.width / 2, t.top + t.height / 2);
    }
    _renderPathCommands(t) {
        const e = -this.pathOffset.x, s = -this.pathOffset.y;
        t.beginPath();
        for (const i of this.path)switch(i[0]){
            case "L":
                t.lineTo(i[1] + e, i[2] + s);
                break;
            case "M":
                t.moveTo(i[1] + e, i[2] + s);
                break;
            case "C":
                t.bezierCurveTo(i[1] + e, i[2] + s, i[3] + e, i[4] + s, i[5] + e, i[6] + s);
                break;
            case "Q":
                t.quadraticCurveTo(i[1] + e, i[2] + s, i[3] + e, i[4] + s);
                break;
            case "Z":
                t.closePath();
        }
    }
    _render(t) {
        this._renderPathCommands(t), this._renderPaintInOrder(t);
    }
    toString() {
        return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return s(s({}, super.toObject(t)), {}, {
            path: this.path.map((t)=>t.slice())
        });
    }
    toDatalessObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        const e = this.toObject(t);
        return this.sourcePath && (delete e.path, e.sourcePath = this.sourcePath), e;
    }
    _toSVG() {
        const t = bn(this.path, o.NUM_FRACTION_DIGITS);
        return [
            "<path ",
            "COMMON_PARTS",
            'd="'.concat(t, '" stroke-linecap="round" />\n')
        ];
    }
    _getOffsetTransform() {
        const t = o.NUM_FRACTION_DIGITS;
        return " translate(".concat(Vt(-this.pathOffset.x, t), ", ").concat(Vt(-this.pathOffset.y, t), ")");
    }
    toClipPathSVG(t) {
        const e = this._getOffsetTransform();
        return "\t" + this._createBaseClipPathSVGMarkup(this._toSVG(), {
            reviver: t,
            additionalTransform: e
        });
    }
    toSVG(t) {
        const e = this._getOffsetTransform();
        return this._createBaseSVGMarkup(this._toSVG(), {
            reviver: t,
            additionalTransform: e
        });
    }
    complexity() {
        return this.path.length;
    }
    setDimensions() {
        this.setBoundingBox();
    }
    setBoundingBox(t) {
        const { width: e, height: s, pathOffset: i } = this._calcDimensions();
        this.set({
            width: e,
            height: s,
            pathOffset: i
        }), t && this.setPositionByOrigin(i, D, D);
    }
    _calcBoundsFromPath() {
        const t = [];
        let e = 0, s = 0, i = 0, r = 0;
        for (const n of this.path)switch(n[0]){
            case "L":
                i = n[1], r = n[2], t.push({
                    x: e,
                    y: s
                }, {
                    x: i,
                    y: r
                });
                break;
            case "M":
                i = n[1], r = n[2], e = i, s = r;
                break;
            case "C":
                t.push(...tn(i, r, n[1], n[2], n[3], n[4], n[5], n[6])), i = n[5], r = n[6];
                break;
            case "Q":
                t.push(...tn(i, r, n[1], n[2], n[1], n[2], n[3], n[4])), i = n[3], r = n[4];
                break;
            case "Z":
                i = e, r = s;
        }
        return ae(t);
    }
    _calcDimensions() {
        const t = this._calcBoundsFromPath();
        return s(s({}, t), {}, {
            pathOffset: new ot(t.left + t.width / 2, t.top + t.height / 2)
        });
    }
    static fromObject(t) {
        return this._fromObject(t, {
            extraParam: "path"
        });
    }
    static async fromElement(t, e, r) {
        const n = Dr(t, this.ATTRIBUTE_NAMES, r), { d: o } = n;
        return new this(o, s(s(s({}, i(n, io)), e), {}, {
            left: void 0,
            top: void 0
        }));
    }
}
t(ro, "type", "Path"), t(ro, "cacheProperties", [
    ...Ms,
    "path",
    "fillRule"
]), t(ro, "ATTRIBUTE_NAMES", [
    ...Ji,
    "d"
]), tt.setClass(ro), tt.setSVGClass(ro);
class no extends eo {
    constructor(e){
        super(e), t(this, "decimate", .4), t(this, "drawStraightLine", !1), t(this, "straightLineKey", "shiftKey"), this._points = [], this._hasStraightLine = !1;
    }
    needsFullRender() {
        return super.needsFullRender() || this._hasStraightLine;
    }
    static drawSegment(t, e, s) {
        const i = e.midPointFrom(s);
        return t.quadraticCurveTo(e.x, e.y, i.x, i.y), i;
    }
    onMouseDown(t, e) {
        let { e: s } = e;
        this.canvas._isMainEvent(s) && (this.drawStraightLine = !!this.straightLineKey && s[this.straightLineKey], this._prepareForDrawing(t), this._addPoint(t), this._render());
    }
    onMouseMove(t, e) {
        let { e: s } = e;
        if (this.canvas._isMainEvent(s) && (this.drawStraightLine = !!this.straightLineKey && s[this.straightLineKey], (!0 !== this.limitedToCanvasSize || !this._isOutSideCanvas(t)) && this._addPoint(t) && this._points.length > 1)) if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render();
        else {
            const t = this._points, e = t.length, s = this.canvas.contextTop;
            this._saveAndTransform(s), this.oldEnd && (s.beginPath(), s.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = no.drawSegment(s, t[e - 2], t[e - 1]), s.stroke(), s.restore();
        }
    }
    onMouseUp(t) {
        let { e: e } = t;
        return !this.canvas._isMainEvent(e) || (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1);
    }
    _prepareForDrawing(t) {
        this._reset(), this._addPoint(t), this.canvas.contextTop.moveTo(t.x, t.y);
    }
    _addPoint(t) {
        return !(this._points.length > 1 && t.eq(this._points[this._points.length - 1])) && (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(t), !0);
    }
    _reset() {
        this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1;
    }
    _render() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.canvas.contextTop, e = this._points[0], s = this._points[1];
        if (this._saveAndTransform(t), t.beginPath(), 2 === this._points.length && e.x === s.x && e.y === s.y) {
            const t = this.width / 1e3;
            e.x -= t, s.x += t;
        }
        t.moveTo(e.x, e.y);
        for(let i = 1; i < this._points.length; i++)no.drawSegment(t, e, s), e = this._points[i], s = this._points[i + 1];
        t.lineTo(e.x, e.y), t.stroke(), t.restore();
    }
    convertPointsToSVGPath(t) {
        const e = this.width / 1e3;
        return Cn(t, e);
    }
    createPath(t) {
        const e = new ro(t, {
            fill: null,
            stroke: this.color,
            strokeWidth: this.width,
            strokeLineCap: this.strokeLineCap,
            strokeMiterLimit: this.strokeMiterLimit,
            strokeLineJoin: this.strokeLineJoin,
            strokeDashArray: this.strokeDashArray
        });
        return this.shadow && (this.shadow.affectStroke = !0, e.shadow = new Os(this.shadow)), e;
    }
    decimatePoints(t, e) {
        if (t.length <= 2) return t;
        let s, i = t[0];
        const r = this.canvas.getZoom(), n = Math.pow(e / r, 2), o = t.length - 1, a = [
            i
        ];
        for(let e = 1; e < o - 1; e++)s = Math.pow(i.x - t[e].x, 2) + Math.pow(i.y - t[e].y, 2), s >= n && (i = t[e], a.push(i));
        return a.push(t[o]), a;
    }
    _finalizeAndAddPath() {
        this.canvas.contextTop.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate));
        const t = this.convertPointsToSVGPath(this._points);
        if (function(t) {
            return "M 0 0 Q 0 0 0 0 L 0 0" === bn(t);
        }(t)) return void this.canvas.requestRenderAll();
        const e = this.createPath(t);
        this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", {
            path: e
        }), this.canvas.add(e), this.canvas.requestRenderAll(), e.setCoords(), this._resetShadow(), this.canvas.fire("path:created", {
            path: e
        });
    }
}
const oo = [
    "left",
    "top",
    "radius"
], ao = [
    "radius",
    "startAngle",
    "endAngle",
    "counterClockwise"
];
class ho extends ji {
    static getDefaults() {
        return s(s({}, super.getDefaults()), ho.ownDefaults);
    }
    constructor(t){
        super(), Object.assign(this, ho.ownDefaults), this.setOptions(t);
    }
    _set(t, e) {
        return super._set(t, e), "radius" === t && this.setRadius(e), this;
    }
    _render(t) {
        t.beginPath(), t.arc(0, 0, this.radius, xt(this.startAngle), xt(this.endAngle), this.counterClockwise), this._renderPaintInOrder(t);
    }
    getRadiusX() {
        return this.get("radius") * this.get(H);
    }
    getRadiusY() {
        return this.get("radius") * this.get(N);
    }
    setRadius(t) {
        this.radius = t, this.set({
            width: 2 * t,
            height: 2 * t
        });
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return super.toObject([
            ...ao,
            ...t
        ]);
    }
    _toSVG() {
        const t = (this.endAngle - this.startAngle) % 360;
        if (0 === t) return [
            "<circle ",
            "COMMON_PARTS",
            'cx="0" cy="0" ',
            'r="',
            "".concat(this.radius),
            '" />\n'
        ];
        {
            const { radius: e } = this, s = xt(this.startAngle), i = xt(this.endAngle), r = rt(s) * e, n = nt(s) * e, o = rt(i) * e, a = nt(i) * e, h = t > 180 ? 1 : 0, c = this.counterClockwise ? 0 : 1;
            return [
                '<path d="M '.concat(r, " ").concat(n, " A ").concat(e, " ").concat(e, " 0 ").concat(h, " ").concat(c, " ").concat(o, " ").concat(a, '" '),
                "COMMON_PARTS",
                " />\n"
            ];
        }
    }
    static async fromElement(t, e, r) {
        const n = Dr(t, this.ATTRIBUTE_NAMES, r), { left: o = 0, top: a = 0, radius: h = 0 } = n;
        return new this(s(s({}, i(n, oo)), {}, {
            radius: h,
            left: o - h,
            top: a - h
        }));
    }
    static fromObject(t) {
        return super._fromObject(t);
    }
}
t(ho, "type", "Circle"), t(ho, "cacheProperties", [
    ...Ms,
    ...ao
]), t(ho, "ownDefaults", {
    radius: 0,
    startAngle: 0,
    endAngle: 360,
    counterClockwise: !1
}), t(ho, "ATTRIBUTE_NAMES", [
    "cx",
    "cy",
    "r",
    ...Ji
]), tt.setClass(ho), tt.setSVGClass(ho);
class co extends eo {
    constructor(e){
        super(e), t(this, "width", 10), this.points = [];
    }
    drawDot(t) {
        const e = this.addPoint(t), s = this.canvas.contextTop;
        this._saveAndTransform(s), this.dot(s, e), s.restore();
    }
    dot(t, e) {
        t.fillStyle = e.fill, t.beginPath(), t.arc(e.x, e.y, e.radius, 0, 2 * Math.PI, !1), t.closePath(), t.fill();
    }
    onMouseDown(t) {
        this.points = [], this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(t);
    }
    _render() {
        const t = this.canvas.contextTop, e = this.points;
        this._saveAndTransform(t);
        for(let s = 0; s < e.length; s++)this.dot(t, e[s]);
        t.restore();
    }
    onMouseMove(t) {
        !0 === this.limitedToCanvasSize && this._isOutSideCanvas(t) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(t), this._render()) : this.drawDot(t));
    }
    onMouseUp() {
        const t = this.canvas.renderOnAddRemove;
        this.canvas.renderOnAddRemove = !1;
        const e = [];
        for(let t = 0; t < this.points.length; t++){
            const s = this.points[t], i = new ho({
                radius: s.radius,
                left: s.x,
                top: s.y,
                originX: D,
                originY: D,
                fill: s.fill
            });
            this.shadow && (i.shadow = new Os(this.shadow)), e.push(i);
        }
        const s = new Hr(e, {
            canvas: this.canvas
        });
        this.canvas.fire("before:path:created", {
            path: s
        }), this.canvas.add(s), this.canvas.fire("path:created", {
            path: s
        }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t, this.canvas.requestRenderAll();
    }
    addPoint(t) {
        let { x: e, y: s } = t;
        const i = {
            x: e,
            y: s,
            radius: wn(Math.max(0, this.width - 20), this.width + 20) / 2,
            fill: new Le(this.color).setAlpha(wn(0, 100) / 100).toRgba()
        };
        return this.points.push(i), i;
    }
}
class lo extends eo {
    constructor(e){
        super(e), t(this, "width", 10), t(this, "density", 20), t(this, "dotWidth", 1), t(this, "dotWidthVariance", 1), t(this, "randomOpacity", !1), t(this, "optimizeOverlapping", !0), this.sprayChunks = [], this.sprayChunk = [];
    }
    onMouseDown(t) {
        this.sprayChunks = [], this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(t), this.renderChunck(this.sprayChunk);
    }
    onMouseMove(t) {
        !0 === this.limitedToCanvasSize && this._isOutSideCanvas(t) || (this.addSprayChunk(t), this.renderChunck(this.sprayChunk));
    }
    onMouseUp() {
        const t = this.canvas.renderOnAddRemove;
        this.canvas.renderOnAddRemove = !1;
        const e = [];
        for(let t = 0; t < this.sprayChunks.length; t++){
            const s = this.sprayChunks[t];
            for(let t = 0; t < s.length; t++){
                const i = s[t], r = new Er({
                    width: i.width,
                    height: i.width,
                    left: i.x + 1,
                    top: i.y + 1,
                    originX: D,
                    originY: D,
                    fill: this.color
                });
                e.push(r);
            }
        }
        const s = new Hr(this.optimizeOverlapping ? function(t) {
            const e = {}, s = [];
            for(let i, r = 0; r < t.length; r++)i = "".concat(t[r].left).concat(t[r].top), e[i] || (e[i] = !0, s.push(t[r]));
            return s;
        }(e) : e, {
            objectCaching: !0,
            subTargetCheck: !1,
            interactive: !1
        });
        this.shadow && s.set("shadow", new Os(this.shadow)), this.canvas.fire("before:path:created", {
            path: s
        }), this.canvas.add(s), this.canvas.fire("path:created", {
            path: s
        }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t, this.canvas.requestRenderAll();
    }
    renderChunck(t) {
        const e = this.canvas.contextTop;
        e.fillStyle = this.color, this._saveAndTransform(e);
        for(let s = 0; s < t.length; s++){
            const i = t[s];
            e.globalAlpha = i.opacity, e.fillRect(i.x, i.y, i.width, i.width);
        }
        e.restore();
    }
    _render() {
        const t = this.canvas.contextTop;
        t.fillStyle = this.color, this._saveAndTransform(t);
        for(let t = 0; t < this.sprayChunks.length; t++)this.renderChunck(this.sprayChunks[t]);
        t.restore();
    }
    addSprayChunk(t) {
        this.sprayChunk = [];
        const e = this.width / 2;
        for(let s = 0; s < this.density; s++)this.sprayChunk.push({
            x: wn(t.x - e, t.x + e),
            y: wn(t.y - e, t.y + e),
            width: this.dotWidthVariance ? wn(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth,
            opacity: this.randomOpacity ? wn(0, 100) / 100 : 1
        });
        this.sprayChunks.push(this.sprayChunk);
    }
}
class uo extends no {
    constructor(t){
        super(t);
    }
    getPatternSrc() {
        const t = pt(), e = t.getContext("2d");
        return t.width = t.height = 25, e && (e.fillStyle = this.color, e.beginPath(), e.arc(10, 10, 10, 0, 2 * Math.PI, !1), e.closePath(), e.fill()), t;
    }
    getPattern(t) {
        return t.createPattern(this.source || this.getPatternSrc(), "repeat");
    }
    _setBrushStyles(t) {
        super._setBrushStyles(t);
        const e = this.getPattern(t);
        e && (t.strokeStyle = e);
    }
    createPath(t) {
        const e = super.createPath(t), s = e._getLeftTopCoords().scalarAdd(e.strokeWidth / 2);
        return e.stroke = new to({
            source: this.source || this.getPatternSrc(),
            offsetX: -s.x,
            offsetY: -s.y
        }), e;
    }
}
const go = [
    "x1",
    "y1",
    "x2",
    "y2"
], fo = [
    "x1",
    "y1",
    "x2",
    "y2"
], po = [
    "x1",
    "x2",
    "y1",
    "y2"
];
class mo extends ji {
    constructor(){
        let [t, e, s, i] = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [
            0,
            0,
            0,
            0
        ], r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(), Object.assign(this, mo.ownDefaults), this.setOptions(r), this.x1 = t, this.x2 = s, this.y1 = e, this.y2 = i, this._setWidthHeight();
        const { left: n, top: o } = r;
        "number" == typeof n && this.set(M, n), "number" == typeof o && this.set(P, o);
    }
    _setWidthHeight() {
        const { x1: t, y1: e, x2: s, y2: i } = this;
        this.width = Math.abs(s - t), this.height = Math.abs(i - e);
        const { left: r, top: n, width: o, height: a } = ae([
            {
                x: t,
                y: e
            },
            {
                x: s,
                y: i
            }
        ]), h = new ot(r + o / 2, n + a / 2);
        this.setPositionByOrigin(h, D, D);
    }
    _set(t, e) {
        return super._set(t, e), po.includes(t) && this._setWidthHeight(), this;
    }
    _render(t) {
        t.beginPath();
        const e = this.calcLinePoints();
        t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.lineWidth = this.strokeWidth;
        const s = t.strokeStyle;
        var i;
        Gt(this.stroke) ? t.strokeStyle = this.stroke.toLive(t) : t.strokeStyle = null !== (i = this.stroke) && void 0 !== i ? i : t.fillStyle;
        this.stroke && this._renderStroke(t), t.strokeStyle = s;
    }
    _findCenterFromElement() {
        return new ot((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return s(s({}, super.toObject(t)), this.calcLinePoints());
    }
    _getNonTransformedDimensions() {
        const t = super._getNonTransformedDimensions();
        return "butt" === this.strokeLineCap && (0 === this.width && (t.y -= this.strokeWidth), 0 === this.height && (t.x -= this.strokeWidth)), t;
    }
    calcLinePoints() {
        const { x1: t, x2: e, y1: s, y2: i, width: r, height: n } = this, o = t <= e ? -1 : 1, a = s <= i ? -1 : 1;
        return {
            x1: o * r / 2,
            x2: o * -r / 2,
            y1: a * n / 2,
            y2: a * -n / 2
        };
    }
    _toSVG() {
        const { x1: t, x2: e, y1: s, y2: i } = this.calcLinePoints();
        return [
            "<line ",
            "COMMON_PARTS",
            'x1="'.concat(t, '" y1="').concat(s, '" x2="').concat(e, '" y2="').concat(i, '" />\n')
        ];
    }
    static async fromElement(t, e, s) {
        const r = Dr(t, this.ATTRIBUTE_NAMES, s), { x1: n = 0, y1: o = 0, x2: a = 0, y2: h = 0 } = r;
        return new this([
            n,
            o,
            a,
            h
        ], i(r, go));
    }
    static fromObject(t) {
        let { x1: e, y1: r, x2: n, y2: o } = t, a = i(t, fo);
        return this._fromObject(s(s({}, a), {}, {
            points: [
                e,
                r,
                n,
                o
            ]
        }), {
            extraParam: "points"
        });
    }
}
t(mo, "type", "Line"), t(mo, "cacheProperties", [
    ...Ms,
    ...po
]), t(mo, "ATTRIBUTE_NAMES", Ji.concat(po)), tt.setClass(mo), tt.setSVGClass(mo);
class vo extends ji {
    static getDefaults() {
        return s(s({}, super.getDefaults()), vo.ownDefaults);
    }
    constructor(t){
        super(), Object.assign(this, vo.ownDefaults), this.setOptions(t);
    }
    _render(t) {
        const e = this.width / 2, s = this.height / 2;
        t.beginPath(), t.moveTo(-e, s), t.lineTo(0, -s), t.lineTo(e, s), t.closePath(), this._renderPaintInOrder(t);
    }
    _toSVG() {
        const t = this.width / 2, e = this.height / 2;
        return [
            "<polygon ",
            "COMMON_PARTS",
            'points="',
            "".concat(-t, " ").concat(e, ",0 ").concat(-e, ",").concat(t, " ").concat(e),
            '" />'
        ];
    }
}
t(vo, "type", "Triangle"), t(vo, "ownDefaults", {
    width: 100,
    height: 100
}), tt.setClass(vo), tt.setSVGClass(vo);
const yo = [
    "rx",
    "ry"
];
class _o extends ji {
    static getDefaults() {
        return s(s({}, super.getDefaults()), _o.ownDefaults);
    }
    constructor(t){
        super(), Object.assign(this, _o.ownDefaults), this.setOptions(t);
    }
    _set(t, e) {
        switch(super._set(t, e), t){
            case "rx":
                this.rx = e, this.set("width", 2 * e);
                break;
            case "ry":
                this.ry = e, this.set("height", 2 * e);
        }
        return this;
    }
    getRx() {
        return this.get("rx") * this.get(H);
    }
    getRy() {
        return this.get("ry") * this.get(N);
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return super.toObject([
            ...yo,
            ...t
        ]);
    }
    _toSVG() {
        return [
            "<ellipse ",
            "COMMON_PARTS",
            'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, '" />\n')
        ];
    }
    _render(t) {
        t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(0, 0, this.rx, 0, S, !1), t.restore(), this._renderPaintInOrder(t);
    }
    static async fromElement(t, e, s) {
        const i = Dr(t, this.ATTRIBUTE_NAMES, s);
        return i.left = (i.left || 0) - i.rx, i.top = (i.top || 0) - i.ry, new this(i);
    }
}
function xo(t) {
    if (!t) return [];
    const e = t.replace(/,/g, " ").trim().split(/\s+/), s = [];
    for(let t = 0; t < e.length; t += 2)s.push({
        x: parseFloat(e[t]),
        y: parseFloat(e[t + 1])
    });
    return s;
}
t(_o, "type", "Ellipse"), t(_o, "cacheProperties", [
    ...Ms,
    ...yo
]), t(_o, "ownDefaults", {
    rx: 0,
    ry: 0
}), t(_o, "ATTRIBUTE_NAMES", [
    ...Ji,
    "cx",
    "cy",
    "rx",
    "ry"
]), tt.setClass(_o), tt.setSVGClass(_o);
const Co = [
    "left",
    "top"
], bo = {
    exactBoundingBox: !1
};
class So extends ji {
    static getDefaults() {
        return s(s({}, super.getDefaults()), So.ownDefaults);
    }
    constructor(){
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(), t(this, "strokeDiff", void 0), Object.assign(this, So.ownDefaults), this.setOptions(s), this.points = e;
        const { left: i, top: r } = s;
        this.initialized = !0, this.setBoundingBox(!0), "number" == typeof i && this.set(M, i), "number" == typeof r && this.set(P, r);
    }
    isOpen() {
        return !0;
    }
    _projectStrokeOnPoints(t) {
        return Xi(this.points, t, this.isOpen());
    }
    _calcDimensions(t) {
        t = s({
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: this.skewX,
            skewY: this.skewY,
            strokeLineCap: this.strokeLineCap,
            strokeLineJoin: this.strokeLineJoin,
            strokeMiterLimit: this.strokeMiterLimit,
            strokeUniform: this.strokeUniform,
            strokeWidth: this.strokeWidth
        }, t || {});
        const e = this.exactBoundingBox ? this._projectStrokeOnPoints(t).map((t)=>t.projectedPoint) : this.points;
        if (0 === e.length) return {
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            pathOffset: new ot,
            strokeOffset: new ot,
            strokeDiff: new ot
        };
        const i = ae(e), r = Lt(s(s({}, t), {}, {
            scaleX: 1,
            scaleY: 1
        })), n = ae(this.points.map((t)=>St(t, r, !0))), o = new ot(this.scaleX, this.scaleY);
        let a = i.left + i.width / 2, h = i.top + i.height / 2;
        return this.exactBoundingBox && (a -= h * Math.tan(xt(this.skewX)), h -= a * Math.tan(xt(this.skewY))), s(s({}, i), {}, {
            pathOffset: new ot(a, h),
            strokeOffset: new ot(n.left, n.top).subtract(new ot(i.left, i.top)).multiply(o),
            strokeDiff: new ot(i.width, i.height).subtract(new ot(n.width, n.height)).multiply(o)
        });
    }
    _findCenterFromElement() {
        const t = ae(this.points);
        return new ot(t.left + t.width / 2, t.top + t.height / 2);
    }
    setDimensions() {
        this.setBoundingBox();
    }
    setBoundingBox(t) {
        const { left: e, top: s, width: i, height: r, pathOffset: n, strokeOffset: o, strokeDiff: a } = this._calcDimensions();
        this.set({
            width: i,
            height: r,
            pathOffset: n,
            strokeOffset: o,
            strokeDiff: a
        }), t && this.setPositionByOrigin(new ot(e + i / 2, s + r / 2), D, D);
    }
    isStrokeAccountedForInDimensions() {
        return this.exactBoundingBox;
    }
    _getNonTransformedDimensions() {
        return this.exactBoundingBox ? new ot(this.width, this.height) : super._getNonTransformedDimensions();
    }
    _getTransformedDimensions() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        if (this.exactBoundingBox) {
            let n;
            if (Object.keys(t).some((t)=>this.strokeUniform || this.constructor.layoutProperties.includes(t))) {
                var e, s;
                const { width: i, height: r } = this._calcDimensions(t);
                n = new ot(null !== (e = t.width) && void 0 !== e ? e : i, null !== (s = t.height) && void 0 !== s ? s : r);
            } else {
                var i, r;
                n = new ot(null !== (i = t.width) && void 0 !== i ? i : this.width, null !== (r = t.height) && void 0 !== r ? r : this.height);
            }
            return n.multiply(new ot(t.scaleX || this.scaleX, t.scaleY || this.scaleY));
        }
        return super._getTransformedDimensions(t);
    }
    _set(t, e) {
        const s = this.initialized && this[t] !== e, i = super._set(t, e);
        return this.exactBoundingBox && s && ((t === H || t === N) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(t)) && this.setDimensions(), i;
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return s(s({}, super.toObject(t)), {}, {
            points: this.points.map((t)=>{
                let { x: e, y: s } = t;
                return {
                    x: e,
                    y: s
                };
            })
        });
    }
    _toSVG() {
        const t = [], e = this.pathOffset.x, s = this.pathOffset.y, i = o.NUM_FRACTION_DIGITS;
        for(let r = 0, n = this.points.length; r < n; r++)t.push(Vt(this.points[r].x - e, i), ",", Vt(this.points[r].y - s, i), " ");
        return [
            "<".concat(this.constructor.type.toLowerCase(), " "),
            "COMMON_PARTS",
            'points="'.concat(t.join(""), '" />\n')
        ];
    }
    _render(t) {
        const e = this.points.length, s = this.pathOffset.x, i = this.pathOffset.y;
        if (e && !isNaN(this.points[e - 1].y)) {
            t.beginPath(), t.moveTo(this.points[0].x - s, this.points[0].y - i);
            for(let r = 0; r < e; r++){
                const e = this.points[r];
                t.lineTo(e.x - s, e.y - i);
            }
            !this.isOpen() && t.closePath(), this._renderPaintInOrder(t);
        }
    }
    complexity() {
        return this.points.length;
    }
    static async fromElement(t, e, r) {
        return new this(xo(t.getAttribute("points")), s(s({}, i(Dr(t, this.ATTRIBUTE_NAMES, r), Co)), e));
    }
    static fromObject(t) {
        return this._fromObject(t, {
            extraParam: "points"
        });
    }
}
t(So, "ownDefaults", bo), t(So, "type", "Polyline"), t(So, "layoutProperties", [
    U,
    q,
    "strokeLineCap",
    "strokeLineJoin",
    "strokeMiterLimit",
    "strokeWidth",
    "strokeUniform",
    "points"
]), t(So, "cacheProperties", [
    ...Ms,
    "points"
]), t(So, "ATTRIBUTE_NAMES", [
    ...Ji
]), tt.setClass(So), tt.setSVGClass(So);
class wo extends So {
    isOpen() {
        return !1;
    }
}
t(wo, "ownDefaults", bo), t(wo, "type", "Polygon"), tt.setClass(wo), tt.setSVGClass(wo);
class To extends ji {
    isEmptyStyles(t) {
        if (!this.styles) return !0;
        if (void 0 !== t && !this.styles[t]) return !0;
        const e = void 0 === t ? this.styles : {
            line: this.styles[t]
        };
        for(const t in e)for(const s in e[t])for(const i in e[t][s])return !1;
        return !0;
    }
    styleHas(t, e) {
        if (!this.styles) return !1;
        if (void 0 !== e && !this.styles[e]) return !1;
        const s = void 0 === e ? this.styles : {
            0: this.styles[e]
        };
        for(const e in s)for(const i in s[e])if (void 0 !== s[e][i][t]) return !0;
        return !1;
    }
    cleanStyle(t) {
        if (!this.styles) return !1;
        const e = this.styles;
        let s, i, r = 0, n = !0, o = 0;
        for(const o in e){
            s = 0;
            for(const a in e[o]){
                const h = e[o][a] || {};
                r++, void 0 !== h[t] ? (i ? h[t] !== i && (n = !1) : i = h[t], h[t] === this[t] && delete h[t]) : n = !1, 0 !== Object.keys(h).length ? s++ : delete e[o][a];
            }
            0 === s && delete e[o];
        }
        for(let t = 0; t < this._textLines.length; t++)o += this._textLines[t].length;
        n && r === o && (this[t] = i, this.removeStyle(t));
    }
    removeStyle(t) {
        if (!this.styles) return;
        const e = this.styles;
        let s, i, r;
        for(i in e){
            for(r in s = e[i], s)delete s[r][t], 0 === Object.keys(s[r]).length && delete s[r];
            0 === Object.keys(s).length && delete e[i];
        }
    }
    _extendStyles(t, e) {
        const { lineIndex: i, charIndex: r } = this.get2DCursorLocation(t);
        this._getLineStyle(i) || this._setLineStyle(i);
        const n = Wt(s(s({}, this._getStyleDeclaration(i, r)), e), (t)=>void 0 !== t);
        this._setStyleDeclaration(i, r, n);
    }
    getSelectionStyles(t, e, s) {
        const i = [];
        for(let r = t; r < (e || t); r++)i.push(this.getStyleAtPosition(r, s));
        return i;
    }
    getStyleAtPosition(t, e) {
        const { lineIndex: s, charIndex: i } = this.get2DCursorLocation(t);
        return e ? this.getCompleteStyleDeclaration(s, i) : this._getStyleDeclaration(s, i);
    }
    setSelectionStyles(t, e, s) {
        for(let i = e; i < (s || e); i++)this._extendStyles(i, t);
        this._forceClearCache = !0;
    }
    _getStyleDeclaration(t, e) {
        var s;
        const i = this.styles && this.styles[t];
        return i && null !== (s = i[e]) && void 0 !== s ? s : {};
    }
    getCompleteStyleDeclaration(t, e) {
        return s(s({}, Yt(this, this.constructor._styleProperties)), this._getStyleDeclaration(t, e));
    }
    _setStyleDeclaration(t, e, s) {
        this.styles[t][e] = s;
    }
    _deleteStyleDeclaration(t, e) {
        delete this.styles[t][e];
    }
    _getLineStyle(t) {
        return !!this.styles[t];
    }
    _setLineStyle(t) {
        this.styles[t] = {};
    }
    _deleteLineStyle(t) {
        delete this.styles[t];
    }
}
t(To, "_styleProperties", Ne);
const Oo = /  +/g, ko = /"/g;
function Do(t, e, s, i, r) {
    return "\t\t".concat(function(t, e) {
        let { left: s, top: i, width: r, height: n } = e, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o.NUM_FRACTION_DIGITS;
        const h = Be(K, t, !1), [c, l, u, d] = [
            s,
            i,
            r,
            n
        ].map((t)=>Vt(t, a));
        return "<rect ".concat(h, ' x="').concat(c, '" y="').concat(l, '" width="').concat(u, '" height="').concat(d, '"></rect>');
    }(t, {
        left: e,
        top: s,
        width: i,
        height: r
    }), "\n");
}
const Mo = [
    "textAnchor",
    "textDecoration",
    "dx",
    "dy",
    "top",
    "left",
    "fontSize",
    "strokeWidth"
];
let Po;
class Eo extends To {
    static getDefaults() {
        return s(s({}, super.getDefaults()), Eo.ownDefaults);
    }
    constructor(e, s){
        super(), t(this, "__charBounds", []), Object.assign(this, Eo.ownDefaults), this.setOptions(s), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
    }
    setPathInfo() {
        const t = this.path;
        t && (t.segmentsInfo = fn(t.path));
    }
    _splitText() {
        const t = this._splitTextIntoLines(this.text);
        return this.textLines = t.lines, this._textLines = t.graphemeLines, this._unwrappedTextLines = t._unwrappedLines, this._text = t.graphemeText, t;
    }
    initDimensions() {
        this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(qe) && this.enlargeSpaces();
    }
    enlargeSpaces() {
        let t, e, s, i, r, n, o;
        for(let a = 0, h = this._textLines.length; a < h; a++)if ((this.textAlign === qe || a !== h - 1 && !this.isEndOfWrapping(a)) && (i = 0, r = this._textLines[a], e = this.getLineWidth(a), e < this.width && (o = this.textLines[a].match(this._reSpacesAndTabs)))) {
            s = o.length, t = (this.width - e) / s;
            for(let e = 0; e <= r.length; e++)n = this.__charBounds[a][e], this._reSpaceAndTab.test(r[e]) ? (n.width += t, n.kernedWidth += t, n.left += i, i += t) : n.left += i;
        }
    }
    isEndOfWrapping(t) {
        return t === this._textLines.length - 1;
    }
    missingNewlineOffset(t) {
        return 1;
    }
    get2DCursorLocation(t, e) {
        const s = e ? this._unwrappedTextLines : this._textLines;
        let i;
        for(i = 0; i < s.length; i++){
            if (t <= s[i].length) return {
                lineIndex: i,
                charIndex: t
            };
            t -= s[i].length + this.missingNewlineOffset(i, e);
        }
        return {
            lineIndex: i - 1,
            charIndex: s[i - 1].length < t ? s[i - 1].length : t
        };
    }
    toString() {
        return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
    }
    _getCacheCanvasDimensions() {
        const t = super._getCacheCanvasDimensions(), e = this.fontSize;
        return t.width += e * t.zoomX, t.height += e * t.zoomY, t;
    }
    _render(t) {
        const e = this.path;
        e && !e.isNotVisible() && e._render(t), this._setTextStyles(t), this._renderTextLinesBackground(t), this._renderTextDecoration(t, "underline"), this._renderText(t), this._renderTextDecoration(t, "overline"), this._renderTextDecoration(t, "linethrough");
    }
    _renderText(t) {
        this.paintFirst === J ? (this._renderTextStroke(t), this._renderTextFill(t)) : (this._renderTextFill(t), this._renderTextStroke(t));
    }
    _setTextStyles(t, e, s) {
        if (t.textBaseline = "alphabetic", this.path) switch(this.pathAlign){
            case D:
                t.textBaseline = "middle";
                break;
            case "ascender":
                t.textBaseline = P;
                break;
            case "descender":
                t.textBaseline = E;
        }
        t.font = this._getFontDeclaration(e, s);
    }
    calcTextWidth() {
        let t = this.getLineWidth(0);
        for(let e = 1, s = this._textLines.length; e < s; e++){
            const s = this.getLineWidth(e);
            s > t && (t = s);
        }
        return t;
    }
    _renderTextLine(t, e, s, i, r, n) {
        this._renderChars(t, e, s, i, r, n);
    }
    _renderTextLinesBackground(t) {
        if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
        const e = t.fillStyle, s = this._getLeftOffset();
        let i = this._getTopOffset();
        for(let e = 0, r = this._textLines.length; e < r; e++){
            const r = this.getHeightOfLine(e);
            if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", e)) {
                i += r;
                continue;
            }
            const n = this._textLines[e].length, o = this._getLineLeftOffset(e);
            let a, h, c = 0, l = 0, u = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
            for(let d = 0; d < n; d++){
                const n = this.__charBounds[e][d];
                h = this.getValueOfPropertyAt(e, d, "textBackgroundColor"), this.path ? (t.save(), t.translate(n.renderLeft, n.renderTop), t.rotate(n.angle), t.fillStyle = h, h && t.fillRect(-n.width / 2, -r / this.lineHeight * (1 - this._fontSizeFraction), n.width, r / this.lineHeight), t.restore()) : h !== u ? (a = s + o + l, "rtl" === this.direction && (a = this.width - a - c), t.fillStyle = u, u && t.fillRect(a, i, c, r / this.lineHeight), l = n.left, c = n.width, u = h) : c += n.kernedWidth;
            }
            h && !this.path && (a = s + o + l, "rtl" === this.direction && (a = this.width - a - c), t.fillStyle = h, t.fillRect(a, i, c, r / this.lineHeight)), i += r;
        }
        t.fillStyle = e, this._removeShadow(t);
    }
    _measureChar(t, e, s, i) {
        const r = _.getFontCache(e), n = this._getFontDeclaration(e), o = s + t, a = s && n === this._getFontDeclaration(i), h = e.fontSize / this.CACHE_FONT_SIZE;
        let c, l, u, d;
        if (s && void 0 !== r[s] && (u = r[s]), void 0 !== r[t] && (d = c = r[t]), a && void 0 !== r[o] && (l = r[o], d = l - u), void 0 === c || void 0 === u || void 0 === l) {
            const i = function() {
                if (!Po) {
                    const t = vt({
                        width: 0,
                        height: 0
                    });
                    Po = t.getContext("2d");
                }
                return Po;
            }();
            this._setTextStyles(i, e, !0), void 0 === c && (d = c = i.measureText(t).width, r[t] = c), void 0 === u && a && s && (u = i.measureText(s).width, r[s] = u), a && void 0 === l && (l = i.measureText(o).width, r[o] = l, d = l - u);
        }
        return {
            width: c * h,
            kernedWidth: d * h
        };
    }
    getHeightOfChar(t, e) {
        return this.getValueOfPropertyAt(t, e, "fontSize");
    }
    measureLine(t) {
        const e = this._measureLine(t);
        return 0 !== this.charSpacing && (e.width -= this._getWidthOfCharSpacing()), e.width < 0 && (e.width = 0), e;
    }
    _measureLine(t) {
        let e, s, i = 0;
        const r = this.pathSide === A, n = this.path, o = this._textLines[t], a = o.length, h = new Array(a);
        this.__charBounds[t] = h;
        for(let r = 0; r < a; r++){
            const n = o[r];
            s = this._getGraphemeBox(n, t, r, e), h[r] = s, i += s.kernedWidth, e = n;
        }
        if (h[a] = {
            left: s ? s.left + s.width : 0,
            width: 0,
            kernedWidth: 0,
            height: this.fontSize,
            deltaY: 0
        }, n && n.segmentsInfo) {
            let t = 0;
            const e = n.segmentsInfo[n.segmentsInfo.length - 1].length;
            switch(this.textAlign){
                case M:
                    t = r ? e - i : 0;
                    break;
                case D:
                    t = (e - i) / 2;
                    break;
                case A:
                    t = r ? 0 : e - i;
            }
            t += this.pathStartOffset * (r ? -1 : 1);
            for(let i = r ? a - 1 : 0; r ? i >= 0 : i < a; r ? i-- : i++)s = h[i], t > e ? t %= e : t < 0 && (t += e), this._setGraphemeOnPath(t, s), t += s.kernedWidth;
        }
        return {
            width: i,
            numOfSpaces: 0
        };
    }
    _setGraphemeOnPath(t, e) {
        const s = t + e.kernedWidth / 2, i = this.path, r = pn(i.path, s, i.segmentsInfo);
        e.renderLeft = r.x - i.pathOffset.x, e.renderTop = r.y - i.pathOffset.y, e.angle = r.angle + (this.pathSide === A ? Math.PI : 0);
    }
    _getGraphemeBox(t, e, s, i, r) {
        const n = this.getCompleteStyleDeclaration(e, s), o = i ? this.getCompleteStyleDeclaration(e, s - 1) : {}, a = this._measureChar(t, n, i, o);
        let h, c = a.kernedWidth, l = a.width;
        0 !== this.charSpacing && (h = this._getWidthOfCharSpacing(), l += h, c += h);
        const u = {
            width: l,
            left: 0,
            height: n.fontSize,
            kernedWidth: c,
            deltaY: n.deltaY
        };
        if (s > 0 && !r) {
            const t = this.__charBounds[e][s - 1];
            u.left = t.left + t.width + a.kernedWidth - a.width;
        }
        return u;
    }
    getHeightOfLine(t) {
        if (this.__lineHeights[t]) return this.__lineHeights[t];
        let e = this.getHeightOfChar(t, 0);
        for(let s = 1, i = this._textLines[t].length; s < i; s++)e = Math.max(this.getHeightOfChar(t, s), e);
        return this.__lineHeights[t] = e * this.lineHeight * this._fontSizeMult;
    }
    calcTextHeight() {
        let t, e = 0;
        for(let s = 0, i = this._textLines.length; s < i; s++)t = this.getHeightOfLine(s), e += s === i - 1 ? t / this.lineHeight : t;
        return e;
    }
    _getLeftOffset() {
        return "ltr" === this.direction ? -this.width / 2 : this.width / 2;
    }
    _getTopOffset() {
        return -this.height / 2;
    }
    _renderTextCommon(t, e) {
        t.save();
        let s = 0;
        const i = this._getLeftOffset(), r = this._getTopOffset();
        for(let n = 0, o = this._textLines.length; n < o; n++){
            const o = this.getHeightOfLine(n), a = o / this.lineHeight, h = this._getLineLeftOffset(n);
            this._renderTextLine(e, t, this._textLines[n], i + h, r + s + a, n), s += o;
        }
        t.restore();
    }
    _renderTextFill(t) {
        (this.fill || this.styleHas(K)) && this._renderTextCommon(t, "fillText");
    }
    _renderTextStroke(t) {
        (this.stroke && 0 !== this.strokeWidth || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray), t.beginPath(), this._renderTextCommon(t, "strokeText"), t.closePath(), t.restore());
    }
    _renderChars(t, e, s, i, r, n) {
        const o = this.getHeightOfLine(n), a = this.textAlign.includes(qe), h = this.path, c = !a && 0 === this.charSpacing && this.isEmptyStyles(n) && !h, l = "ltr" === this.direction, u = "ltr" === this.direction ? 1 : -1, d = e.direction;
        let g, f, p, m, v, y = "", _ = 0;
        if (e.save(), d !== this.direction && (e.canvas.setAttribute("dir", l ? "ltr" : "rtl"), e.direction = l ? "ltr" : "rtl", e.textAlign = l ? M : A), r -= o * this._fontSizeFraction / this.lineHeight, c) return this._renderChar(t, e, n, 0, s.join(""), i, r), void e.restore();
        for(let o = 0, c = s.length - 1; o <= c; o++)m = o === c || this.charSpacing || h, y += s[o], p = this.__charBounds[n][o], 0 === _ ? (i += u * (p.kernedWidth - p.width), _ += p.width) : _ += p.kernedWidth, a && !m && this._reSpaceAndTab.test(s[o]) && (m = !0), m || (g = g || this.getCompleteStyleDeclaration(n, o), f = this.getCompleteStyleDeclaration(n, o + 1), m = Ui(g, f, !1)), m && (h ? (e.save(), e.translate(p.renderLeft, p.renderTop), e.rotate(p.angle), this._renderChar(t, e, n, o, y, -_ / 2, 0), e.restore()) : (v = i, this._renderChar(t, e, n, o, y, v, r)), y = "", g = f, i += u * _, _ = 0);
        e.restore();
    }
    _applyPatternGradientTransformText(t) {
        const e = this.width + this.strokeWidth, s = this.height + this.strokeWidth, i = vt({
            width: e,
            height: s
        }), r = i.getContext("2d");
        return i.width = e, i.height = s, r.beginPath(), r.moveTo(0, 0), r.lineTo(e, 0), r.lineTo(e, s), r.lineTo(0, s), r.closePath(), r.translate(e / 2, s / 2), r.fillStyle = t.toLive(r), this._applyPatternGradientTransform(r, t), r.fill(), r.createPattern(i, "no-repeat");
    }
    handleFiller(t, e, s) {
        let i, r;
        return Gt(s) ? "percentage" === s.gradientUnits || s.gradientTransform || s.patternTransform ? (i = -this.width / 2, r = -this.height / 2, t.translate(i, r), t[e] = this._applyPatternGradientTransformText(s), {
            offsetX: i,
            offsetY: r
        }) : (t[e] = s.toLive(t), this._applyPatternGradientTransform(t, s)) : (t[e] = s, {
            offsetX: 0,
            offsetY: 0
        });
    }
    _setStrokeStyles(t, e) {
        let { stroke: s, strokeWidth: i } = e;
        return t.lineWidth = i, t.lineCap = this.strokeLineCap, t.lineDashOffset = this.strokeDashOffset, t.lineJoin = this.strokeLineJoin, t.miterLimit = this.strokeMiterLimit, this.handleFiller(t, "strokeStyle", s);
    }
    _setFillStyles(t, e) {
        let { fill: s } = e;
        return this.handleFiller(t, "fillStyle", s);
    }
    _renderChar(t, e, s, i, r, n, o) {
        const a = this._getStyleDeclaration(s, i), h = this.getCompleteStyleDeclaration(s, i), c = "fillText" === t && h.fill, l = "strokeText" === t && h.stroke && h.strokeWidth;
        if (l || c) {
            if (e.save(), e.font = this._getFontDeclaration(h), a.textBackgroundColor && this._removeShadow(e), a.deltaY && (o += a.deltaY), c) {
                const t = this._setFillStyles(e, h);
                e.fillText(r, n - t.offsetX, o - t.offsetY);
            }
            if (l) {
                const t = this._setStrokeStyles(e, h);
                e.strokeText(r, n - t.offsetX, o - t.offsetY);
            }
            e.restore();
        }
    }
    setSuperscript(t, e) {
        this._setScript(t, e, this.superscript);
    }
    setSubscript(t, e) {
        this._setScript(t, e, this.subscript);
    }
    _setScript(t, e, s) {
        const i = this.get2DCursorLocation(t, !0), r = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "fontSize"), n = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "deltaY"), o = {
            fontSize: r * s.size,
            deltaY: n + r * s.baseline
        };
        this.setSelectionStyles(o, t, e);
    }
    _getLineLeftOffset(t) {
        const e = this.getLineWidth(t), s = this.width - e, i = this.textAlign, r = this.direction, n = this.isEndOfWrapping(t);
        let o = 0;
        return i === qe || i === Qe && !n || i === Je && !n || i === Ke && !n ? 0 : (i === D && (o = s / 2), i === A && (o = s), i === Qe && (o = s / 2), i === Je && (o = s), "rtl" === r && (i === A || i === qe || i === Je ? o = 0 : i === M || i === Ke ? o = -s : i !== D && i !== Qe || (o = -s / 2)), o);
    }
    _clearCache() {
        this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
    }
    getLineWidth(t) {
        if (void 0 !== this.__lineWidths[t]) return this.__lineWidths[t];
        const { width: e } = this.measureLine(t);
        return this.__lineWidths[t] = e, e;
    }
    _getWidthOfCharSpacing() {
        return 0 !== this.charSpacing ? this.fontSize * this.charSpacing / 1e3 : 0;
    }
    getValueOfPropertyAt(t, e, s) {
        var i;
        return null !== (i = this._getStyleDeclaration(t, e)[s]) && void 0 !== i ? i : this[s];
    }
    _renderTextDecoration(t, e) {
        if (!this[e] && !this.styleHas(e)) return;
        let s = this._getTopOffset();
        const i = this._getLeftOffset(), r = this.path, n = this._getWidthOfCharSpacing(), o = "linethrough" === e ? .5 : "overline" === e ? 1 : 0, a = this.offsets[e];
        for(let h = 0, c = this._textLines.length; h < c; h++){
            const c = this.getHeightOfLine(h);
            if (!this[e] && !this.styleHas(e, h)) {
                s += c;
                continue;
            }
            const l = this._textLines[h], u = c / this.lineHeight, d = this._getLineLeftOffset(h);
            let g = 0, f = 0, p = this.getValueOfPropertyAt(h, 0, e), m = this.getValueOfPropertyAt(h, 0, K), v = this.getValueOfPropertyAt(h, 0, We), y = p, _ = m, x = v;
            const C = s + u * (1 - this._fontSizeFraction);
            let b = this.getHeightOfChar(h, 0), S = this.getValueOfPropertyAt(h, 0, "deltaY");
            for(let s = 0, n = l.length; s < n; s++){
                const n = this.__charBounds[h][s];
                y = this.getValueOfPropertyAt(h, s, e), _ = this.getValueOfPropertyAt(h, s, K), x = this.getValueOfPropertyAt(h, s, We);
                const c = this.getHeightOfChar(h, s), l = this.getValueOfPropertyAt(h, s, "deltaY");
                if (r && y && _) {
                    const e = this.fontSize * x / 1e3;
                    t.save(), t.fillStyle = m, t.translate(n.renderLeft, n.renderTop), t.rotate(n.angle), t.fillRect(-n.kernedWidth / 2, a * c + l - o * e, n.kernedWidth, e), t.restore();
                } else if ((y !== p || _ !== m || c !== b || x !== v || l !== S) && f > 0) {
                    const e = this.fontSize * v / 1e3;
                    let s = i + d + g;
                    "rtl" === this.direction && (s = this.width - s - f), p && m && v && (t.fillStyle = m, t.fillRect(s, C + a * b + S - o * e, f, e)), g = n.left, f = n.width, p = y, v = x, m = _, b = c, S = l;
                } else f += n.kernedWidth;
            }
            let w = i + d + g;
            "rtl" === this.direction && (w = this.width - w - f), t.fillStyle = _;
            const T = this.fontSize * x / 1e3;
            y && _ && x && t.fillRect(w, C + a * b + S - o * T, f - n, T), s += c;
        }
        this._removeShadow(t);
    }
    _getFontDeclaration() {
        let { fontFamily: t = this.fontFamily, fontStyle: e = this.fontStyle, fontWeight: s = this.fontWeight, fontSize: i = this.fontSize } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
        const n = t.includes("'") || t.includes('"') || t.includes(",") || Eo.genericFonts.includes(t.toLowerCase()) ? t : '"'.concat(t, '"');
        return [
            e,
            s,
            "".concat(r ? this.CACHE_FONT_SIZE : i, "px"),
            n
        ].join(" ");
    }
    render(t) {
        this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(t)));
    }
    graphemeSplit(t) {
        return zi(t);
    }
    _splitTextIntoLines(t) {
        const e = t.split(this._reNewline), s = new Array(e.length), i = [
            "\n"
        ];
        let r = [];
        for(let t = 0; t < e.length; t++)s[t] = this.graphemeSplit(e[t]), r = r.concat(s[t], i);
        return r.pop(), {
            _unwrappedLines: s,
            lines: e,
            graphemeText: r,
            graphemeLines: s
        };
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return s(s({}, super.toObject([
            ...He,
            ...t
        ])), {}, {
            styles: qi(this.styles, this.text)
        }, this.path ? {
            path: this.path.toObject()
        } : {});
    }
    set(t, e) {
        const { textLayoutProperties: s } = this.constructor;
        super.set(t, e);
        let i = !1, r = !1;
        if ("object" == typeof t) for(const e in t)"path" === e && this.setPathInfo(), i = i || s.includes(e), r = r || "path" === e;
        else i = s.includes(t), r = "path" === t;
        return r && this.setPathInfo(), i && this.initialized && (this.initDimensions(), this.setCoords()), this;
    }
    complexity() {
        return 1;
    }
    static async fromElement(t, e, r) {
        const n = Dr(t, Eo.ATTRIBUTE_NAMES, r), o = s(s({}, e), n), { textAnchor: a = M, textDecoration: h = "", dx: c = 0, dy: l = 0, top: u = 0, left: d = 0, fontSize: g = O, strokeWidth: f = 1 } = o, p = i(o, Mo), m = new this((t.textContent || "").replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "), s({
            left: d + c,
            top: u + l,
            underline: h.includes("underline"),
            overline: h.includes("overline"),
            linethrough: h.includes("line-through"),
            strokeWidth: 0,
            fontSize: g
        }, p)), v = m.getScaledHeight() / m.height, y = ((m.height + m.strokeWidth) * m.lineHeight - m.height) * v, _ = m.getScaledHeight() + y;
        let x = 0;
        return a === D && (x = m.getScaledWidth() / 2), a === A && (x = m.getScaledWidth()), m.set({
            left: m.left - x,
            top: m.top - (_ - m.fontSize * (.07 + m._fontSizeFraction)) / m.lineHeight,
            strokeWidth: f
        }), m;
    }
    static fromObject(t) {
        return this._fromObject(s(s({}, t), {}, {
            styles: Ki(t.styles || {}, t.text)
        }), {
            extraParam: "text"
        });
    }
}
t(Eo, "textLayoutProperties", Ge), t(Eo, "cacheProperties", [
    ...Ms,
    ...He
]), t(Eo, "ownDefaults", Ue), t(Eo, "type", "Text"), t(Eo, "genericFonts", [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
]), t(Eo, "ATTRIBUTE_NAMES", Ji.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), Ai(Eo, [
    class extends Xe {
        _toSVG() {
            const t = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(t.textTop, t.textLeft);
            return this._wrapSVGTextAndBg(e);
        }
        toSVG(t) {
            const e = this._createBaseSVGMarkup(this._toSVG(), {
                reviver: t,
                noStyle: !0,
                withShadow: !0
            }), s = this.path;
            return s ? e + s._createBaseSVGMarkup(s._toSVG(), {
                reviver: t,
                withShadow: !0,
                additionalTransform: zt(this.calcOwnMatrix())
            }) : e;
        }
        _getSVGLeftTopOffsets() {
            return {
                textLeft: -this.width / 2,
                textTop: -this.height / 2,
                lineTop: this.getHeightOfLine(0)
            };
        }
        _wrapSVGTextAndBg(t) {
            let { textBgRects: e, textSpans: s } = t;
            const i = this.getSvgTextDecoration(this);
            return [
                e.join(""),
                '\t\t<text xml:space="preserve" ',
                'font-family="'.concat(this.fontFamily.replace(ko, "'"), '" '),
                'font-size="'.concat(this.fontSize, '" '),
                this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "",
                this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "",
                i ? 'text-decoration="'.concat(i, '" ') : "",
                "rtl" === this.direction ? 'direction="'.concat(this.direction, '" ') : "",
                'style="',
                this.getSvgStyles(!0),
                '"',
                this.addPaintOrder(),
                " >",
                s.join(""),
                "</text>\n"
            ];
        }
        _getSVGTextAndBg(t, e) {
            const s = [], i = [];
            let r, n = t;
            this.backgroundColor && i.push(...Do(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
            for(let t = 0, o = this._textLines.length; t < o; t++)r = this._getLineLeftOffset(t), "rtl" === this.direction && (r += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", t)) && this._setSVGTextLineBg(i, t, e + r, n), this._setSVGTextLineText(s, t, e + r, n), n += this.getHeightOfLine(t);
            return {
                textSpans: s,
                textBgRects: i
            };
        }
        _createTextCharSpan(t, e, s, i, r) {
            const n = o.NUM_FRACTION_DIGITS, a = this.getSvgSpanStyles(e, t !== t.trim() || !!t.match(Oo)), h = a ? 'style="'.concat(a, '"') : "", c = e.deltaY, l = c ? ' dy="'.concat(Vt(c, n), '" ') : "", { angle: u, renderLeft: d, renderTop: g, width: f } = r;
            let p = "";
            if (void 0 !== d) {
                const t = f / 2;
                u && (p = ' rotate="'.concat(Vt(Ct(u), n), '"'));
                const e = Pt({
                    angle: Ct(u)
                });
                e[4] = d, e[5] = g;
                const r = new ot(-t, 0).transform(e);
                s = r.x, i = r.y;
            }
            return '<tspan x="'.concat(Vt(s, n), '" y="').concat(Vt(i, n), '" ').concat(l).concat(p).concat(h, ">").concat(Wi(t), "</tspan>");
        }
        _setSVGTextLineText(t, e, s, i) {
            const r = this.getHeightOfLine(e), n = this.textAlign.includes(qe), o = this._textLines[e];
            let a, h, c, l, u, d = "", g = 0;
            i += r * (1 - this._fontSizeFraction) / this.lineHeight;
            for(let r = 0, f = o.length - 1; r <= f; r++)u = r === f || this.charSpacing || this.path, d += o[r], c = this.__charBounds[e][r], 0 === g ? (s += c.kernedWidth - c.width, g += c.width) : g += c.kernedWidth, n && !u && this._reSpaceAndTab.test(o[r]) && (u = !0), u || (a = a || this.getCompleteStyleDeclaration(e, r), h = this.getCompleteStyleDeclaration(e, r + 1), u = Ui(a, h, !0)), u && (l = this._getStyleDeclaration(e, r), t.push(this._createTextCharSpan(d, l, s, i, c)), d = "", a = h, "rtl" === this.direction ? s -= g : s += g, g = 0);
        }
        _setSVGTextLineBg(t, e, s, i) {
            const r = this._textLines[e], n = this.getHeightOfLine(e) / this.lineHeight;
            let o, a = 0, h = 0, c = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
            for(let l = 0; l < r.length; l++){
                const { left: r, width: u, kernedWidth: d } = this.__charBounds[e][l];
                o = this.getValueOfPropertyAt(e, l, "textBackgroundColor"), o !== c ? (c && t.push(...Do(c, s + h, i, a, n)), h = r, a = u, c = o) : a += d;
            }
            o && t.push(...Do(c, s + h, i, a, n));
        }
        _getSVGLineTopOffset(t) {
            let e, s = 0;
            for(e = 0; e < t; e++)s += this.getHeightOfLine(e);
            const i = this.getHeightOfLine(e);
            return {
                lineTop: s,
                offset: (this._fontSizeMult - this._fontSizeFraction) * i / (this.lineHeight * this._fontSizeMult)
            };
        }
        getSvgStyles(t) {
            return "".concat(super.getSvgStyles(t), " text-decoration-thickness: ").concat(Vt(this.textDecorationThickness * this.getObjectScaling().y / 10, o.NUM_FRACTION_DIGITS), "%; white-space: pre;");
        }
        getSvgSpanStyles(t, e) {
            const { fontFamily: s, strokeWidth: i, stroke: r, fill: n, fontSize: a, fontStyle: h, fontWeight: c, deltaY: l, textDecorationThickness: u, linethrough: d, overline: g, underline: f } = t, p = this.getSvgTextDecoration({
                underline: null != f ? f : this.underline,
                overline: null != g ? g : this.overline,
                linethrough: null != d ? d : this.linethrough
            }), m = u || this.textDecorationThickness;
            return [
                r ? Be(J, r) : "",
                i ? "stroke-width: ".concat(i, "; ") : "",
                s ? "font-family: ".concat(s.includes("'") || s.includes('"') ? s : "'".concat(s, "'"), "; ") : "",
                a ? "font-size: ".concat(a, "px; ") : "",
                h ? "font-style: ".concat(h, "; ") : "",
                c ? "font-weight: ".concat(c, "; ") : "",
                p ? "text-decoration: ".concat(p, "; text-decoration-thickness: ").concat(Vt(m * this.getObjectScaling().y / 10, o.NUM_FRACTION_DIGITS), "%; ") : "",
                n ? Be(K, n) : "",
                l ? "baseline-shift: ".concat(-l, "; ") : "",
                e ? "white-space: pre; " : ""
            ].join("");
        }
        getSvgTextDecoration(t) {
            return [
                "overline",
                "underline",
                "line-through"
            ].filter((e)=>t[e.replace("-", "")]).join(" ");
        }
    }
]), tt.setClass(Eo), tt.setSVGClass(Eo);
class Ao {
    constructor(e){
        t(this, "target", void 0), t(this, "__mouseDownInPlace", !1), t(this, "__dragStartFired", !1), t(this, "__isDraggingOver", !1), t(this, "__dragStartSelection", void 0), t(this, "__dragImageDisposer", void 0), t(this, "_dispose", void 0), this.target = e;
        const s = [
            this.target.on("dragenter", this.dragEnterHandler.bind(this)),
            this.target.on("dragover", this.dragOverHandler.bind(this)),
            this.target.on("dragleave", this.dragLeaveHandler.bind(this)),
            this.target.on("dragend", this.dragEndHandler.bind(this)),
            this.target.on("drop", this.dropHandler.bind(this))
        ];
        this._dispose = ()=>{
            s.forEach((t)=>t()), this._dispose = void 0;
        };
    }
    isPointerOverSelection(t) {
        const e = this.target, s = e.getSelectionStartFromPointer(t);
        return e.isEditing && s >= e.selectionStart && s <= e.selectionEnd && e.selectionStart < e.selectionEnd;
    }
    start(t) {
        return this.__mouseDownInPlace = this.isPointerOverSelection(t);
    }
    isActive() {
        return this.__mouseDownInPlace;
    }
    end(t) {
        const e = this.isActive();
        return e && !this.__dragStartFired && (this.target.setCursorByClick(t), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, e;
    }
    getDragStartSelection() {
        return this.__dragStartSelection;
    }
    setDragImage(t, e) {
        var s;
        let { selectionStart: i, selectionEnd: r } = e;
        const n = this.target, o = n.canvas, a = new ot(n.flipX ? -1 : 1, n.flipY ? -1 : 1), h = n._getCursorBoundaries(i), c = new ot(h.left + h.leftOffset, h.top + h.topOffset).multiply(a).transform(n.calcTransformMatrix()), l = o.getScenePoint(t).subtract(c), u = n.getCanvasRetinaScaling(), d = n.getBoundingRect(), g = c.subtract(new ot(d.left, d.top)), f = o.viewportTransform, p = g.add(l).transform(f, !0), m = n.backgroundColor, v = Yi(n.styles);
        n.backgroundColor = "";
        const y = {
            stroke: "transparent",
            fill: "transparent",
            textBackgroundColor: "transparent"
        };
        n.setSelectionStyles(y, 0, i), n.setSelectionStyles(y, r, n.text.length), n.dirty = !0;
        const _ = n.toCanvasElement({
            enableRetinaScaling: o.enableRetinaScaling,
            viewportTransform: !0
        });
        n.backgroundColor = m, n.styles = v, n.dirty = !0, Sn(_, {
            position: "fixed",
            left: "".concat(-_.width, "px"),
            border: j,
            width: "".concat(_.width / u, "px"),
            height: "".concat(_.height / u, "px")
        }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = ()=>{
            _.remove();
        }, Kt(t.target || this.target.hiddenTextarea).body.appendChild(_), null === (s = t.dataTransfer) || void 0 === s || s.setDragImage(_, p.x, p.y);
    }
    onDragStart(t) {
        this.__dragStartFired = !0;
        const e = this.target, i = this.isActive();
        if (i && t.dataTransfer) {
            const i = this.__dragStartSelection = {
                selectionStart: e.selectionStart,
                selectionEnd: e.selectionEnd
            }, r = e._text.slice(i.selectionStart, i.selectionEnd).join(""), n = s({
                text: e.text,
                value: r
            }, i);
            t.dataTransfer.setData("text/plain", r), t.dataTransfer.setData("application/fabric", JSON.stringify({
                value: r,
                styles: e.getSelectionStyles(i.selectionStart, i.selectionEnd, !0)
            })), t.dataTransfer.effectAllowed = "copyMove", this.setDragImage(t, n);
        }
        return e.abortCursorAnimation(), i;
    }
    canDrop(t) {
        if (this.target.editable && !this.target.getActiveControl() && !t.defaultPrevented) {
            if (this.isActive() && this.__dragStartSelection) {
                const e = this.target.getSelectionStartFromPointer(t), s = this.__dragStartSelection;
                return e < s.selectionStart || e > s.selectionEnd;
            }
            return !0;
        }
        return !1;
    }
    targetCanDrop(t) {
        return this.target.canDrop(t);
    }
    dragEnterHandler(t) {
        let { e: e } = t;
        const s = this.targetCanDrop(e);
        !this.__isDraggingOver && s && (this.__isDraggingOver = !0);
    }
    dragOverHandler(t) {
        const { e: e } = t, s = this.targetCanDrop(e);
        !this.__isDraggingOver && s ? this.__isDraggingOver = !0 : this.__isDraggingOver && !s && (this.__isDraggingOver = !1), this.__isDraggingOver && (e.preventDefault(), t.canDrop = !0, t.dropTarget = this.target);
    }
    dragLeaveHandler() {
        (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
    }
    dropHandler(t) {
        var e;
        const { e: s } = t, i = s.defaultPrevented;
        this.__isDraggingOver = !1, s.preventDefault();
        let r = null === (e = s.dataTransfer) || void 0 === e ? void 0 : e.getData("text/plain");
        if (r && !i) {
            const e = this.target, i = e.canvas;
            let n = e.getSelectionStartFromPointer(s);
            const { styles: o } = s.dataTransfer.types.includes("application/fabric") ? JSON.parse(s.dataTransfer.getData("application/fabric")) : {}, a = r[Math.max(0, r.length - 1)], h = 0;
            if (this.__dragStartSelection) {
                const t = this.__dragStartSelection.selectionStart, s = this.__dragStartSelection.selectionEnd;
                n > t && n <= s ? n = t : n > s && (n -= s - t), e.removeChars(t, s), delete this.__dragStartSelection;
            }
            e._reNewline.test(a) && (e._reNewline.test(e._text[n]) || n === e._text.length) && (r = r.trimEnd()), t.didDrop = !0, t.dropTarget = e, e.insertChars(r, o, n), i.setActiveObject(e), e.enterEditing(s), e.selectionStart = Math.min(n + h, e._text.length), e.selectionEnd = Math.min(e.selectionStart + r.length, e._text.length), e.hiddenTextarea.value = e.text, e._updateTextarea(), e.hiddenTextarea.focus(), e.fire(z, {
                index: n + h,
                action: "drop"
            }), i.fire("text:changed", {
                target: e
            }), i.contextTopDirty = !0, i.requestRenderAll();
        }
    }
    dragEndHandler(t) {
        let { e: e } = t;
        if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
            var s;
            const t = this.target, i = this.target.canvas, { selectionStart: r, selectionEnd: n } = this.__dragStartSelection, o = (null === (s = e.dataTransfer) || void 0 === s ? void 0 : s.dropEffect) || j;
            o === j ? (t.selectionStart = r, t.selectionEnd = n, t._updateTextarea(), t.hiddenTextarea.focus()) : (t.clearContextTop(), "move" === o && (t.removeChars(r, n), t.selectionStart = t.selectionEnd = r, t.hiddenTextarea && (t.hiddenTextarea.value = t.text), t._updateTextarea(), t.fire(z, {
                index: r,
                action: "dragend"
            }), i.fire("text:changed", {
                target: t
            }), i.requestRenderAll()), t.exitEditing());
        }
        this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
    }
    dispose() {
        this._dispose && this._dispose();
    }
}
const jo = /[ \n\.,;!\?\-]/;
class Fo extends Eo {
    constructor(){
        super(...arguments), t(this, "_currentCursorOpacity", 1);
    }
    initBehavior() {
        this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
    }
    onDeselect(t) {
        return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(t);
    }
    _animateCursor(t) {
        let { toValue: e, duration: s, delay: i, onComplete: r } = t;
        return Us({
            startValue: this._currentCursorOpacity,
            endValue: e,
            duration: s,
            delay: i,
            onComplete: r,
            abort: ()=>!this.canvas || this.selectionStart !== this.selectionEnd,
            onChange: (t)=>{
                this._currentCursorOpacity = t, this.renderCursorOrSelection();
            }
        });
    }
    _tick(t) {
        this._currentTickState = this._animateCursor({
            toValue: 0,
            duration: this.cursorDuration / 2,
            delay: Math.max(t || 0, 100),
            onComplete: this._onTickComplete
        });
    }
    _onTickComplete() {
        var t;
        null === (t = this._currentTickCompleteState) || void 0 === t || t.abort(), this._currentTickCompleteState = this._animateCursor({
            toValue: 1,
            duration: this.cursorDuration,
            onComplete: this._tick
        });
    }
    initDelayedCursor(t) {
        this.abortCursorAnimation(), this._tick(t ? 0 : this.cursorDelay);
    }
    abortCursorAnimation() {
        let t = !1;
        [
            this._currentTickState,
            this._currentTickCompleteState
        ].forEach((e)=>{
            e && !e.isDone() && (t = !0, e.abort());
        }), this._currentCursorOpacity = 1, t && this.clearContextTop();
    }
    restartCursorIfNeeded() {
        [
            this._currentTickState,
            this._currentTickCompleteState
        ].some((t)=>!t || t.isDone()) && this.initDelayedCursor();
    }
    selectAll() {
        return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
    }
    cmdAll() {
        this.selectAll(), this.renderCursorOrSelection();
    }
    getSelectedText() {
        return this._text.slice(this.selectionStart, this.selectionEnd).join("");
    }
    findWordBoundaryLeft(t) {
        let e = 0, s = t - 1;
        if (this._reSpace.test(this._text[s])) for(; this._reSpace.test(this._text[s]);)e++, s--;
        for(; /\S/.test(this._text[s]) && s > -1;)e++, s--;
        return t - e;
    }
    findWordBoundaryRight(t) {
        let e = 0, s = t;
        if (this._reSpace.test(this._text[s])) for(; this._reSpace.test(this._text[s]);)e++, s++;
        for(; /\S/.test(this._text[s]) && s < this._text.length;)e++, s++;
        return t + e;
    }
    findLineBoundaryLeft(t) {
        let e = 0, s = t - 1;
        for(; !/\n/.test(this._text[s]) && s > -1;)e++, s--;
        return t - e;
    }
    findLineBoundaryRight(t) {
        let e = 0, s = t;
        for(; !/\n/.test(this._text[s]) && s < this._text.length;)e++, s++;
        return t + e;
    }
    searchWordBoundary(t, e) {
        const s = this._text;
        let i = t > 0 && this._reSpace.test(s[t]) && (-1 === e || !F.test(s[t - 1])) ? t - 1 : t, r = s[i];
        for(; i > 0 && i < s.length && !jo.test(r);)i += e, r = s[i];
        return -1 === e && jo.test(r) && i++, i;
    }
    selectWord(t) {
        var e;
        t = null !== (e = t) && void 0 !== e ? e : this.selectionStart;
        const s = this.searchWordBoundary(t, -1), i = Math.max(s, this.searchWordBoundary(t, 1));
        this.selectionStart = s, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
    }
    selectLine(t) {
        var e;
        t = null !== (e = t) && void 0 !== e ? e : this.selectionStart;
        const s = this.findLineBoundaryLeft(t), i = this.findLineBoundaryRight(t);
        this.selectionStart = s, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea();
    }
    enterEditing(t) {
        !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", t ? {
            e: t
        } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", {
            target: this,
            e: t
        }), this.canvas.requestRenderAll()));
    }
    enterEditingImpl() {
        this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
    }
    updateSelectionOnMouseMove(t) {
        if (this.getActiveControl()) return;
        const e = this.hiddenTextarea;
        Kt(e).activeElement !== e && e.focus();
        const s = this.getSelectionStartFromPointer(t), i = this.selectionStart, r = this.selectionEnd;
        (s === this.__selectionStartOnMouseDown && i !== r || i !== s && r !== s) && (s > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = s) : (this.selectionStart = s, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i && this.selectionEnd === r || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
    }
    _setEditingProps() {
        this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
    }
    fromStringToGraphemeSelection(t, e, s) {
        const i = s.slice(0, t), r = this.graphemeSplit(i).length;
        if (t === e) return {
            selectionStart: r,
            selectionEnd: r
        };
        const n = s.slice(t, e);
        return {
            selectionStart: r,
            selectionEnd: r + this.graphemeSplit(n).length
        };
    }
    fromGraphemeToStringSelection(t, e, s) {
        const i = s.slice(0, t).join("").length;
        if (t === e) return {
            selectionStart: i,
            selectionEnd: i
        };
        return {
            selectionStart: i,
            selectionEnd: i + s.slice(t, e).join("").length
        };
    }
    _updateTextarea() {
        if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
            if (!this.inCompositionMode) {
                const t = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
                this.hiddenTextarea.selectionStart = t.selectionStart, this.hiddenTextarea.selectionEnd = t.selectionEnd;
            }
            this.updateTextareaPosition();
        }
    }
    updateFromTextArea() {
        if (!this.hiddenTextarea) return;
        this.cursorOffsetCache = {};
        const t = this.hiddenTextarea;
        this.text = t.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
        const e = this.fromStringToGraphemeSelection(t.selectionStart, t.selectionEnd, t.value);
        this.selectionEnd = this.selectionStart = e.selectionEnd, this.inCompositionMode || (this.selectionStart = e.selectionStart), this.updateTextareaPosition();
    }
    updateTextareaPosition() {
        if (this.selectionStart === this.selectionEnd) {
            const t = this._calcTextareaPosition();
            this.hiddenTextarea.style.left = t.left, this.hiddenTextarea.style.top = t.top;
        }
    }
    _calcTextareaPosition() {
        if (!this.canvas) return {
            left: "1px",
            top: "1px"
        };
        const t = this.inCompositionMode ? this.compositionStart : this.selectionStart, e = this._getCursorBoundaries(t), s = this.get2DCursorLocation(t), i = s.lineIndex, r = s.charIndex, n = this.getValueOfPropertyAt(i, r, "fontSize") * this.lineHeight, o = e.leftOffset, a = this.getCanvasRetinaScaling(), h = this.canvas.upperCanvasEl, c = h.width / a, l = h.height / a, u = c - n, d = l - n, g = new ot(e.left + o, e.top + e.topOffset + n).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new ot(h.clientWidth / c, h.clientHeight / l));
        return g.x < 0 && (g.x = 0), g.x > u && (g.x = u), g.y < 0 && (g.y = 0), g.y > d && (g.y = d), g.x += this.canvas._offset.left, g.y += this.canvas._offset.top, {
            left: "".concat(g.x, "px"),
            top: "".concat(g.y, "px"),
            fontSize: "".concat(n, "px"),
            charHeight: n
        };
    }
    _saveEditingProps() {
        this._savedProps = {
            hasControls: this.hasControls,
            borderColor: this.borderColor,
            lockMovementX: this.lockMovementX,
            lockMovementY: this.lockMovementY,
            hoverCursor: this.hoverCursor,
            selectable: this.selectable,
            defaultCursor: this.canvas && this.canvas.defaultCursor,
            moveCursor: this.canvas && this.canvas.moveCursor
        };
    }
    _restoreEditingProps() {
        this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
    }
    _exitEditing() {
        const t = this.hiddenTextarea;
        this.selected = !1, this.isEditing = !1, t && (t.blur && t.blur(), t.parentNode && t.parentNode.removeChild(t)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
    }
    exitEditingImpl() {
        this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
    }
    exitEditing() {
        const t = this._textBeforeEdit !== this.text;
        return this.exitEditingImpl(), this.fire("editing:exited"), t && this.fire(Q), this.canvas && (this.canvas.fire("text:editing:exited", {
            target: this
        }), t && this.canvas.fire("object:modified", {
            target: this
        })), this;
    }
    _removeExtraneousStyles() {
        for(const t in this.styles)this._textLines[t] || delete this.styles[t];
    }
    removeStyleFromTo(t, e) {
        const { lineIndex: s, charIndex: i } = this.get2DCursorLocation(t, !0), { lineIndex: r, charIndex: n } = this.get2DCursorLocation(e, !0);
        if (s !== r) {
            if (this.styles[s]) for(let t = i; t < this._unwrappedTextLines[s].length; t++)delete this.styles[s][t];
            if (this.styles[r]) for(let t = n; t < this._unwrappedTextLines[r].length; t++){
                const e = this.styles[r][t];
                e && (this.styles[s] || (this.styles[s] = {}), this.styles[s][i + t - n] = e);
            }
            for(let t = s + 1; t <= r; t++)delete this.styles[t];
            this.shiftLineStyles(r, s - r);
        } else if (this.styles[s]) {
            const t = this.styles[s], e = n - i;
            for(let e = i; e < n; e++)delete t[e];
            for(const i in this.styles[s]){
                const s = parseInt(i, 10);
                s >= n && (t[s - e] = t[i], delete t[i]);
            }
        }
    }
    shiftLineStyles(t, e) {
        const s = Object.assign({}, this.styles);
        for(const i in this.styles){
            const r = parseInt(i, 10);
            r > t && (this.styles[r + e] = s[r], s[r - e] || delete this.styles[r]);
        }
    }
    insertNewlineStyleObject(t, e, i, r) {
        const n = {}, o = this._unwrappedTextLines[t].length, a = o === e;
        let h = !1;
        i || (i = 1), this.shiftLineStyles(t, i);
        const c = this.styles[t] ? this.styles[t][0 === e ? e : e - 1] : void 0;
        for(const s in this.styles[t]){
            const i = parseInt(s, 10);
            i >= e && (h = !0, n[i - e] = this.styles[t][s], a && 0 === e || delete this.styles[t][s]);
        }
        let l = !1;
        for(h && !a && (this.styles[t + i] = n, l = !0), (l || o > e) && i--; i > 0;)r && r[i - 1] ? this.styles[t + i] = {
            0: s({}, r[i - 1])
        } : c ? this.styles[t + i] = {
            0: s({}, c)
        } : delete this.styles[t + i], i--;
        this._forceClearCache = !0;
    }
    insertCharStyleObject(t, e, i, r) {
        this.styles || (this.styles = {});
        const n = this.styles[t], o = n ? s({}, n) : {};
        i || (i = 1);
        for(const t in o){
            const s = parseInt(t, 10);
            s >= e && (n[s + i] = o[s], o[s - i] || delete n[s]);
        }
        if (this._forceClearCache = !0, r) {
            for(; i--;)Object.keys(r[i]).length && (this.styles[t] || (this.styles[t] = {}), this.styles[t][e + i] = s({}, r[i]));
            return;
        }
        if (!n) return;
        const a = n[e ? e - 1 : 1];
        for(; a && i--;)this.styles[t][e + i] = s({}, a);
    }
    insertNewStyleBlock(t, e, s) {
        const i = this.get2DCursorLocation(e, !0), r = [
            0
        ];
        let n, o = 0;
        for(let e = 0; e < t.length; e++)"\n" === t[e] ? (o++, r[o] = 0) : r[o]++;
        for(r[0] > 0 && (this.insertCharStyleObject(i.lineIndex, i.charIndex, r[0], s), s = s && s.slice(r[0] + 1)), o && this.insertNewlineStyleObject(i.lineIndex, i.charIndex + r[0], o), n = 1; n < o; n++)r[n] > 0 ? this.insertCharStyleObject(i.lineIndex + n, 0, r[n], s) : s && this.styles[i.lineIndex + n] && s[0] && (this.styles[i.lineIndex + n][0] = s[0]), s = s && s.slice(r[n] + 1);
        r[n] > 0 && this.insertCharStyleObject(i.lineIndex + n, 0, r[n], s);
    }
    removeChars(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t + 1;
        this.removeStyleFromTo(t, e), this._text.splice(t, e - t), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
    }
    insertChars(t, e, s) {
        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : s;
        i > s && this.removeStyleFromTo(s, i);
        const r = this.graphemeSplit(t);
        this.insertNewStyleBlock(r, s, e), this._text = [
            ...this._text.slice(0, s),
            ...r,
            ...this._text.slice(i)
        ], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
    }
    setSelectionStartEndWithShift(t, e, s) {
        s <= t ? (e === t ? this._selectionDirection = M : this._selectionDirection === A && (this._selectionDirection = M, this.selectionEnd = t), this.selectionStart = s) : s > t && s < e ? this._selectionDirection === A ? this.selectionEnd = s : this.selectionStart = s : (e === t ? this._selectionDirection = A : this._selectionDirection === M && (this._selectionDirection = A, this.selectionStart = e), this.selectionEnd = s);
    }
}
class Lo extends Fo {
    initHiddenTextarea() {
        const t = this.canvas && Kt(this.canvas.getElement()) || m(), e = t.createElement("textarea");
        Object.entries({
            autocapitalize: "off",
            autocorrect: "off",
            autocomplete: "off",
            spellcheck: "false",
            "data-fabric": "textarea",
            wrap: "off"
        }).map((t)=>{
            let [s, i] = t;
            return e.setAttribute(s, i);
        });
        const { top: s, left: i, fontSize: r } = this._calcTextareaPosition();
        e.style.cssText = "position: absolute; top: ".concat(s, "; left: ").concat(i, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(r, ";"), (this.hiddenTextareaContainer || t.body).appendChild(e), Object.entries({
            blur: "blur",
            keydown: "onKeyDown",
            keyup: "onKeyUp",
            input: "onInput",
            copy: "copy",
            cut: "copy",
            paste: "paste",
            compositionstart: "onCompositionStart",
            compositionupdate: "onCompositionUpdate",
            compositionend: "onCompositionEnd"
        }).map((t)=>{
            let [s, i] = t;
            return e.addEventListener(s, this[i].bind(this));
        }), this.hiddenTextarea = e;
    }
    blur() {
        this.abortCursorAnimation();
    }
    onKeyDown(t) {
        if (!this.isEditing) return;
        const e = "rtl" === this.direction ? this.keysMapRtl : this.keysMap;
        if (t.keyCode in e) this[e[t.keyCode]](t);
        else {
            if (!(t.keyCode in this.ctrlKeysMapDown) || !t.ctrlKey && !t.metaKey) return;
            this[this.ctrlKeysMapDown[t.keyCode]](t);
        }
        t.stopImmediatePropagation(), t.preventDefault(), t.keyCode >= 33 && t.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
    }
    onKeyUp(t) {
        !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : t.keyCode in this.ctrlKeysMapUp && (t.ctrlKey || t.metaKey) && (this[this.ctrlKeysMapUp[t.keyCode]](t), t.stopImmediatePropagation(), t.preventDefault(), this.canvas && this.canvas.requestRenderAll());
    }
    onInput(t) {
        const e = this.fromPaste, { value: s, selectionStart: i, selectionEnd: r } = this.hiddenTextarea;
        if (this.fromPaste = !1, t && t.stopPropagation(), !this.isEditing) return;
        const n = ()=>{
            this.updateFromTextArea(), this.fire(z), this.canvas && (this.canvas.fire("text:changed", {
                target: this
            }), this.canvas.requestRenderAll());
        };
        if ("" === this.hiddenTextarea.value) return this.styles = {}, void n();
        const a = this._splitTextIntoLines(s).graphemeText, h = this._text.length, c = a.length, l = this.selectionStart, u = this.selectionEnd, d = l !== u;
        let g, f, m, v, y = c - h;
        const _ = this.fromStringToGraphemeSelection(i, r, s), x = l > _.selectionStart;
        d ? (f = this._text.slice(l, u), y += u - l) : c < h && (f = x ? this._text.slice(u + y, u) : this._text.slice(l, l - y));
        const C = a.slice(_.selectionEnd - y, _.selectionEnd);
        if (f && f.length && (C.length && (g = this.getSelectionStyles(l, l + 1, !1), g = C.map(()=>g[0])), d ? (m = l, v = u) : x ? (m = u - f.length, v = u) : (m = u, v = u + f.length), this.removeStyleFromTo(m, v)), C.length) {
            const { copyPasteData: t } = p();
            e && C.join("") === t.copiedText && !o.disableStyleCopyPaste && (g = t.copiedTextStyle), this.insertNewStyleBlock(C, l, g);
        }
        n();
    }
    onCompositionStart() {
        this.inCompositionMode = !0;
    }
    onCompositionEnd() {
        this.inCompositionMode = !1;
    }
    onCompositionUpdate(t) {
        let { target: e } = t;
        const { selectionStart: s, selectionEnd: i } = e;
        this.compositionStart = s, this.compositionEnd = i, this.updateTextareaPosition();
    }
    copy() {
        if (this.selectionStart === this.selectionEnd) return;
        const { copyPasteData: t } = p();
        t.copiedText = this.getSelectedText(), o.disableStyleCopyPaste ? t.copiedTextStyle = void 0 : t.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
    }
    paste() {
        this.fromPaste = !0;
    }
    _getWidthBeforeCursor(t, e) {
        let s, i = this._getLineLeftOffset(t);
        return e > 0 && (s = this.__charBounds[t][e - 1], i += s.left + s.width), i;
    }
    getDownCursorOffset(t, e) {
        const s = this._getSelectionForOffset(t, e), i = this.get2DCursorLocation(s), r = i.lineIndex;
        if (r === this._textLines.length - 1 || t.metaKey || 34 === t.keyCode) return this._text.length - s;
        const n = i.charIndex, o = this._getWidthBeforeCursor(r, n), a = this._getIndexOnLine(r + 1, o);
        return this._textLines[r].slice(n).length + a + 1 + this.missingNewlineOffset(r);
    }
    _getSelectionForOffset(t, e) {
        return t.shiftKey && this.selectionStart !== this.selectionEnd && e ? this.selectionEnd : this.selectionStart;
    }
    getUpCursorOffset(t, e) {
        const s = this._getSelectionForOffset(t, e), i = this.get2DCursorLocation(s), r = i.lineIndex;
        if (0 === r || t.metaKey || 33 === t.keyCode) return -s;
        const n = i.charIndex, o = this._getWidthBeforeCursor(r, n), a = this._getIndexOnLine(r - 1, o), h = this._textLines[r].slice(0, n), c = this.missingNewlineOffset(r - 1);
        return -this._textLines[r - 1].length + a - h.length + (1 - c);
    }
    _getIndexOnLine(t, e) {
        const s = this._textLines[t];
        let i, r, n = this._getLineLeftOffset(t), o = 0;
        for(let a = 0, h = s.length; a < h; a++)if (i = this.__charBounds[t][a].width, n += i, n > e) {
            r = !0;
            const t = n - i, s = n, h = Math.abs(t - e);
            o = Math.abs(s - e) < h ? a : a - 1;
            break;
        }
        return r || (o = s.length - 1), o;
    }
    moveCursorDown(t) {
        this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", t);
    }
    moveCursorUp(t) {
        0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorUpOrDown("Up", t);
    }
    _moveCursorUpOrDown(t, e) {
        const s = this["get".concat(t, "CursorOffset")](e, this._selectionDirection === A);
        if (e.shiftKey ? this.moveCursorWithShift(s) : this.moveCursorWithoutShift(s), 0 !== s) {
            const t = this.text.length;
            this.selectionStart = ks(0, this.selectionStart, t), this.selectionEnd = ks(0, this.selectionEnd, t), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
        }
    }
    moveCursorWithShift(t) {
        const e = this._selectionDirection === M ? this.selectionStart + t : this.selectionEnd + t;
        return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e), 0 !== t;
    }
    moveCursorWithoutShift(t) {
        return t < 0 ? (this.selectionStart += t, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t, this.selectionStart = this.selectionEnd), 0 !== t;
    }
    moveCursorLeft(t) {
        0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorLeftOrRight("Left", t);
    }
    _move(t, e, s) {
        let i;
        if (t.altKey) i = this["findWordBoundary".concat(s)](this[e]);
        else {
            if (!t.metaKey && 35 !== t.keyCode && 36 !== t.keyCode) return this[e] += "Left" === s ? -1 : 1, !0;
            i = this["findLineBoundary".concat(s)](this[e]);
        }
        return void 0 !== i && this[e] !== i && (this[e] = i, !0);
    }
    _moveLeft(t, e) {
        return this._move(t, e, "Left");
    }
    _moveRight(t, e) {
        return this._move(t, e, "Right");
    }
    moveCursorLeftWithoutShift(t) {
        let e = !0;
        return this._selectionDirection = M, this.selectionEnd === this.selectionStart && 0 !== this.selectionStart && (e = this._moveLeft(t, "selectionStart")), this.selectionEnd = this.selectionStart, e;
    }
    moveCursorLeftWithShift(t) {
        return this._selectionDirection === A && this.selectionStart !== this.selectionEnd ? this._moveLeft(t, "selectionEnd") : 0 !== this.selectionStart ? (this._selectionDirection = M, this._moveLeft(t, "selectionStart")) : void 0;
    }
    moveCursorRight(t) {
        this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", t);
    }
    _moveCursorLeftOrRight(t, e) {
        const s = "moveCursor".concat(t).concat(e.shiftKey ? "WithShift" : "WithoutShift");
        this._currentCursorOpacity = 1, this[s](e) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
    }
    moveCursorRightWithShift(t) {
        return this._selectionDirection === M && this.selectionStart !== this.selectionEnd ? this._moveRight(t, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = A, this._moveRight(t, "selectionEnd")) : void 0;
    }
    moveCursorRightWithoutShift(t) {
        let e = !0;
        return this._selectionDirection = A, this.selectionStart === this.selectionEnd ? (e = this._moveRight(t, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e;
    }
}
const Ro = (t)=>!!t.button;
class Io extends Lo {
    constructor(){
        super(...arguments), t(this, "draggableTextDelegate", void 0);
    }
    initBehavior() {
        this.on("mousedown", this._mouseDownHandler), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("mousetripleclick", this.tripleClickHandler), this.draggableTextDelegate = new Ao(this), super.initBehavior();
    }
    shouldStartDragging() {
        return this.draggableTextDelegate.isActive();
    }
    onDragStart(t) {
        return this.draggableTextDelegate.onDragStart(t);
    }
    canDrop(t) {
        return this.draggableTextDelegate.canDrop(t);
    }
    doubleClickHandler(t) {
        this.isEditing && (this.selectWord(this.getSelectionStartFromPointer(t.e)), this.renderCursorOrSelection());
    }
    tripleClickHandler(t) {
        this.isEditing && (this.selectLine(this.getSelectionStartFromPointer(t.e)), this.renderCursorOrSelection());
    }
    _mouseDownHandler(t) {
        let { e: e, alreadySelected: s } = t;
        this.canvas && this.editable && !Ro(e) && !this.getActiveControl() && (this.draggableTextDelegate.start(e) || (this.canvas.textEditingManager.register(this), s && (this.inCompositionMode = !1, this.setCursorByClick(e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()), this.selected || (this.selected = s || this.isEditing)));
    }
    mouseUpHandler(t) {
        let { e: e, transform: s } = t;
        const i = this.draggableTextDelegate.end(e);
        if (this.canvas) {
            this.canvas.textEditingManager.unregister(this);
            const t = this.canvas._activeObject;
            if (t && t !== this) return;
        }
        !this.editable || this.group && !this.group.interactive || s && s.actionPerformed || Ro(e) || i || this.selected && !this.getActiveControl() && (this.enterEditing(e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection());
    }
    setCursorByClick(t) {
        const e = this.getSelectionStartFromPointer(t), s = this.selectionStart, i = this.selectionEnd;
        t.shiftKey ? this.setSelectionStartEndWithShift(s, i, e) : (this.selectionStart = e, this.selectionEnd = e), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
    }
    getSelectionStartFromPointer(t) {
        const e = this.canvas.getScenePoint(t).transform(wt(this.calcTransformMatrix())).add(new ot(-this._getLeftOffset(), -this._getTopOffset()));
        let s = 0, i = 0, r = 0;
        for(let t = 0; t < this._textLines.length && s <= e.y; t++)s += this.getHeightOfLine(t), r = t, t > 0 && (i += this._textLines[t - 1].length + this.missingNewlineOffset(t - 1));
        let n = Math.abs(this._getLineLeftOffset(r));
        const o = this._textLines[r].length, a = this.__charBounds[r];
        for(let t = 0; t < o; t++){
            const s = n + a[t].kernedWidth;
            if (e.x <= s) {
                Math.abs(e.x - s) <= Math.abs(e.x - n) && i++;
                break;
            }
            n = s, i++;
        }
        return Math.min(this.flipX ? o - i : i, this._text.length);
    }
}
const Bo = "moveCursorUp", Xo = "moveCursorDown", Yo = "moveCursorLeft", Wo = "moveCursorRight", Vo = "exitEditing", zo = (t, e)=>{
    const s = e.getRetinaScaling();
    t.setTransform(s, 0, 0, s, 0, 0);
    const i = e.viewportTransform;
    t.transform(i[0], i[1], i[2], i[3], i[4], i[5]);
}, Go = s({
    selectionStart: 0,
    selectionEnd: 0,
    selectionColor: "rgba(17,119,255,0.3)",
    isEditing: !1,
    editable: !0,
    editingBorderColor: "rgba(102,153,255,0.25)",
    cursorWidth: 2,
    cursorColor: "",
    cursorDelay: 1e3,
    cursorDuration: 600,
    caching: !0,
    hiddenTextareaContainer: null,
    keysMap: {
        9: Vo,
        27: Vo,
        33: Bo,
        34: Xo,
        35: Wo,
        36: Yo,
        37: Yo,
        38: Bo,
        39: Wo,
        40: Xo
    },
    keysMapRtl: {
        9: Vo,
        27: Vo,
        33: Bo,
        34: Xo,
        35: Yo,
        36: Wo,
        37: Wo,
        38: Bo,
        39: Yo,
        40: Xo
    },
    ctrlKeysMapDown: {
        65: "cmdAll"
    },
    ctrlKeysMapUp: {
        67: "copy",
        88: "cut"
    }
}, {
    _selectionDirection: null,
    _reSpace: /\s|\r?\n/,
    inCompositionMode: !1
});
class Ho extends Io {
    static getDefaults() {
        return s(s({}, super.getDefaults()), Ho.ownDefaults);
    }
    get type() {
        const t = super.type;
        return "itext" === t ? "i-text" : t;
    }
    constructor(t, e){
        super(t, s(s({}, Ho.ownDefaults), e)), this.initBehavior();
    }
    _set(t, e) {
        return this.isEditing && this._savedProps && t in this._savedProps ? (this._savedProps[t] = e, this) : ("canvas" === t && (this.canvas instanceof In && this.canvas.textEditingManager.remove(this), e instanceof In && e.textEditingManager.add(this)), super._set(t, e));
    }
    setSelectionStart(t) {
        t = Math.max(t, 0), this._updateAndFire("selectionStart", t);
    }
    setSelectionEnd(t) {
        t = Math.min(t, this.text.length), this._updateAndFire("selectionEnd", t);
    }
    _updateAndFire(t, e) {
        this[t] !== e && (this._fireSelectionChanged(), this[t] = e), this._updateTextarea();
    }
    _fireSelectionChanged() {
        this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", {
            target: this
        });
    }
    initDimensions() {
        this.isEditing && this.initDelayedCursor(), super.initDimensions();
    }
    getSelectionStyles() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectionStart || 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selectionEnd, s = arguments.length > 2 ? arguments[2] : void 0;
        return super.getSelectionStyles(t, e, s);
    }
    setSelectionStyles(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selectionStart || 0, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.selectionEnd;
        return super.setSelectionStyles(t, e, s);
    }
    get2DCursorLocation() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectionStart, e = arguments.length > 1 ? arguments[1] : void 0;
        return super.get2DCursorLocation(t, e);
    }
    render(t) {
        super.render(t), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
    }
    toCanvasElement(t) {
        const e = this.isEditing;
        this.isEditing = !1;
        const s = super.toCanvasElement(t);
        return this.isEditing = e, s;
    }
    renderCursorOrSelection() {
        if (!this.isEditing || !this.canvas) return;
        const t = this.clearContextTop(!0);
        if (!t) return;
        const e = this._getCursorBoundaries(), s = this.findAncestorsWithClipPath(), i = s.length > 0;
        let r, n = t;
        if (i) {
            r = vt(t.canvas), n = r.getContext("2d"), zo(n, this.canvas);
            const e = this.calcTransformMatrix();
            n.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
        }
        if (this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(n, e) : this.renderCursor(n, e), i) for (const e of s){
            const s = e.clipPath, i = vt(t.canvas), r = i.getContext("2d");
            if (zo(r, this.canvas), !s.absolutePositioned) {
                const t = e.calcTransformMatrix();
                r.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
            }
            s.transform(r), s.drawObject(r, !0, {}), this.drawClipPathOnCache(n, s, i);
        }
        i && (t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(r, 0, 0)), this.canvas.contextTopDirty = !0, t.restore();
    }
    findAncestorsWithClipPath() {
        const t = [];
        let e = this;
        for(; e;)e.clipPath && t.push(e), e = e.parent;
        return t;
    }
    _getCursorBoundaries() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectionStart, e = arguments.length > 1 ? arguments[1] : void 0;
        const s = this._getLeftOffset(), i = this._getTopOffset(), r = this._getCursorBoundariesOffsets(t, e);
        return {
            left: s,
            top: i,
            leftOffset: r.left,
            topOffset: r.top
        };
    }
    _getCursorBoundariesOffsets(t, e) {
        return e ? this.__getCursorBoundariesOffsets(t) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(t);
    }
    __getCursorBoundariesOffsets(t) {
        let e = 0, s = 0;
        const { charIndex: i, lineIndex: r } = this.get2DCursorLocation(t);
        for(let t = 0; t < r; t++)e += this.getHeightOfLine(t);
        const n = this._getLineLeftOffset(r), o = this.__charBounds[r][i];
        o && (s = o.left), 0 !== this.charSpacing && i === this._textLines[r].length && (s -= this._getWidthOfCharSpacing());
        const a = {
            top: e,
            left: n + (s > 0 ? s : 0)
        };
        return "rtl" === this.direction && (this.textAlign === A || this.textAlign === qe || this.textAlign === Je ? a.left *= -1 : this.textAlign === M || this.textAlign === Ke ? a.left = n - (s > 0 ? s : 0) : this.textAlign !== D && this.textAlign !== Qe || (a.left = n - (s > 0 ? s : 0))), a;
    }
    renderCursorAt(t) {
        this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(t, !0), t);
    }
    renderCursor(t, e) {
        this._renderCursor(t, e, this.selectionStart);
    }
    getCursorRenderingData() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectionStart, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getCursorBoundaries(t);
        const s = this.get2DCursorLocation(t), i = s.lineIndex, r = s.charIndex > 0 ? s.charIndex - 1 : 0, n = this.getValueOfPropertyAt(i, r, "fontSize"), o = this.getObjectScaling().x * this.canvas.getZoom(), a = this.cursorWidth / o, h = this.getValueOfPropertyAt(i, r, "deltaY"), c = e.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(i) / this.lineHeight - n * (1 - this._fontSizeFraction);
        return {
            color: this.cursorColor || this.getValueOfPropertyAt(i, r, "fill"),
            opacity: this._currentCursorOpacity,
            left: e.left + e.leftOffset - a / 2,
            top: c + e.top + h,
            width: a,
            height: n
        };
    }
    _renderCursor(t, e, s) {
        const { color: i, opacity: r, left: n, top: o, width: a, height: h } = this.getCursorRenderingData(s, e);
        t.fillStyle = i, t.globalAlpha = r, t.fillRect(n, o, a, h);
    }
    renderSelection(t, e) {
        const s = {
            selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
            selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd
        };
        this._renderSelection(t, s, e);
    }
    renderDragSourceEffect() {
        const t = this.draggableTextDelegate.getDragStartSelection();
        this._renderSelection(this.canvas.contextTop, t, this._getCursorBoundaries(t.selectionStart, !0));
    }
    renderDropTargetEffect(t) {
        const e = this.getSelectionStartFromPointer(t);
        this.renderCursorAt(e);
    }
    _renderSelection(t, e, s) {
        const i = e.selectionStart, r = e.selectionEnd, n = this.textAlign.includes(qe), o = this.get2DCursorLocation(i), a = this.get2DCursorLocation(r), h = o.lineIndex, c = a.lineIndex, l = o.charIndex < 0 ? 0 : o.charIndex, u = a.charIndex < 0 ? 0 : a.charIndex;
        for(let e = h; e <= c; e++){
            const i = this._getLineLeftOffset(e) || 0;
            let r = this.getHeightOfLine(e), o = 0, a = 0, d = 0;
            if (e === h && (a = this.__charBounds[h][l].left), e >= h && e < c) d = n && !this.isEndOfWrapping(e) ? this.width : this.getLineWidth(e) || 5;
            else if (e === c) if (0 === u) d = this.__charBounds[c][u].left;
            else {
                const t = this._getWidthOfCharSpacing();
                d = this.__charBounds[c][u - 1].left + this.__charBounds[c][u - 1].width - t;
            }
            o = r, (this.lineHeight < 1 || e === c && this.lineHeight > 1) && (r /= this.lineHeight);
            let g = s.left + i + a, f = r, p = 0;
            const m = d - a;
            this.inCompositionMode ? (t.fillStyle = this.compositionColor || "black", f = 1, p = r) : t.fillStyle = this.selectionColor, "rtl" === this.direction && (this.textAlign === A || this.textAlign === qe || this.textAlign === Je ? g = this.width - g - m : this.textAlign === M || this.textAlign === Ke ? g = s.left + i - d : this.textAlign !== D && this.textAlign !== Qe || (g = s.left + i - d)), t.fillRect(g, s.top + s.topOffset + p, m, f), s.topOffset += o;
        }
    }
    getCurrentCharFontSize() {
        const t = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(t.l, t.c, "fontSize");
    }
    getCurrentCharColor() {
        const t = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(t.l, t.c, K);
    }
    _getCurrentCharIndex() {
        const t = this.get2DCursorLocation(this.selectionStart, !0), e = t.charIndex > 0 ? t.charIndex - 1 : 0;
        return {
            l: t.lineIndex,
            c: e
        };
    }
    dispose() {
        this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
    }
}
t(Ho, "ownDefaults", Go), t(Ho, "type", "IText"), tt.setClass(Ho), tt.setClass(Ho, "i-text");
class No extends Ho {
    static getDefaults() {
        return s(s({}, super.getDefaults()), No.ownDefaults);
    }
    constructor(t, e){
        super(t, s(s({}, No.ownDefaults), e));
    }
    static createControls() {
        return {
            controls: Pi()
        };
    }
    initDimensions() {
        this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(qe) && this.enlargeSpaces(), this.height = this.calcTextHeight());
    }
    _generateStyleMap(t) {
        let e = 0, s = 0, i = 0;
        const r = {};
        for(let n = 0; n < t.graphemeLines.length; n++)"\n" === t.graphemeText[i] && n > 0 ? (s = 0, i++, e++) : !this.splitByGrapheme && this._reSpaceAndTab.test(t.graphemeText[i]) && n > 0 && (s++, i++), r[n] = {
            line: e,
            offset: s
        }, i += t.graphemeLines[n].length, s += t.graphemeLines[n].length;
        return r;
    }
    styleHas(t, e) {
        if (this._styleMap && !this.isWrapping) {
            const t = this._styleMap[e];
            t && (e = t.line);
        }
        return super.styleHas(t, e);
    }
    isEmptyStyles(t) {
        if (!this.styles) return !0;
        let e, s = 0, i = t + 1, r = !1;
        const n = this._styleMap[t], o = this._styleMap[t + 1];
        n && (t = n.line, s = n.offset), o && (i = o.line, r = i === t, e = o.offset);
        const a = void 0 === t ? this.styles : {
            line: this.styles[t]
        };
        for(const t in a)for(const i in a[t]){
            const n = parseInt(i, 10);
            if (n >= s && (!r || n < e)) for(const e in a[t][i])return !1;
        }
        return !0;
    }
    _getStyleDeclaration(t, e) {
        if (this._styleMap && !this.isWrapping) {
            const s = this._styleMap[t];
            if (!s) return {};
            t = s.line, e = s.offset + e;
        }
        return super._getStyleDeclaration(t, e);
    }
    _setStyleDeclaration(t, e, s) {
        const i = this._styleMap[t];
        super._setStyleDeclaration(i.line, i.offset + e, s);
    }
    _deleteStyleDeclaration(t, e) {
        const s = this._styleMap[t];
        super._deleteStyleDeclaration(s.line, s.offset + e);
    }
    _getLineStyle(t) {
        const e = this._styleMap[t];
        return !!this.styles[e.line];
    }
    _setLineStyle(t) {
        const e = this._styleMap[t];
        super._setLineStyle(e.line);
    }
    _wrapText(t, e) {
        this.isWrapping = !0;
        const s = this.getGraphemeDataForRender(t), i = [];
        for(let t = 0; t < s.wordsData.length; t++)i.push(...this._wrapLine(t, e, s));
        return this.isWrapping = !1, i;
    }
    getGraphemeDataForRender(t) {
        const e = this.splitByGrapheme, s = e ? "" : " ";
        let i = 0;
        return {
            wordsData: t.map((t, r)=>{
                let n = 0;
                const o = e ? this.graphemeSplit(t) : this.wordSplit(t);
                return 0 === o.length ? [
                    {
                        word: [],
                        width: 0
                    }
                ] : o.map((t)=>{
                    const o = e ? [
                        t
                    ] : this.graphemeSplit(t), a = this._measureWord(o, r, n);
                    return i = Math.max(a, i), n += o.length + s.length, {
                        word: o,
                        width: a
                    };
                });
            }),
            largestWordWidth: i
        };
    }
    _measureWord(t, e) {
        let s, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = 0;
        for(let n = 0, o = t.length; n < o; n++){
            r += this._getGraphemeBox(t[n], e, n + i, s, true).kernedWidth, s = t[n];
        }
        return r;
    }
    wordSplit(t) {
        return t.split(this._wordJoiners);
    }
    _wrapLine(t, e, s) {
        let { largestWordWidth: i, wordsData: r } = s, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        const o = this._getWidthOfCharSpacing(), a = this.splitByGrapheme, h = [], c = a ? "" : " ";
        let l = 0, u = [], d = 0, g = 0, f = !0;
        e -= n;
        const p = Math.max(e, i, this.dynamicMinWidth), m = r[t];
        let v;
        for(d = 0, v = 0; v < m.length; v++){
            const { word: e, width: s } = m[v];
            d += e.length, l += g + s - o, l > p && !f ? (h.push(u), u = [], l = s, f = !0) : l += o, f || a || u.push(c), u = u.concat(e), g = a ? 0 : this._measureWord([
                c
            ], t, d), d++, f = !1;
        }
        return v && h.push(u), i + n > this.dynamicMinWidth && (this.dynamicMinWidth = i - o + n), h;
    }
    isEndOfWrapping(t) {
        return !this._styleMap[t + 1] || this._styleMap[t + 1].line !== this._styleMap[t].line;
    }
    missingNewlineOffset(t, e) {
        return this.splitByGrapheme && !e ? this.isEndOfWrapping(t) ? 1 : 0 : 1;
    }
    _splitTextIntoLines(t) {
        const e = super._splitTextIntoLines(t), s = this._wrapText(e.lines, this.width), i = new Array(s.length);
        for(let t = 0; t < s.length; t++)i[t] = s[t].join("");
        return e.lines = i, e.graphemeLines = s, e;
    }
    getMinWidth() {
        return Math.max(this.minWidth, this.dynamicMinWidth);
    }
    _removeExtraneousStyles() {
        const t = new Map;
        for(const e in this._styleMap){
            const s = parseInt(e, 10);
            if (this._textLines[s]) {
                const s = this._styleMap[e].line;
                t.set("".concat(s), !0);
            }
        }
        for(const e in this.styles)t.has(e) || delete this.styles[e];
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return super.toObject([
            "minWidth",
            "splitByGrapheme",
            ...t
        ]);
    }
}
t(No, "type", "Textbox"), t(No, "textLayoutProperties", [
    ...Ho.textLayoutProperties,
    "width"
]), t(No, "ownDefaults", {
    minWidth: 20,
    dynamicMinWidth: 2,
    lockScalingFlip: !0,
    noScaleCache: !1,
    _wordJoiners: /[ \t\r]/,
    splitByGrapheme: !1
}), tt.setClass(No);
class Uo extends Ir {
    shouldPerformLayout(t) {
        return !!t.target.clipPath && super.shouldPerformLayout(t);
    }
    shouldLayoutClipPath() {
        return !1;
    }
    calcLayoutResult(t, e) {
        const { target: s } = t, { clipPath: i, group: r } = s;
        if (!i || !this.shouldPerformLayout(t)) return;
        const { width: n, height: o } = ae(Rr(s, i)), a = new ot(n, o);
        if (i.absolutePositioned) {
            return {
                center: pe(i.getRelativeCenterPoint(), void 0, r ? r.calcTransformMatrix() : void 0),
                size: a
            };
        }
        {
            const r = i.getRelativeCenterPoint().transform(s.calcOwnMatrix(), !0);
            if (this.shouldPerformLayout(t)) {
                const { center: s = new ot, correction: i = new ot } = this.calcBoundingBox(e, t) || {};
                return {
                    center: s.add(r),
                    correction: i.subtract(r),
                    size: a
                };
            }
            return {
                center: s.getRelativeCenterPoint().add(r),
                size: a
            };
        }
    }
}
t(Uo, "type", "clip-path"), tt.setClass(Uo);
class qo extends Ir {
    getInitialSize(t, e) {
        let { target: s } = t, { size: i } = e;
        return new ot(s.width || i.x, s.height || i.y);
    }
}
t(qo, "type", "fixed"), tt.setClass(qo);
class Ko extends Vr {
    subscribeTargets(t) {
        const e = t.target;
        t.targets.reduce((t, e)=>(e.parent && t.add(e.parent), t), new Set).forEach((t)=>{
            t.layoutManager.subscribeTargets({
                target: t,
                targets: [
                    e
                ]
            });
        });
    }
    unsubscribeTargets(t) {
        const e = t.target, s = e.getObjects();
        t.targets.reduce((t, e)=>(e.parent && t.add(e.parent), t), new Set).forEach((t)=>{
            !s.some((e)=>e.parent === t) && t.layoutManager.unsubscribeTargets({
                target: t,
                targets: [
                    e
                ]
            });
        });
    }
}
class Jo extends Hr {
    static getDefaults() {
        return s(s({}, super.getDefaults()), Jo.ownDefaults);
    }
    constructor(){
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(), Object.assign(this, Jo.ownDefaults), this.setOptions(e);
        const { left: s, top: i, layoutManager: r } = e;
        this.groupInit(t, {
            left: s,
            top: i,
            layoutManager: null != r ? r : new Ko
        });
    }
    _shouldSetNestedCoords() {
        return !0;
    }
    __objectSelectionMonitor() {}
    multiSelectAdd() {
        for(var t = arguments.length, e = new Array(t), s = 0; s < t; s++)e[s] = arguments[s];
        "selection-order" === this.multiSelectionStacking ? this.add(...e) : e.forEach((t)=>{
            const e = this._objects.findIndex((e)=>e.isInFrontOf(t)), s = -1 === e ? this.size() : e;
            this.insertAt(s, t);
        });
    }
    canEnterGroup(t) {
        return this.getObjects().some((e)=>e.isDescendantOf(t) || t.isDescendantOf(e)) ? (a("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(t);
    }
    enterGroup(t, e) {
        t.parent && t.parent === t.group ? t.parent._exitGroup(t) : t.group && t.parent !== t.group && t.group.remove(t), this._enterGroup(t, e);
    }
    exitGroup(t, e) {
        this._exitGroup(t, e), t.parent && t.parent._enterGroup(t, !0);
    }
    _onAfterObjectsChange(t, e) {
        super._onAfterObjectsChange(t, e);
        const s = new Set;
        e.forEach((t)=>{
            const { parent: e } = t;
            e && s.add(e);
        }), t === Fr ? s.forEach((t)=>{
            t._onAfterObjectsChange(jr, e);
        }) : s.forEach((t)=>{
            t._set("dirty", !0);
        });
    }
    onDeselect() {
        return this.removeAll(), !1;
    }
    toString() {
        return "#<ActiveSelection: (".concat(this.complexity(), ")>");
    }
    shouldCache() {
        return !1;
    }
    isOnACache() {
        return !1;
    }
    _renderControls(t, e, i) {
        t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
        const r = s(s({
            hasControls: !1
        }, i), {}, {
            forActiveSelection: !0
        });
        for(let e = 0; e < this._objects.length; e++)this._objects[e]._renderControls(t, r);
        super._renderControls(t, e), t.restore();
    }
}
t(Jo, "type", "ActiveSelection"), t(Jo, "ownDefaults", {
    multiSelectionStacking: "canvas-stacking"
}), tt.setClass(Jo), tt.setClass(Jo, "activeSelection");
class Qo {
    constructor(){
        t(this, "resources", {});
    }
    applyFilters(t, e, s, i, r) {
        const n = r.getContext("2d");
        if (!n) return;
        n.drawImage(e, 0, 0, s, i);
        const o = {
            sourceWidth: s,
            sourceHeight: i,
            imageData: n.getImageData(0, 0, s, i),
            originalEl: e,
            originalImageData: n.getImageData(0, 0, s, i),
            canvasEl: r,
            ctx: n,
            filterBackend: this
        };
        t.forEach((t)=>{
            t.applyTo(o);
        });
        const { imageData: a } = o;
        return a.width === s && a.height === i || (r.width = a.width, r.height = a.height), n.putImageData(a, 0, 0), o;
    }
}
class Zo {
    constructor(){
        let { tileSize: e = o.textureSize } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        t(this, "aPosition", new Float32Array([
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ])), t(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
    }
    setupGLContext(t, e) {
        this.dispose(), this.createWebGLCanvas(t, e);
    }
    createWebGLCanvas(t, e) {
        const s = vt({
            width: t,
            height: e
        }), i = s.getContext("webgl", {
            alpha: !0,
            premultipliedAlpha: !1,
            depth: !1,
            stencil: !1,
            antialias: !1
        });
        i && (i.clearColor(0, 0, 0, 0), this.canvas = s, this.gl = i);
    }
    applyFilters(t, e, s, i, r, n) {
        const o = this.gl, a = r.getContext("2d");
        if (!o || !a) return;
        let h;
        n && (h = this.getCachedTexture(n, e));
        const c = {
            originalWidth: e.width || e.naturalWidth || 0,
            originalHeight: e.height || e.naturalHeight || 0,
            sourceWidth: s,
            sourceHeight: i,
            destinationWidth: s,
            destinationHeight: i,
            context: o,
            sourceTexture: this.createTexture(o, s, i, h ? void 0 : e),
            targetTexture: this.createTexture(o, s, i),
            originalTexture: h || this.createTexture(o, s, i, h ? void 0 : e),
            passes: t.length,
            webgl: !0,
            aPosition: this.aPosition,
            programCache: this.programCache,
            pass: 0,
            filterBackend: this,
            targetCanvas: r
        }, l = o.createFramebuffer();
        return o.bindFramebuffer(o.FRAMEBUFFER, l), t.forEach((t)=>{
            t && t.applyTo(c);
        }), function(t) {
            const e = t.targetCanvas, s = e.width, i = e.height, r = t.destinationWidth, n = t.destinationHeight;
            s === r && i === n || (e.width = r, e.height = n);
        }(c), this.copyGLTo2D(o, c), o.bindTexture(o.TEXTURE_2D, null), o.deleteTexture(c.sourceTexture), o.deleteTexture(c.targetTexture), o.deleteFramebuffer(l), a.setTransform(1, 0, 0, 1, 0, 0), c;
    }
    dispose() {
        this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
    }
    clearWebGLCaches() {
        this.programCache = {}, this.textureCache = {};
    }
    createTexture(t, e, s, i, r) {
        const { NEAREST: n, TEXTURE_2D: o, RGBA: a, UNSIGNED_BYTE: h, CLAMP_TO_EDGE: c, TEXTURE_MAG_FILTER: l, TEXTURE_MIN_FILTER: u, TEXTURE_WRAP_S: d, TEXTURE_WRAP_T: g } = t, f = t.createTexture();
        return t.bindTexture(o, f), t.texParameteri(o, l, r || n), t.texParameteri(o, u, r || n), t.texParameteri(o, d, c), t.texParameteri(o, g, c), i ? t.texImage2D(o, 0, a, a, h, i) : t.texImage2D(o, 0, a, e, s, 0, a, h, null), f;
    }
    getCachedTexture(t, e, s) {
        const { textureCache: i } = this;
        if (i[t]) return i[t];
        {
            const r = this.createTexture(this.gl, e.width, e.height, e, s);
            return r && (i[t] = r), r;
        }
    }
    evictCachesForKey(t) {
        this.textureCache[t] && (this.gl.deleteTexture(this.textureCache[t]), delete this.textureCache[t]);
    }
    copyGLTo2D(t, e) {
        const s = t.canvas, i = e.targetCanvas, r = i.getContext("2d");
        if (!r) return;
        r.translate(0, i.height), r.scale(1, -1);
        const n = s.height - i.height;
        r.drawImage(s, 0, n, i.width, i.height, 0, 0, i.width, i.height);
    }
    copyGLTo2DPutImageData(t, e) {
        const s = e.targetCanvas.getContext("2d"), i = e.destinationWidth, r = e.destinationHeight, n = i * r * 4;
        if (!s) return;
        const o = new Uint8Array(this.imageBuffer, 0, n), a = new Uint8ClampedArray(this.imageBuffer, 0, n);
        t.readPixels(0, 0, i, r, t.RGBA, t.UNSIGNED_BYTE, o);
        const h = new ImageData(a, i, r);
        s.putImageData(h, 0, 0);
    }
    captureGPUInfo() {
        if (this.gpuInfo) return this.gpuInfo;
        const t = this.gl, e = {
            renderer: "",
            vendor: ""
        };
        if (!t) return e;
        const s = t.getExtension("WEBGL_debug_renderer_info");
        if (s) {
            const i = t.getParameter(s.UNMASKED_RENDERER_WEBGL), r = t.getParameter(s.UNMASKED_VENDOR_WEBGL);
            i && (e.renderer = i.toLowerCase()), r && (e.vendor = r.toLowerCase());
        }
        return this.gpuInfo = e, e;
    }
}
let $o;
function ta() {
    const { WebGLProbe: t } = p();
    return t.queryWebGL(pt()), o.enableGLFiltering && t.isSupported(o.textureSize) ? new Zo({
        tileSize: o.textureSize
    }) : new Qo;
}
function ea() {
    return !$o && (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) && ($o = ta()), $o;
}
function sa(t) {
    $o = t;
}
const ia = [
    "filters",
    "resizeFilter",
    "src",
    "crossOrigin",
    "type"
], ra = [
    "cropX",
    "cropY"
];
class na extends ji {
    static getDefaults() {
        return s(s({}, super.getDefaults()), na.ownDefaults);
    }
    constructor(e, s){
        super(), t(this, "_lastScaleX", 1), t(this, "_lastScaleY", 1), t(this, "_filterScalingX", 1), t(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, na.ownDefaults), this.setOptions(s), this.cacheKey = "texture".concat(ft()), this.setElement("string" == typeof e ? (this.canvas && Kt(this.canvas.getElement()) || m()).getElementById(e) : e, s);
    }
    getElement() {
        return this._element;
    }
    setElement(t) {
        var e;
        let s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = t, this._originalElement = t, this._setWidthHeight(s), null === (e = t.classList) || void 0 === e || e.add(na.CSS_CANVAS), 0 !== this.filters.length && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
    }
    removeTexture(t) {
        const e = ea(!1);
        e instanceof Zo && e.evictCachesForKey(t);
    }
    dispose() {
        super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, [
            "_originalElement",
            "_element",
            "_filteredEl",
            "_cacheCanvas"
        ].forEach((t)=>{
            const e = this[t];
            e && p().dispose(e), this[t] = void 0;
        });
    }
    getCrossOrigin() {
        return this._originalElement && (this._originalElement.crossOrigin || null);
    }
    getOriginalSize() {
        const t = this.getElement();
        return t ? {
            width: t.naturalWidth || t.width,
            height: t.naturalHeight || t.height
        } : {
            width: 0,
            height: 0
        };
    }
    _stroke(t) {
        if (!this.stroke || 0 === this.strokeWidth) return;
        const e = this.width / 2, s = this.height / 2;
        t.beginPath(), t.moveTo(-e, -s), t.lineTo(e, -s), t.lineTo(e, s), t.lineTo(-e, s), t.lineTo(-e, -s), t.closePath();
    }
    toObject() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        const e = [];
        return this.filters.forEach((t)=>{
            t && e.push(t.toObject());
        }), s(s({}, super.toObject([
            ...ra,
            ...t
        ])), {}, {
            src: this.getSrc(),
            crossOrigin: this.getCrossOrigin(),
            filters: e
        }, this.resizeFilter ? {
            resizeFilter: this.resizeFilter.toObject()
        } : {});
    }
    hasCrop() {
        return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
    }
    _toSVG() {
        const t = [], e = this._element, s = -this.width / 2, i = -this.height / 2;
        let r = [], n = [], o = "", a = "";
        if (!e) return [];
        if (this.hasCrop()) {
            const t = ft();
            r.push('<clipPath id="imageCrop_' + t + '">\n', '\t<rect x="' + s + '" y="' + i + '" width="' + this.width + '" height="' + this.height + '" />\n', "</clipPath>\n"), o = ' clip-path="url(#imageCrop_' + t + ')" ';
        }
        if (this.imageSmoothing || (a = ' image-rendering="optimizeSpeed"'), t.push("\t<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(s - this.cropX, '" y="').concat(i - this.cropY, '" width="').concat(e.width || e.naturalWidth, '" height="').concat(e.height || e.naturalHeight, '"').concat(a).concat(o, "></image>\n")), this.stroke || this.strokeDashArray) {
            const t = this.fill;
            this.fill = null, n = [
                '\t<rect x="'.concat(s, '" y="').concat(i, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), '" />\n')
            ], this.fill = t;
        }
        return r = this.paintFirst !== K ? r.concat(n, t) : r.concat(t, n), r;
    }
    getSrc(t) {
        const e = t ? this._element : this._originalElement;
        return e ? e.toDataURL ? e.toDataURL() : this.srcFromAttribute ? e.getAttribute("src") || "" : e.src : this.src || "";
    }
    getSvgSrc(t) {
        return this.getSrc(t);
    }
    setSrc(t) {
        let { crossOrigin: e, signal: s } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return It(t, {
            crossOrigin: e,
            signal: s
        }).then((t)=>{
            void 0 !== e && this.set({
                crossOrigin: e
            }), this.setElement(t);
        });
    }
    toString() {
        return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
    }
    applyResizeFilters() {
        const t = this.resizeFilter, e = this.minimumScaleTrigger, s = this.getTotalObjectScaling(), i = s.x, r = s.y, n = this._filteredEl || this._originalElement;
        if (this.group && this.set("dirty", !0), !t || i > e && r > e) return this._element = n, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = i, void (this._lastScaleY = r);
        const o = vt(n), { width: a, height: h } = n;
        this._element = o, this._lastScaleX = t.scaleX = i, this._lastScaleY = t.scaleY = r, ea().applyFilters([
            t
        ], n, a, h, this._element), this._filterScalingX = o.width / this._originalElement.width, this._filterScalingY = o.height / this._originalElement.height;
    }
    applyFilters() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.filters || [];
        if (t = t.filter((t)=>t && !t.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), 0 === t.length) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
        const e = this._originalElement, s = e.naturalWidth || e.width, i = e.naturalHeight || e.height;
        if (this._element === this._originalElement) {
            const t = vt({
                width: s,
                height: i
            });
            this._element = t, this._filteredEl = t;
        } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, s, i), this._lastScaleX = 1, this._lastScaleY = 1);
        ea().applyFilters(t, this._originalElement, s, i, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
    }
    _render(t) {
        t.imageSmoothingEnabled = this.imageSmoothing, !0 !== this.isMoving && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t), this._renderPaintInOrder(t);
    }
    drawCacheOnCanvas(t) {
        t.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(t);
    }
    shouldCache() {
        return this.needsItsOwnCache();
    }
    _renderFill(t) {
        const e = this._element;
        if (!e) return;
        const s = this._filterScalingX, i = this._filterScalingY, r = this.width, n = this.height, o = Math.max(this.cropX, 0), a = Math.max(this.cropY, 0), h = e.naturalWidth || e.width, c = e.naturalHeight || e.height, l = o * s, u = a * i, d = Math.min(r * s, h - l), g = Math.min(n * i, c - u), f = -r / 2, p = -n / 2, m = Math.min(r, h / s - o), v = Math.min(n, c / i - a);
        e && t.drawImage(e, l, u, d, g, f, p, m, v);
    }
    _needsResize() {
        const t = this.getTotalObjectScaling();
        return t.x !== this._lastScaleX || t.y !== this._lastScaleY;
    }
    _resetWidthHeight() {
        this.set(this.getOriginalSize());
    }
    _setWidthHeight() {
        let { width: t, height: e } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const s = this.getOriginalSize();
        this.width = t || s.width, this.height = e || s.height;
    }
    parsePreserveAspectRatioAttribute() {
        const t = Ie(this.preserveAspectRatio || ""), e = this.width, s = this.height, i = {
            width: e,
            height: s
        };
        let r, n = this._element.width, o = this._element.height, a = 1, h = 1, c = 0, l = 0, u = 0, d = 0;
        return !t || t.alignX === j && t.alignY === j ? (a = e / n, h = s / o) : ("meet" === t.meetOrSlice && (a = h = Nr(this._element, i), r = (e - n * a) / 2, "Min" === t.alignX && (c = -r), "Max" === t.alignX && (c = r), r = (s - o * h) / 2, "Min" === t.alignY && (l = -r), "Max" === t.alignY && (l = r)), "slice" === t.meetOrSlice && (a = h = Ur(this._element, i), r = n - e / a, "Mid" === t.alignX && (u = r / 2), "Max" === t.alignX && (u = r), r = o - s / h, "Mid" === t.alignY && (d = r / 2), "Max" === t.alignY && (d = r), n = e / a, o = s / h)), {
            width: n,
            height: o,
            scaleX: a,
            scaleY: h,
            offsetLeft: c,
            offsetTop: l,
            cropX: u,
            cropY: d
        };
    }
    static fromObject(t, e) {
        let { filters: r, resizeFilter: n, src: o, crossOrigin: a, type: h } = t, c = i(t, ia);
        return Promise.all([
            It(o, s(s({}, e), {}, {
                crossOrigin: a
            })),
            r && Bt(r, e),
            n && Bt([
                n
            ], e),
            Xt(c, e)
        ]).then((t)=>{
            let [e, i = [], [r] = [], n = {}] = t;
            return new this(e, s(s({}, c), {}, {
                src: o,
                filters: i,
                resizeFilter: r
            }, n));
        });
    }
    static fromURL(t) {
        let { crossOrigin: e = null, signal: s } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
        return It(t, {
            crossOrigin: e,
            signal: s
        }).then((t)=>new this(t, i));
    }
    static async fromElement(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, s = arguments.length > 2 ? arguments[2] : void 0;
        const i = Dr(t, this.ATTRIBUTE_NAMES, s);
        return this.fromURL(i["xlink:href"] || i.href, e, i).catch((t)=>(a("log", "Unable to parse Image", t), null));
    }
}
function oa(t) {
    if (!cs.test(t.nodeName)) return {};
    const e = t.getAttribute("viewBox");
    let s, i, r = 1, n = 1, o = 0, a = 0;
    const h = t.getAttribute("width"), c = t.getAttribute("height"), l = t.getAttribute("x") || 0, u = t.getAttribute("y") || 0, d = !(e && us.test(e)), g = !h || !c || "100%" === h || "100%" === c;
    let f = "", p = 0, m = 0;
    if (d && (l || u) && t.parentNode && "#document" !== t.parentNode.nodeName && (f = " translate(" + Re(l || "0") + " " + Re(u || "0") + ") ", s = (t.getAttribute("transform") || "") + f, t.setAttribute("transform", s), t.removeAttribute("x"), t.removeAttribute("y")), d && g) return {
        width: 0,
        height: 0
    };
    const v = {
        width: 0,
        height: 0
    };
    if (d) return v.width = Re(h), v.height = Re(c), v;
    const y = e.match(us);
    o = -parseFloat(y[1]), a = -parseFloat(y[2]);
    const _ = parseFloat(y[3]), x = parseFloat(y[4]);
    v.minX = o, v.minY = a, v.viewBoxWidth = _, v.viewBoxHeight = x, g ? (v.width = _, v.height = x) : (v.width = Re(h), v.height = Re(c), r = v.width / _, n = v.height / x);
    const C = Ie(t.getAttribute("preserveAspectRatio") || "");
    if (C.alignX !== j && ("meet" === C.meetOrSlice && (n = r = r > n ? n : r), "slice" === C.meetOrSlice && (n = r = r > n ? r : n), p = v.width - _ * r, m = v.height - x * r, "Mid" === C.alignX && (p /= 2), "Mid" === C.alignY && (m /= 2), "Min" === C.alignX && (p = 0), "Min" === C.alignY && (m = 0)), 1 === r && 1 === n && 0 === o && 0 === a && 0 === l && 0 === u) return v;
    if ((l || u) && "#document" !== t.parentNode.nodeName && (f = " translate(" + Re(l || "0") + " " + Re(u || "0") + ") "), s = f + " matrix(" + r + " 0 0 " + n + " " + (o * r + p) + " " + (a * n + m) + ") ", "svg" === t.nodeName) {
        for(i = t.ownerDocument.createElementNS(is, "g"); t.firstChild;)i.appendChild(t.firstChild);
        t.appendChild(i);
    } else i = t, i.removeAttribute("x"), i.removeAttribute("y"), s = i.getAttribute("transform") + s;
    return i.setAttribute("transform", s), v;
}
t(na, "type", "Image"), t(na, "cacheProperties", [
    ...Ms,
    ...ra
]), t(na, "ownDefaults", {
    strokeWidth: 0,
    srcFromAttribute: !1,
    minimumScaleTrigger: .5,
    cropX: 0,
    cropY: 0,
    imageSmoothing: !0
}), t(na, "CSS_CANVAS", "canvas-img"), t(na, "ATTRIBUTE_NAMES", [
    ...Ji,
    "x",
    "y",
    "width",
    "height",
    "preserveAspectRatio",
    "xlink:href",
    "href",
    "crossOrigin",
    "image-rendering"
]), tt.setClass(na), tt.setSVGClass(na);
const aa = (t)=>t.tagName.replace("svg:", ""), ha = Ye([
    "pattern",
    "defs",
    "symbol",
    "metadata",
    "clipPath",
    "mask",
    "desc"
]);
function ca(t, e) {
    let s, i, r, n, o = [];
    for(r = 0, n = e.length; r < n; r++)s = e[r], i = t.getElementsByTagNameNS("http://www.w3.org/2000/svg", s), o = o.concat(Array.from(i));
    return o;
}
const la = [
    "gradientTransform",
    "x1",
    "x2",
    "y1",
    "y2",
    "gradientUnits",
    "cx",
    "cy",
    "r",
    "fx",
    "fy"
], ua = "xlink:href";
function da(t, e) {
    var s;
    const i = (null === (s = e.getAttribute(ua)) || void 0 === s ? void 0 : s.slice(1)) || "", r = t.getElementById(i);
    if (r && r.getAttribute(ua) && da(t, r), r && (la.forEach((t)=>{
        const s = r.getAttribute(t);
        !e.hasAttribute(t) && s && e.setAttribute(t, s);
    }), !e.children.length)) {
        const t = r.cloneNode(!0);
        for(; t.firstChild;)e.appendChild(t.firstChild);
    }
    e.removeAttribute(ua);
}
const ga = [
    "linearGradient",
    "radialGradient",
    "svg:linearGradient",
    "svg:radialGradient"
];
function fa(t) {
    const e = t.getElementsByTagName("style"), i = {};
    for(let t = 0; t < e.length; t++){
        const r = (e[t].textContent || "").replace(/\/\*[\s\S]*?\*\//g, "");
        "" !== r.trim() && r.split("}").filter((t, e, s)=>s.length > 1 && t.trim()).forEach((t)=>{
            if ((t.match(/{/g) || []).length > 1 && t.trim().startsWith("@")) return;
            const e = t.split("{"), r = {}, n = e[1].trim().split(";").filter(function(t) {
                return t.trim();
            });
            for(let t = 0; t < n.length; t++){
                const e = n[t].split(":"), s = e[0].trim(), i = e[1].trim();
                r[s] = i;
            }
            (t = e[0].trim()).split(",").forEach((t)=>{
                "" !== (t = t.replace(/^svg/i, "").trim()) && (i[t] = s(s({}, i[t] || {}), r));
            });
        });
    }
    return i;
}
const pa = (t)=>tt.getSVGClass(aa(t).toLowerCase());
class ma {
    constructor(t, e, s, i, r){
        this.elements = t, this.options = e, this.reviver = s, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = i, this.clipPaths = r, this.gradientDefs = function(t) {
            const e = ca(t, ga), s = {};
            let i = e.length;
            for(; i--;){
                const r = e[i];
                r.getAttribute("xlink:href") && da(t, r);
                const n = r.getAttribute("id");
                n && (s[n] = r);
            }
            return s;
        }(i), this.cssRules = fa(i);
    }
    parse() {
        return Promise.all(this.elements.map((t)=>this.createObject(t)));
    }
    async createObject(t) {
        const e = pa(t);
        if (e) {
            const s = await e.fromElement(t, this.options, this.cssRules);
            return this.resolveGradient(s, t, K), this.resolveGradient(s, t, J), s instanceof na && s._originalElement ? On(s, s.parsePreserveAspectRatioAttribute()) : On(s), await this.resolveClipPath(s, t), this.reviver && this.reviver(t, s), s;
        }
        return null;
    }
    extractPropertyDefinition(t, e, s) {
        const i = t[e], r = this.regexUrl;
        if (!r.test(i)) return;
        r.lastIndex = 0;
        const n = r.exec(i)[1];
        return r.lastIndex = 0, s[n];
    }
    resolveGradient(t, e, i) {
        const r = this.extractPropertyDefinition(t, i, this.gradientDefs);
        if (r) {
            const n = e.getAttribute(i + "-opacity"), o = Zn.fromElement(r, t, s(s({}, this.options), {}, {
                opacity: n
            }));
            t.set(i, o);
        }
    }
    async resolveClipPath(t, e, s) {
        const i = this.extractPropertyDefinition(t, "clipPath", this.clipPaths);
        if (i) {
            const r = wt(t.calcTransformMatrix()), n = i[0].parentElement;
            let o = e;
            for(; !s && o.parentElement && o.getAttribute("clip-path") !== t.clipPath;)o = o.parentElement;
            o.parentElement.appendChild(n);
            const a = br("".concat(o.getAttribute("transform") || "", " ").concat(n.getAttribute("originalTransform") || ""));
            n.setAttribute("transform", "matrix(".concat(a.join(","), ")"));
            const h = await Promise.all(i.map((t)=>pa(t).fromElement(t, this.options, this.cssRules).then((t)=>(On(t), t.fillRule = t.clipRule, delete t.clipRule, t)))), c = 1 === h.length ? h[0] : new Hr(h), l = Tt(r, c.calcTransformMatrix());
            c.clipPath && await this.resolveClipPath(c, o, n.getAttribute("clip-path") ? o : void 0);
            const { scaleX: u, scaleY: d, angle: g, skewX: f, translateX: p, translateY: m } = Dt(l);
            c.set({
                flipX: !1,
                flipY: !1
            }), c.set({
                scaleX: u,
                scaleY: d,
                angle: g,
                skewX: f,
                skewY: 0
            }), c.setPositionByOrigin(new ot(p, m), D, D), t.clipPath = c;
        } else delete t.clipPath;
    }
}
const va = (t)=>hs.test(aa(t)), ya = ()=>({
        objects: [],
        elements: [],
        options: {},
        allElements: []
    });
async function _a(t, e) {
    let { crossOrigin: i, signal: r } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (r && r.aborted) return a("log", new c("parseSVGDocument")), ya();
    const n = t.documentElement;
    !function(t) {
        const e = ca(t, [
            "use",
            "svg:use"
        ]), s = [
            "x",
            "y",
            "xlink:href",
            "href",
            "transform"
        ];
        for (const i of e){
            const e = i.attributes, r = {};
            for (const t of e)t.value && (r[t.name] = t.value);
            const n = (r["xlink:href"] || r.href || "").slice(1);
            if ("" === n) return;
            const o = t.getElementById(n);
            if (null === o) return;
            let a = o.cloneNode(!0);
            const h = a.attributes, c = {};
            for (const t of h)t.value && (c[t.name] = t.value);
            const { x: l = 0, y: u = 0, transform: d = "" } = r, g = "".concat(d, " ").concat(c.transform || "", " translate(").concat(l, ", ").concat(u, ")");
            if (oa(a), /^svg$/i.test(a.nodeName)) {
                const t = a.ownerDocument.createElementNS(is, "g");
                Object.entries(c).forEach((e)=>{
                    let [s, i] = e;
                    return t.setAttributeNS(is, s, i);
                }), t.append(...a.childNodes), a = t;
            }
            for (const t of e){
                if (!t) continue;
                const { name: e, value: i } = t;
                if (!s.includes(e)) if ("style" === e) {
                    const t = {};
                    Tr(i, t), Object.entries(c).forEach((e)=>{
                        let [s, i] = e;
                        t[s] = i;
                    }), Tr(c.style || "", t);
                    const s = Object.entries(t).map((t)=>t.join(":")).join(";");
                    a.setAttribute(e, s);
                } else !c[e] && a.setAttribute(e, i);
            }
            a.setAttribute("transform", g), a.setAttribute("instantiated_by_use", "1"), a.removeAttribute("id"), i.parentNode.replaceChild(a, i);
        }
    }(t);
    const o = Array.from(n.getElementsByTagName("*")), h = s(s({}, oa(n)), {}, {
        crossOrigin: i,
        signal: r
    }), l = o.filter((t)=>(oa(t), va(t) && !function(t) {
            let e = t;
            for(; e && (e = e.parentElement);)if (e && e.nodeName && ha.test(aa(e)) && !e.getAttribute("instantiated_by_use")) return !0;
            return !1;
        }(t)));
    if (!l || l && !l.length) return s(s({}, ya()), {}, {
        options: h,
        allElements: o
    });
    const u = {};
    o.filter((t)=>"clipPath" === aa(t)).forEach((t)=>{
        t.setAttribute("originalTransform", t.getAttribute("transform") || "");
        const e = t.getAttribute("id");
        u[e] = Array.from(t.getElementsByTagName("*")).filter((t)=>va(t));
    });
    const d = new ma(l, h, e, t, u);
    return {
        objects: await d.parse(),
        elements: l,
        options: h,
        allElements: o
    };
}
function xa(t, e, s) {
    return _a((new (v()).DOMParser).parseFromString(t.trim(), "text/xml"), e, s);
}
function Ca(t, e) {
    let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return new Promise((e, i)=>{
        Tn(t.replace(/^\n\s*/, "").trim(), {
            onComplete: (t)=>{
                const s = t.responseXML;
                s && e(s), i();
            },
            signal: s.signal
        });
    }).then((t)=>_a(t, e, s)).catch(()=>ya());
}
const ba = W, Sa = (t)=>function(e, s, i) {
        const { points: r, pathOffset: n } = i;
        return new ot(r[t]).subtract(n).transform(Tt(i.getViewportTransform(), i.calcTransformMatrix()));
    }, wa = (t, e, s, i)=>{
    const { target: r, pointIndex: n } = e, o = r, a = pe(new ot(s, i), void 0, o.calcOwnMatrix());
    return o.points[n] = a.add(o.pathOffset), o.setDimensions(), o.set("dirty", !0), !0;
}, Ta = (t, e)=>function(i, r, n, o) {
        const a = r.target, h = new ot(a.points[(t > 0 ? t : a.points.length) - 1]), c = h.subtract(a.pathOffset).transform(a.calcOwnMatrix()), l = e(i, s(s({}, r), {}, {
            pointIndex: t
        }), n, o), u = h.subtract(a.pathOffset).transform(a.calcOwnMatrix()).subtract(c);
        return a.left -= u.x, a.top -= u.y, l;
    }, Oa = (t)=>ti(ba, Ta(t, wa));
const ka = (t, e, s)=>{
    const { path: i, pathOffset: r } = t, n = i[e];
    return new ot(n[s] - r.x, n[s + 1] - r.y).transform(Tt(t.getViewportTransform(), t.calcTransformMatrix()));
};
function Da(t, e, s) {
    const { commandIndex: i, pointIndex: r } = this;
    return ka(s, i, r);
}
function Ma(t, e, i, r) {
    const { target: n } = e, { commandIndex: o, pointIndex: a } = this, h = ((t, e, s, i, r)=>{
        const { path: n, pathOffset: o } = t, a = n[(i > 0 ? i : n.length) - 1], h = new ot(a[r], a[r + 1]), c = h.subtract(o).transform(t.calcOwnMatrix()), l = pe(new ot(e, s), void 0, t.calcOwnMatrix());
        n[i][r] = l.x + o.x, n[i][r + 1] = l.y + o.y, t.setDimensions();
        const u = h.subtract(t.pathOffset).transform(t.calcOwnMatrix()).subtract(c);
        return t.left -= u.x, t.top -= u.y, t.set("dirty", !0), !0;
    })(n, i, r, o, a);
    return ye(this.actionName, s(s({}, Te(t, e, i, r)), {}, {
        commandIndex: o,
        pointIndex: a
    })), h;
}
class Pa extends ni {
    constructor(t){
        super(t);
    }
    render(t, e, i, r, n) {
        const o = s(s({}, r), {}, {
            cornerColor: this.controlFill,
            cornerStrokeColor: this.controlStroke,
            transparentCorners: !this.controlFill
        });
        super.render(t, e, i, o, n);
    }
}
class Ea extends Pa {
    constructor(t){
        super(t);
    }
    render(t, e, s, i, r) {
        const { path: n } = r, { commandIndex: o, pointIndex: a, connectToCommandIndex: h, connectToPointIndex: c } = this;
        t.save(), t.strokeStyle = this.controlStroke, this.connectionDashArray && t.setLineDash(this.connectionDashArray);
        const [l] = n[o], u = ka(r, h, c);
        if ("Q" === l) {
            const i = ka(r, o, a + 2);
            t.moveTo(i.x, i.y), t.lineTo(e, s);
        } else t.moveTo(e, s);
        t.lineTo(u.x, u.y), t.stroke(), t.restore(), super.render(t, e, s, i, r);
    }
}
const Aa = (t, e, i, r, n, o)=>new (i ? Ea : Pa)(s(s({
        commandIndex: t,
        pointIndex: e,
        actionName: "modifyPath",
        positionHandler: Da,
        actionHandler: Ma,
        connectToCommandIndex: n,
        connectToPointIndex: o
    }, r), i ? r.controlPointStyle : r.pointStyle));
var ja = Object.freeze({
    __proto__: null,
    changeWidth: si,
    createObjectDefaultControls: Di,
    createPathControls: function(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const s = {};
        let i = "M";
        return t.path.forEach((t, r)=>{
            const n = t[0];
            switch("Z" !== n && (s["c_".concat(r, "_").concat(n)] = Aa(r, t.length - 2, !1, e)), n){
                case "C":
                    s["c_".concat(r, "_C_CP_1")] = Aa(r, 1, !0, e, r - 1, ((t)=>"C" === t ? 5 : "Q" === t ? 3 : 1)(i)), s["c_".concat(r, "_C_CP_2")] = Aa(r, 3, !0, e, r, 5);
                    break;
                case "Q":
                    s["c_".concat(r, "_Q_CP_1")] = Aa(r, 1, !0, e, r, 3);
            }
            i = n;
        }), s;
    },
    createPolyActionHandler: Oa,
    createPolyControls: function(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i = {};
        for(let r = 0; r < ("number" == typeof t ? t : t.points.length); r++)i["p".concat(r)] = new ni(s({
            actionName: ba,
            positionHandler: Sa(r),
            actionHandler: Oa(r)
        }, e));
        return i;
    },
    createPolyPositionHandler: Sa,
    createResizeControls: Mi,
    createTextboxDefaultControls: Pi,
    dragHandler: De,
    factoryPolyActionHandler: Ta,
    getLocalPoint: ke,
    polyActionHandler: wa,
    renderCircleControl: ii,
    renderSquareControl: ri,
    rotationStyleHandler: oi,
    rotationWithSnapping: ai,
    scaleCursorStyleHandler: ui,
    scaleOrSkewActionName: wi,
    scaleSkewCursorStyleHandler: Ti,
    scalingEqually: gi,
    scalingX: fi,
    scalingXOrSkewingY: Oi,
    scalingY: pi,
    scalingYOrSkewingX: ki,
    skewCursorStyleHandler: _i,
    skewHandlerX: Ci,
    skewHandlerY: bi,
    wrapWithFireEvent: ti,
    wrapWithFixedAnchor: ei
});
const Fa = (t)=>void 0 !== t.webgl, La = (t, e)=>{
    const s = vt({
        width: t,
        height: e
    }), i = pt().getContext("webgl"), r = {
        imageBuffer: new ArrayBuffer(t * e * 4)
    }, n = {
        destinationWidth: t,
        destinationHeight: e,
        targetCanvas: s
    };
    let o;
    o = v().performance.now(), Zo.prototype.copyGLTo2D.call(r, i, n);
    const a = v().performance.now() - o;
    o = v().performance.now(), Zo.prototype.copyGLTo2DPutImageData.call(r, i, n);
    return a > v().performance.now() - o;
}, Ra = "precision highp float", Ia = "\n    ".concat(Ra, ";\n    varying vec2 vTexCoord;\n    uniform sampler2D uTexture;\n    void main() {\n      gl_FragColor = texture2D(uTexture, vTexCoord);\n    }"), Ba = [
    "type"
], Xa = [
    "type"
], Ya = new RegExp(Ra, "g");
class Wa {
    get type() {
        return this.constructor.type;
    }
    constructor(){
        let t = i(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, Ba);
        Object.assign(this, this.constructor.defaults, t);
    }
    getFragmentSource() {
        return Ia;
    }
    getVertexSource() {
        return "\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    void main() {\n      vTexCoord = aPosition;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }";
    }
    createProgram(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getFragmentSource(), s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.getVertexSource();
        const { WebGLProbe: { GLPrecision: i = "highp" } } = p();
        "highp" !== i && (e = e.replace(Ya, Ra.replace("highp", i)));
        const r = t.createShader(t.VERTEX_SHADER), n = t.createShader(t.FRAGMENT_SHADER), o = t.createProgram();
        if (!r || !n || !o) throw new h("Vertex, fragment shader or program creation error");
        if (t.shaderSource(r, s), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS)) throw new h("Vertex shader compile error for ".concat(this.type, ": ").concat(t.getShaderInfoLog(r)));
        if (t.shaderSource(n, e), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) throw new h("Fragment shader compile error for ".concat(this.type, ": ").concat(t.getShaderInfoLog(n)));
        if (t.attachShader(o, r), t.attachShader(o, n), t.linkProgram(o), !t.getProgramParameter(o, t.LINK_STATUS)) throw new h('Shader link error for "'.concat(this.type, '" ').concat(t.getProgramInfoLog(o)));
        const a = this.getUniformLocations(t, o) || {};
        return a.uStepW = t.getUniformLocation(o, "uStepW"), a.uStepH = t.getUniformLocation(o, "uStepH"), {
            program: o,
            attributeLocations: this.getAttributeLocations(t, o),
            uniformLocations: a
        };
    }
    getAttributeLocations(t, e) {
        return {
            aPosition: t.getAttribLocation(e, "aPosition")
        };
    }
    getUniformLocations(t, e) {
        const s = this.constructor.uniformLocations, i = {};
        for(let r = 0; r < s.length; r++)i[s[r]] = t.getUniformLocation(e, s[r]);
        return i;
    }
    sendAttributeData(t, e, s) {
        const i = e.aPosition, r = t.createBuffer();
        t.bindBuffer(t.ARRAY_BUFFER, r), t.enableVertexAttribArray(i), t.vertexAttribPointer(i, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, s, t.STATIC_DRAW);
    }
    _setupFrameBuffer(t) {
        const e = t.context;
        if (t.passes > 1) {
            const s = t.destinationWidth, i = t.destinationHeight;
            t.sourceWidth === s && t.sourceHeight === i || (e.deleteTexture(t.targetTexture), t.targetTexture = t.filterBackend.createTexture(e, s, i)), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t.targetTexture, 0);
        } else e.bindFramebuffer(e.FRAMEBUFFER, null), e.finish();
    }
    _swapTextures(t) {
        t.passes--, t.pass++;
        const e = t.targetTexture;
        t.targetTexture = t.sourceTexture, t.sourceTexture = e;
    }
    isNeutralState(t) {
        return !1;
    }
    applyTo(t) {
        Fa(t) ? (this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);
    }
    applyTo2d(t) {}
    getCacheKey() {
        return this.type;
    }
    retrieveShader(t) {
        const e = this.getCacheKey();
        return t.programCache[e] || (t.programCache[e] = this.createProgram(t.context)), t.programCache[e];
    }
    applyToWebGL(t) {
        const e = t.context, s = this.retrieveShader(t);
        0 === t.pass && t.originalTexture ? e.bindTexture(e.TEXTURE_2D, t.originalTexture) : e.bindTexture(e.TEXTURE_2D, t.sourceTexture), e.useProgram(s.program), this.sendAttributeData(e, s.attributeLocations, t.aPosition), e.uniform1f(s.uniformLocations.uStepW, 1 / t.sourceWidth), e.uniform1f(s.uniformLocations.uStepH, 1 / t.sourceHeight), this.sendUniformData(e, s.uniformLocations), e.viewport(0, 0, t.destinationWidth, t.destinationHeight), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
    }
    bindAdditionalTexture(t, e, s) {
        t.activeTexture(s), t.bindTexture(t.TEXTURE_2D, e), t.activeTexture(t.TEXTURE0);
    }
    unbindAdditionalTexture(t, e) {
        t.activeTexture(e), t.bindTexture(t.TEXTURE_2D, null), t.activeTexture(t.TEXTURE0);
    }
    sendUniformData(t, e) {}
    createHelpLayer(t) {
        if (!t.helpLayer) {
            const { sourceWidth: e, sourceHeight: s } = t, i = vt({
                width: e,
                height: s
            });
            t.helpLayer = i;
        }
    }
    toObject() {
        const t = Object.keys(this.constructor.defaults || {});
        return s({
            type: this.type
        }, t.reduce((t, e)=>(t[e] = this[e], t), {}));
    }
    toJSON() {
        return this.toObject();
    }
    static async fromObject(t, e) {
        return new this(i(t, Xa));
    }
}
t(Wa, "type", "BaseFilter"), t(Wa, "uniformLocations", []);
const Va = {
    multiply: "gl_FragColor.rgb *= uColor.rgb;\n",
    screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n",
    add: "gl_FragColor.rgb += uColor.rgb;\n",
    difference: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n",
    subtract: "gl_FragColor.rgb -= uColor.rgb;\n",
    lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n",
    darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n",
    exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n",
    overlay: "\n    if (uColor.r < 0.5) {\n      gl_FragColor.r *= 2.0 * uColor.r;\n    } else {\n      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n    }\n    if (uColor.g < 0.5) {\n      gl_FragColor.g *= 2.0 * uColor.g;\n    } else {\n      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n    }\n    if (uColor.b < 0.5) {\n      gl_FragColor.b *= 2.0 * uColor.b;\n    } else {\n      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n    }\n    ",
    tint: "\n    gl_FragColor.rgb *= (1.0 - uColor.a);\n    gl_FragColor.rgb += uColor.rgb;\n    "
};
class za extends Wa {
    getCacheKey() {
        return "".concat(this.type, "_").concat(this.mode);
    }
    getFragmentSource() {
        return "\n      precision highp float;\n      uniform sampler2D uTexture;\n      uniform vec4 uColor;\n      varying vec2 vTexCoord;\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        gl_FragColor = color;\n        if (color.a > 0.0) {\n          ".concat(Va[this.mode], "\n        }\n      }\n      ");
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = new Le(this.color).getSource(), i = this.alpha, r = s[0] * i, n = s[1] * i, o = s[2] * i, a = 1 - i;
        for(let t = 0; t < e.length; t += 4){
            const s = e[t], i = e[t + 1], h = e[t + 2];
            let c, l, u;
            switch(this.mode){
                case "multiply":
                    c = s * r / 255, l = i * n / 255, u = h * o / 255;
                    break;
                case "screen":
                    c = 255 - (255 - s) * (255 - r) / 255, l = 255 - (255 - i) * (255 - n) / 255, u = 255 - (255 - h) * (255 - o) / 255;
                    break;
                case "add":
                    c = s + r, l = i + n, u = h + o;
                    break;
                case "difference":
                    c = Math.abs(s - r), l = Math.abs(i - n), u = Math.abs(h - o);
                    break;
                case "subtract":
                    c = s - r, l = i - n, u = h - o;
                    break;
                case "darken":
                    c = Math.min(s, r), l = Math.min(i, n), u = Math.min(h, o);
                    break;
                case "lighten":
                    c = Math.max(s, r), l = Math.max(i, n), u = Math.max(h, o);
                    break;
                case "overlay":
                    c = r < 128 ? 2 * s * r / 255 : 255 - 2 * (255 - s) * (255 - r) / 255, l = n < 128 ? 2 * i * n / 255 : 255 - 2 * (255 - i) * (255 - n) / 255, u = o < 128 ? 2 * h * o / 255 : 255 - 2 * (255 - h) * (255 - o) / 255;
                    break;
                case "exclusion":
                    c = r + s - 2 * r * s / 255, l = n + i - 2 * n * i / 255, u = o + h - 2 * o * h / 255;
                    break;
                case "tint":
                    c = r + s * a, l = n + i * a, u = o + h * a;
            }
            e[t] = c, e[t + 1] = l, e[t + 2] = u;
        }
    }
    sendUniformData(t, e) {
        const s = new Le(this.color).getSource();
        s[0] = this.alpha * s[0] / 255, s[1] = this.alpha * s[1] / 255, s[2] = this.alpha * s[2] / 255, s[3] = this.alpha, t.uniform4fv(e.uColor, s);
    }
}
t(za, "defaults", {
    color: "#F95C63",
    mode: "multiply",
    alpha: 1
}), t(za, "type", "BlendColor"), t(za, "uniformLocations", [
    "uColor"
]), tt.setClass(za);
const Ga = {
    multiply: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.rgba *= color2.rgba;\n      gl_FragColor = color;\n    }\n    ",
    mask: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.a = color2.a;\n      gl_FragColor = color;\n    }\n    "
}, Ha = [
    "type",
    "image"
];
class Na extends Wa {
    getCacheKey() {
        return "".concat(this.type, "_").concat(this.mode);
    }
    getFragmentSource() {
        return Ga[this.mode];
    }
    getVertexSource() {
        return "\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    uniform mat3 uTransformMatrix;\n    void main() {\n      vTexCoord = aPosition;\n      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }\n    ";
    }
    applyToWebGL(t) {
        const e = t.context, s = this.createTexture(t.filterBackend, this.image);
        this.bindAdditionalTexture(e, s, e.TEXTURE1), super.applyToWebGL(t), this.unbindAdditionalTexture(e, e.TEXTURE1);
    }
    createTexture(t, e) {
        return t.getCachedTexture(e.cacheKey, e.getElement());
    }
    calculateMatrix() {
        const t = this.image, { width: e, height: s } = t.getElement();
        return [
            1 / t.scaleX,
            0,
            0,
            0,
            1 / t.scaleY,
            0,
            -t.left / e,
            -t.top / s,
            1
        ];
    }
    applyTo2d(t) {
        let { imageData: { data: e, width: s, height: i }, filterBackend: { resources: r } } = t;
        const n = this.image;
        r.blendImage || (r.blendImage = pt());
        const o = r.blendImage, a = o.getContext("2d");
        o.width !== s || o.height !== i ? (o.width = s, o.height = i) : a.clearRect(0, 0, s, i), a.setTransform(n.scaleX, 0, 0, n.scaleY, n.left, n.top), a.drawImage(n.getElement(), 0, 0, s, i);
        const h = a.getImageData(0, 0, s, i).data;
        for(let t = 0; t < e.length; t += 4){
            const s = e[t], i = e[t + 1], r = e[t + 2], n = e[t + 3], o = h[t], a = h[t + 1], c = h[t + 2], l = h[t + 3];
            switch(this.mode){
                case "multiply":
                    e[t] = s * o / 255, e[t + 1] = i * a / 255, e[t + 2] = r * c / 255, e[t + 3] = n * l / 255;
                    break;
                case "mask":
                    e[t + 3] = l;
            }
        }
    }
    sendUniformData(t, e) {
        const s = this.calculateMatrix();
        t.uniform1i(e.uImage, 1), t.uniformMatrix3fv(e.uTransformMatrix, !1, s);
    }
    toObject() {
        return s(s({}, super.toObject()), {}, {
            image: this.image && this.image.toObject()
        });
    }
    static async fromObject(t, e) {
        let { type: r, image: n } = t, o = i(t, Ha);
        return na.fromObject(n, e).then((t)=>new this(s(s({}, o), {}, {
                image: t
            })));
    }
}
t(Na, "type", "BlendImage"), t(Na, "defaults", {
    mode: "multiply",
    alpha: 1
}), t(Na, "uniformLocations", [
    "uTransformMatrix",
    "uImage"
]), tt.setClass(Na);
class Ua extends Wa {
    getFragmentSource() {
        return "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform vec2 uDelta;\n    varying vec2 vTexCoord;\n    const float nSamples = 15.0;\n    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n    float random(vec3 scale) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n    }\n    void main() {\n      vec4 color = vec4(0.0);\n      float totalC = 0.0;\n      float totalA = 0.0;\n      float offset = random(v3offset);\n      for (float t = -nSamples; t <= nSamples; t++) {\n        float percent = (t + offset - 0.5) / nSamples;\n        vec4 sample = texture2D(uTexture, vTexCoord + uDelta * percent);\n        float weight = 1.0 - abs(percent);\n        float alpha = weight * sample.a;\n        color.rgb += sample.rgb * alpha;\n        color.a += alpha;\n        totalA += weight;\n        totalC += alpha;\n      }\n      gl_FragColor.rgb = color.rgb / totalC;\n      gl_FragColor.a = color.a / totalA;\n    }\n  ";
    }
    applyTo(t) {
        Fa(t) ? (this.aspectRatio = t.sourceWidth / t.sourceHeight, t.passes++, this._setupFrameBuffer(t), this.horizontal = !0, this.applyToWebGL(t), this._swapTextures(t), this._setupFrameBuffer(t), this.horizontal = !1, this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);
    }
    applyTo2d(t) {
        let { imageData: { data: e, width: s, height: i } } = t;
        this.aspectRatio = s / i, this.horizontal = !0;
        let r = this.getBlurValue() * s;
        const n = new Uint8ClampedArray(e), o = 15, a = 4 * s;
        for(let t = 0; t < e.length; t += 4){
            let s = 0, i = 0, h = 0, c = 0, l = 0;
            const u = t - t % a, d = u + a;
            for(let n = -14; n < o; n++){
                const a = n / o, g = 4 * Math.floor(r * a), f = 1 - Math.abs(a);
                let p = t + g;
                p < u ? p = u : p > d && (p = d);
                const m = e[p + 3] * f;
                s += e[p] * m, i += e[p + 1] * m, h += e[p + 2] * m, c += m, l += f;
            }
            n[t] = s / c, n[t + 1] = i / c, n[t + 2] = h / c, n[t + 3] = c / l;
        }
        this.horizontal = !1, r = this.getBlurValue() * i;
        for(let t = 0; t < n.length; t += 4){
            let s = 0, i = 0, h = 0, c = 0, l = 0;
            const u = t % a, d = n.length - a + u;
            for(let e = -14; e < o; e++){
                const g = e / o, f = Math.floor(r * g) * a, p = 1 - Math.abs(g);
                let m = t + f;
                m < u ? m = u : m > d && (m = d);
                const v = n[m + 3] * p;
                s += n[m] * v, i += n[m + 1] * v, h += n[m + 2] * v, c += v, l += p;
            }
            e[t] = s / c, e[t + 1] = i / c, e[t + 2] = h / c, e[t + 3] = c / l;
        }
    }
    sendUniformData(t, e) {
        const s = this.chooseRightDelta();
        t.uniform2fv(e.uDelta, s);
    }
    isNeutralState() {
        return 0 === this.blur;
    }
    getBlurValue() {
        let t = 1;
        const { horizontal: e, aspectRatio: s } = this;
        return e ? s > 1 && (t = 1 / s) : s < 1 && (t = s), t * this.blur * .12;
    }
    chooseRightDelta() {
        const t = this.getBlurValue();
        return this.horizontal ? [
            t,
            0
        ] : [
            0,
            t
        ];
    }
}
t(Ua, "type", "Blur"), t(Ua, "defaults", {
    blur: 0
}), t(Ua, "uniformLocations", [
    "uDelta"
]), tt.setClass(Ua);
class qa extends Wa {
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBrightness;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += uBrightness;\n    gl_FragColor = color;\n  }\n";
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = Math.round(255 * this.brightness);
        for(let t = 0; t < e.length; t += 4)e[t] += s, e[t + 1] += s, e[t + 2] += s;
    }
    isNeutralState() {
        return 0 === this.brightness;
    }
    sendUniformData(t, e) {
        t.uniform1f(e.uBrightness, this.brightness);
    }
}
t(qa, "type", "Brightness"), t(qa, "defaults", {
    brightness: 0
}), t(qa, "uniformLocations", [
    "uBrightness"
]), tt.setClass(qa);
const Ka = {
    matrix: [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
    ],
    colorsOnly: !0
};
class Ja extends Wa {
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  varying vec2 vTexCoord;\n  uniform mat4 uColorMatrix;\n  uniform vec4 uConstants;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color *= uColorMatrix;\n    color += uConstants;\n    gl_FragColor = color;\n  }";
    }
    applyTo2d(t) {
        const e = t.imageData.data, s = this.matrix, i = this.colorsOnly;
        for(let t = 0; t < e.length; t += 4){
            const r = e[t], n = e[t + 1], o = e[t + 2];
            if (e[t] = r * s[0] + n * s[1] + o * s[2] + 255 * s[4], e[t + 1] = r * s[5] + n * s[6] + o * s[7] + 255 * s[9], e[t + 2] = r * s[10] + n * s[11] + o * s[12] + 255 * s[14], !i) {
                const i = e[t + 3];
                e[t] += i * s[3], e[t + 1] += i * s[8], e[t + 2] += i * s[13], e[t + 3] = r * s[15] + n * s[16] + o * s[17] + i * s[18] + 255 * s[19];
            }
        }
    }
    sendUniformData(t, e) {
        const s = this.matrix, i = [
            s[0],
            s[1],
            s[2],
            s[3],
            s[5],
            s[6],
            s[7],
            s[8],
            s[10],
            s[11],
            s[12],
            s[13],
            s[15],
            s[16],
            s[17],
            s[18]
        ], r = [
            s[4],
            s[9],
            s[14],
            s[19]
        ];
        t.uniformMatrix4fv(e.uColorMatrix, !1, i), t.uniform4fv(e.uConstants, r);
    }
    toObject() {
        return s(s({}, super.toObject()), {}, {
            matrix: [
                ...this.matrix
            ]
        });
    }
}
function Qa(e, s) {
    var i;
    const r = (t(i = class extends Ja {
        toObject() {
            return {
                type: this.type,
                colorsOnly: this.colorsOnly
            };
        }
    }, "type", e), t(i, "defaults", {
        colorsOnly: !1,
        matrix: s
    }), i);
    return tt.setClass(r, e), r;
}
t(Ja, "type", "ColorMatrix"), t(Ja, "defaults", Ka), t(Ja, "uniformLocations", [
    "uColorMatrix",
    "uConstants"
]), tt.setClass(Ja);
const Za = Qa("Brownie", [
    .5997,
    .34553,
    -.27082,
    0,
    .186,
    -.0377,
    .86095,
    .15059,
    0,
    -.1449,
    .24113,
    -.07441,
    .44972,
    0,
    -.02965,
    0,
    0,
    0,
    1,
    0
]), $a = Qa("Vintage", [
    .62793,
    .32021,
    -.03965,
    0,
    .03784,
    .02578,
    .64411,
    .03259,
    0,
    .02926,
    .0466,
    -.08512,
    .52416,
    0,
    .02023,
    0,
    0,
    0,
    1,
    0
]), th = Qa("Kodachrome", [
    1.12855,
    -.39673,
    -.03992,
    0,
    .24991,
    -.16404,
    1.08352,
    -.05498,
    0,
    .09698,
    -.16786,
    -.56034,
    1.60148,
    0,
    .13972,
    0,
    0,
    0,
    1,
    0
]), eh = Qa("Technicolor", [
    1.91252,
    -.85453,
    -.09155,
    0,
    .04624,
    -.30878,
    1.76589,
    -.10601,
    0,
    -.27589,
    -.2311,
    -.75018,
    1.84759,
    0,
    .12137,
    0,
    0,
    0,
    1,
    0
]), sh = Qa("Polaroid", [
    1.438,
    -.062,
    -.062,
    0,
    0,
    -.122,
    1.378,
    -.122,
    0,
    0,
    -.016,
    -.016,
    1.483,
    0,
    0,
    0,
    0,
    0,
    1,
    0
]), ih = Qa("Sepia", [
    .393,
    .769,
    .189,
    0,
    0,
    .349,
    .686,
    .168,
    0,
    0,
    .272,
    .534,
    .131,
    0,
    0,
    0,
    0,
    0,
    1,
    0
]), rh = Qa("BlackWhite", [
    1.5,
    1.5,
    1.5,
    0,
    -1,
    1.5,
    1.5,
    1.5,
    0,
    -1,
    1.5,
    1.5,
    1.5,
    0,
    -1,
    0,
    0,
    0,
    1,
    0
]);
class nh extends Wa {
    constructor(){
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        super(t), this.subFilters = t.subFilters || [];
    }
    applyTo(t) {
        Fa(t) && (t.passes += this.subFilters.length - 1), this.subFilters.forEach((e)=>{
            e.applyTo(t);
        });
    }
    toObject() {
        return {
            type: this.type,
            subFilters: this.subFilters.map((t)=>t.toObject())
        };
    }
    isNeutralState() {
        return !this.subFilters.some((t)=>!t.isNeutralState());
    }
    static fromObject(t, e) {
        return Promise.all((t.subFilters || []).map((t)=>tt.getClass(t.type).fromObject(t, e))).then((t)=>new this({
                subFilters: t
            }));
    }
}
t(nh, "type", "Composed"), tt.setClass(nh);
class oh extends Wa {
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uContrast;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n    gl_FragColor = color;\n  }";
    }
    isNeutralState() {
        return 0 === this.contrast;
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = Math.floor(255 * this.contrast), i = 259 * (s + 255) / (255 * (259 - s));
        for(let t = 0; t < e.length; t += 4)e[t] = i * (e[t] - 128) + 128, e[t + 1] = i * (e[t + 1] - 128) + 128, e[t + 2] = i * (e[t + 2] - 128) + 128;
    }
    sendUniformData(t, e) {
        t.uniform1f(e.uContrast, this.contrast);
    }
}
t(oh, "type", "Contrast"), t(oh, "defaults", {
    contrast: 0
}), t(oh, "uniformLocations", [
    "uContrast"
]), tt.setClass(oh);
const ah = {
    Convolute_3_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",
    Convolute_3_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ",
    Convolute_5_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",
    Convolute_5_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ",
    Convolute_7_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",
    Convolute_7_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ",
    Convolute_9_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",
    Convolute_9_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    "
};
class hh extends Wa {
    getCacheKey() {
        return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
    }
    getFragmentSource() {
        return ah[this.getCacheKey()];
    }
    applyTo2d(t) {
        const e = t.imageData, s = e.data, i = this.matrix, r = Math.round(Math.sqrt(i.length)), n = Math.floor(r / 2), o = e.width, a = e.height, h = t.ctx.createImageData(o, a), c = h.data, l = this.opaque ? 1 : 0;
        let u, d, g, f, p, m, v, y, _, x, C, b, S;
        for(C = 0; C < a; C++)for(x = 0; x < o; x++){
            for(p = 4 * (C * o + x), u = 0, d = 0, g = 0, f = 0, S = 0; S < r; S++)for(b = 0; b < r; b++)v = C + S - n, m = x + b - n, v < 0 || v >= a || m < 0 || m >= o || (y = 4 * (v * o + m), _ = i[S * r + b], u += s[y] * _, d += s[y + 1] * _, g += s[y + 2] * _, l || (f += s[y + 3] * _));
            c[p] = u, c[p + 1] = d, c[p + 2] = g, c[p + 3] = l ? s[p + 3] : f;
        }
        t.imageData = h;
    }
    sendUniformData(t, e) {
        t.uniform1fv(e.uMatrix, this.matrix);
    }
    toObject() {
        return s(s({}, super.toObject()), {}, {
            opaque: this.opaque,
            matrix: [
                ...this.matrix
            ]
        });
    }
}
t(hh, "type", "Convolute"), t(hh, "defaults", {
    opaque: !1,
    matrix: [
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0
    ]
}), t(hh, "uniformLocations", [
    "uMatrix",
    "uOpaque",
    "uHalfSize",
    "uSize"
]), tt.setClass(hh);
const ch = "Gamma";
class lh extends Wa {
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform vec3 uGamma;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    vec3 correction = (1.0 / uGamma);\n    color.r = pow(color.r, correction.r);\n    color.g = pow(color.g, correction.g);\n    color.b = pow(color.b, correction.b);\n    gl_FragColor = color;\n    gl_FragColor.rgb *= color.a;\n  }\n";
    }
    constructor(){
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        super(t), this.gamma = t.gamma || this.constructor.defaults.gamma.concat();
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = this.gamma, i = 1 / s[0], r = 1 / s[1], n = 1 / s[2];
        this.rgbValues || (this.rgbValues = {
            r: new Uint8Array(256),
            g: new Uint8Array(256),
            b: new Uint8Array(256)
        });
        const o = this.rgbValues;
        for(let t = 0; t < 256; t++)o.r[t] = 255 * Math.pow(t / 255, i), o.g[t] = 255 * Math.pow(t / 255, r), o.b[t] = 255 * Math.pow(t / 255, n);
        for(let t = 0; t < e.length; t += 4)e[t] = o.r[e[t]], e[t + 1] = o.g[e[t + 1]], e[t + 2] = o.b[e[t + 2]];
    }
    sendUniformData(t, e) {
        t.uniform3fv(e.uGamma, this.gamma);
    }
    isNeutralState() {
        const { gamma: t } = this;
        return 1 === t[0] && 1 === t[1] && 1 === t[2];
    }
    toObject() {
        return {
            type: ch,
            gamma: this.gamma.concat()
        };
    }
}
t(lh, "type", ch), t(lh, "defaults", {
    gamma: [
        1,
        1,
        1
    ]
}), t(lh, "uniformLocations", [
    "uGamma"
]), tt.setClass(lh);
const uh = {
    average: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      float average = (color.r + color.b + color.g) / 3.0;\n      gl_FragColor = vec4(average, average, average, color.a);\n    }\n    ",
    lightness: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    ",
    luminosity: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    "
};
class dh extends Wa {
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        for(let t, s = 0; s < e.length; s += 4){
            const i = e[s], r = e[s + 1], n = e[s + 2];
            switch(this.mode){
                case "average":
                    t = (i + r + n) / 3;
                    break;
                case "lightness":
                    t = (Math.min(i, r, n) + Math.max(i, r, n)) / 2;
                    break;
                case "luminosity":
                    t = .21 * i + .72 * r + .07 * n;
            }
            e[s + 2] = e[s + 1] = e[s] = t;
        }
    }
    getCacheKey() {
        return "".concat(this.type, "_").concat(this.mode);
    }
    getFragmentSource() {
        return uh[this.mode];
    }
    sendUniformData(t, e) {
        t.uniform1i(e.uMode, 1);
    }
    isNeutralState() {
        return !1;
    }
}
t(dh, "type", "Grayscale"), t(dh, "defaults", {
    mode: "average"
}), t(dh, "uniformLocations", [
    "uMode"
]), tt.setClass(dh);
const gh = s(s({}, Ka), {}, {
    rotation: 0
});
class fh extends Ja {
    calculateMatrix() {
        const t = this.rotation * Math.PI, e = rt(t), s = nt(t), i = 1 / 3, r = Math.sqrt(i) * s, n = 1 - e;
        this.matrix = [
            e + n / 3,
            i * n - r,
            i * n + r,
            0,
            0,
            i * n + r,
            e + i * n,
            i * n - r,
            0,
            0,
            i * n - r,
            i * n + r,
            e + i * n,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ];
    }
    isNeutralState() {
        return 0 === this.rotation;
    }
    applyTo(t) {
        this.calculateMatrix(), super.applyTo(t);
    }
    toObject() {
        return {
            type: this.type,
            rotation: this.rotation
        };
    }
}
t(fh, "type", "HueRotation"), t(fh, "defaults", gh), tt.setClass(fh);
class ph extends Wa {
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        for(let t = 0; t < e.length; t += 4)e[t] = 255 - e[t], e[t + 1] = 255 - e[t + 1], e[t + 2] = 255 - e[t + 2], this.alpha && (e[t + 3] = 255 - e[t + 3]);
    }
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform int uInvert;\n  uniform int uAlpha;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    if (uInvert == 1) {\n      if (uAlpha == 1) {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);\n      } else {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n      }\n    } else {\n      gl_FragColor = color;\n    }\n  }\n";
    }
    isNeutralState() {
        return !this.invert;
    }
    sendUniformData(t, e) {
        t.uniform1i(e.uInvert, Number(this.invert)), t.uniform1i(e.uAlpha, Number(this.alpha));
    }
}
t(ph, "type", "Invert"), t(ph, "defaults", {
    alpha: !1,
    invert: !0
}), t(ph, "uniformLocations", [
    "uInvert",
    "uAlpha"
]), tt.setClass(ph);
class mh extends Wa {
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uStepH;\n  uniform float uNoise;\n  uniform float uSeed;\n  varying vec2 vTexCoord;\n  float rand(vec2 co, float seed, float vScale) {\n    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n  }\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n    gl_FragColor = color;\n  }\n";
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = this.noise;
        for(let t = 0; t < e.length; t += 4){
            const i = (.5 - Math.random()) * s;
            e[t] += i, e[t + 1] += i, e[t + 2] += i;
        }
    }
    sendUniformData(t, e) {
        t.uniform1f(e.uNoise, this.noise / 255), t.uniform1f(e.uSeed, Math.random());
    }
    isNeutralState() {
        return 0 === this.noise;
    }
}
t(mh, "type", "Noise"), t(mh, "defaults", {
    noise: 0
}), t(mh, "uniformLocations", [
    "uNoise",
    "uSeed"
]), tt.setClass(mh);
class vh extends Wa {
    applyTo2d(t) {
        let { imageData: { data: e, width: s, height: i } } = t;
        for(let t = 0; t < i; t += this.blocksize)for(let r = 0; r < s; r += this.blocksize){
            const n = 4 * t * s + 4 * r, o = e[n], a = e[n + 1], h = e[n + 2], c = e[n + 3];
            for(let n = t; n < Math.min(t + this.blocksize, i); n++)for(let t = r; t < Math.min(r + this.blocksize, s); t++){
                const i = 4 * n * s + 4 * t;
                e[i] = o, e[i + 1] = a, e[i + 2] = h, e[i + 3] = c;
            }
        }
    }
    isNeutralState() {
        return 1 === this.blocksize;
    }
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBlocksize;\n  uniform float uStepW;\n  uniform float uStepH;\n  varying vec2 vTexCoord;\n  void main() {\n    float blockW = uBlocksize * uStepW;\n    float blockH = uBlocksize * uStepH;\n    int posX = int(vTexCoord.x / blockW);\n    int posY = int(vTexCoord.y / blockH);\n    float fposX = float(posX);\n    float fposY = float(posY);\n    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n    vec4 color = texture2D(uTexture, squareCoords);\n    gl_FragColor = color;\n  }\n";
    }
    sendUniformData(t, e) {
        t.uniform1f(e.uBlocksize, this.blocksize);
    }
}
t(vh, "type", "Pixelate"), t(vh, "defaults", {
    blocksize: 4
}), t(vh, "uniformLocations", [
    "uBlocksize"
]), tt.setClass(vh);
class yh extends Wa {
    getFragmentSource() {
        return "\nprecision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_FragColor = texture2D(uTexture, vTexCoord);\n  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n    gl_FragColor.a = 0.0;\n  }\n}\n";
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = 255 * this.distance, i = new Le(this.color).getSource(), r = [
            i[0] - s,
            i[1] - s,
            i[2] - s
        ], n = [
            i[0] + s,
            i[1] + s,
            i[2] + s
        ];
        for(let t = 0; t < e.length; t += 4){
            const s = e[t], i = e[t + 1], o = e[t + 2];
            s > r[0] && i > r[1] && o > r[2] && s < n[0] && i < n[1] && o < n[2] && (e[t + 3] = 0);
        }
    }
    sendUniformData(t, e) {
        const s = new Le(this.color).getSource(), i = this.distance, r = [
            0 + s[0] / 255 - i,
            0 + s[1] / 255 - i,
            0 + s[2] / 255 - i,
            1
        ], n = [
            s[0] / 255 + i,
            s[1] / 255 + i,
            s[2] / 255 + i,
            1
        ];
        t.uniform4fv(e.uLow, r), t.uniform4fv(e.uHigh, n);
    }
}
t(yh, "type", "RemoveColor"), t(yh, "defaults", {
    color: "#FFFFFF",
    distance: .02,
    useAlpha: !1
}), t(yh, "uniformLocations", [
    "uLow",
    "uHigh"
]), tt.setClass(yh);
class _h extends Wa {
    sendUniformData(t, e) {
        t.uniform2fv(e.uDelta, this.horizontal ? [
            1 / this.width,
            0
        ] : [
            0,
            1 / this.height
        ]), t.uniform1fv(e.uTaps, this.taps);
    }
    getFilterWindow() {
        const t = this.tempScale;
        return Math.ceil(this.lanczosLobes / t);
    }
    getCacheKey() {
        const t = this.getFilterWindow();
        return "".concat(this.type, "_").concat(t);
    }
    getFragmentSource() {
        const t = this.getFilterWindow();
        return this.generateShader(t);
    }
    getTaps() {
        const t = this.lanczosCreate(this.lanczosLobes), e = this.tempScale, s = this.getFilterWindow(), i = new Array(s);
        for(let r = 1; r <= s; r++)i[r - 1] = t(r * e);
        return i;
    }
    generateShader(t) {
        const e = new Array(t);
        for(let s = 1; s <= t; s++)e[s - 1] = "".concat(s, ".0 * uDelta");
        return "\n      precision highp float;\n      uniform sampler2D uTexture;\n      uniform vec2 uDelta;\n      varying vec2 vTexCoord;\n      uniform float uTaps[".concat(t, "];\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        float sum = 1.0;\n        ").concat(e.map((t, e)=>"\n              color += texture2D(uTexture, vTexCoord + ".concat(t, ") * uTaps[").concat(e, "] + texture2D(uTexture, vTexCoord - ").concat(t, ") * uTaps[").concat(e, "];\n              sum += 2.0 * uTaps[").concat(e, "];\n            ")).join("\n"), "\n        gl_FragColor = color / sum;\n      }\n    ");
    }
    applyToForWebgl(t) {
        t.passes++, this.width = t.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = t.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t.destinationWidth = this.dW, super.applyTo(t), t.sourceWidth = t.destinationWidth, this.height = t.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t.destinationHeight = this.dH, super.applyTo(t), t.sourceHeight = t.destinationHeight;
    }
    applyTo(t) {
        Fa(t) ? this.applyToForWebgl(t) : this.applyTo2d(t);
    }
    isNeutralState() {
        return 1 === this.scaleX && 1 === this.scaleY;
    }
    lanczosCreate(t) {
        return (e)=>{
            if (e >= t || e <= -t) return 0;
            if (e < 1.1920929e-7 && e > -1.1920929e-7) return 1;
            const s = (e *= Math.PI) / t;
            return Math.sin(e) / e * Math.sin(s) / s;
        };
    }
    applyTo2d(t) {
        const e = t.imageData, s = this.scaleX, i = this.scaleY;
        this.rcpScaleX = 1 / s, this.rcpScaleY = 1 / i;
        const r = e.width, n = e.height, o = Math.round(r * s), a = Math.round(n * i);
        let h;
        h = "sliceHack" === this.resizeType ? this.sliceByTwo(t, r, n, o, a) : "hermite" === this.resizeType ? this.hermiteFastResize(t, r, n, o, a) : "bilinear" === this.resizeType ? this.bilinearFiltering(t, r, n, o, a) : "lanczos" === this.resizeType ? this.lanczosResize(t, r, n, o, a) : new ImageData(o, a), t.imageData = h;
    }
    sliceByTwo(t, e, s, i, r) {
        const n = t.imageData, o = .5;
        let a = !1, h = !1, c = e * o, l = s * o;
        const u = t.filterBackend.resources;
        let d = 0, g = 0;
        const f = e;
        let p = 0;
        u.sliceByTwo || (u.sliceByTwo = pt());
        const m = u.sliceByTwo;
        (m.width < 1.5 * e || m.height < s) && (m.width = 1.5 * e, m.height = s);
        const v = m.getContext("2d");
        for(v.clearRect(0, 0, 1.5 * e, s), v.putImageData(n, 0, 0), i = Math.floor(i), r = Math.floor(r); !a || !h;)e = c, s = l, i < Math.floor(c * o) ? c = Math.floor(c * o) : (c = i, a = !0), r < Math.floor(l * o) ? l = Math.floor(l * o) : (l = r, h = !0), v.drawImage(m, d, g, e, s, f, p, c, l), d = f, g = p, p += l;
        return v.getImageData(d, g, i, r);
    }
    lanczosResize(t, e, s, i, r) {
        const n = t.imageData.data, o = t.ctx.createImageData(i, r), a = o.data, h = this.lanczosCreate(this.lanczosLobes), c = this.rcpScaleX, l = this.rcpScaleY, u = 2 / this.rcpScaleX, d = 2 / this.rcpScaleY, g = Math.ceil(c * this.lanczosLobes / 2), f = Math.ceil(l * this.lanczosLobes / 2), p = {}, m = {
            x: 0,
            y: 0
        }, v = {
            x: 0,
            y: 0
        };
        return function t(y) {
            let _, x, C, b, S, w, T, O, k, D, M;
            for(m.x = (y + .5) * c, v.x = Math.floor(m.x), _ = 0; _ < r; _++){
                for(m.y = (_ + .5) * l, v.y = Math.floor(m.y), S = 0, w = 0, T = 0, O = 0, k = 0, x = v.x - g; x <= v.x + g; x++)if (!(x < 0 || x >= e)) {
                    D = Math.floor(1e3 * Math.abs(x - m.x)), p[D] || (p[D] = {});
                    for(let t = v.y - f; t <= v.y + f; t++)t < 0 || t >= s || (M = Math.floor(1e3 * Math.abs(t - m.y)), p[D][M] || (p[D][M] = h(Math.sqrt(Math.pow(D * u, 2) + Math.pow(M * d, 2)) / 1e3)), C = p[D][M], C > 0 && (b = 4 * (t * e + x), S += C, w += C * n[b], T += C * n[b + 1], O += C * n[b + 2], k += C * n[b + 3]));
                }
                b = 4 * (_ * i + y), a[b] = w / S, a[b + 1] = T / S, a[b + 2] = O / S, a[b + 3] = k / S;
            }
            return ++y < i ? t(y) : o;
        }(0);
    }
    bilinearFiltering(t, e, s, i, r) {
        let n, o, a, h, c, l, u, d, g, f, p, m, v, y = 0;
        const _ = this.rcpScaleX, x = this.rcpScaleY, C = 4 * (e - 1), b = t.imageData.data, S = t.ctx.createImageData(i, r), w = S.data;
        for(u = 0; u < r; u++)for(d = 0; d < i; d++)for(c = Math.floor(_ * d), l = Math.floor(x * u), g = _ * d - c, f = x * u - l, v = 4 * (l * e + c), p = 0; p < 4; p++)n = b[v + p], o = b[v + 4 + p], a = b[v + C + p], h = b[v + C + 4 + p], m = n * (1 - g) * (1 - f) + o * g * (1 - f) + a * f * (1 - g) + h * g * f, w[y++] = m;
        return S;
    }
    hermiteFastResize(t, e, s, i, r) {
        const n = this.rcpScaleX, o = this.rcpScaleY, a = Math.ceil(n / 2), h = Math.ceil(o / 2), c = t.imageData.data, l = t.ctx.createImageData(i, r), u = l.data;
        for(let t = 0; t < r; t++)for(let s = 0; s < i; s++){
            const r = 4 * (s + t * i);
            let l = 0, d = 0, g = 0, f = 0, p = 0, m = 0, v = 0;
            const y = (t + .5) * o;
            for(let i = Math.floor(t * o); i < (t + 1) * o; i++){
                const t = Math.abs(y - (i + .5)) / h, r = (s + .5) * n, o = t * t;
                for(let t = Math.floor(s * n); t < (s + 1) * n; t++){
                    let s = Math.abs(r - (t + .5)) / a;
                    const n = Math.sqrt(o + s * s);
                    n > 1 && n < -1 || (l = 2 * n * n * n - 3 * n * n + 1, l > 0 && (s = 4 * (t + i * e), v += l * c[s + 3], g += l, c[s + 3] < 255 && (l = l * c[s + 3] / 250), f += l * c[s], p += l * c[s + 1], m += l * c[s + 2], d += l));
                }
            }
            u[r] = f / d, u[r + 1] = p / d, u[r + 2] = m / d, u[r + 3] = v / g;
        }
        return l;
    }
}
t(_h, "type", "Resize"), t(_h, "defaults", {
    resizeType: "hermite",
    scaleX: 1,
    scaleY: 1,
    lanczosLobes: 3
}), t(_h, "uniformLocations", [
    "uDelta",
    "uTaps"
]), tt.setClass(_h);
class xh extends Wa {
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uSaturation;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float rgMax = max(color.r, color.g);\n    float rgbMax = max(rgMax, color.b);\n    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n    gl_FragColor = color;\n  }\n";
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = -this.saturation;
        for(let t = 0; t < e.length; t += 4){
            const i = e[t], r = e[t + 1], n = e[t + 2], o = Math.max(i, r, n);
            e[t] += o !== i ? (o - i) * s : 0, e[t + 1] += o !== r ? (o - r) * s : 0, e[t + 2] += o !== n ? (o - n) * s : 0;
        }
    }
    sendUniformData(t, e) {
        t.uniform1f(e.uSaturation, -this.saturation);
    }
    isNeutralState() {
        return 0 === this.saturation;
    }
}
t(xh, "type", "Saturation"), t(xh, "defaults", {
    saturation: 0
}), t(xh, "uniformLocations", [
    "uSaturation"
]), tt.setClass(xh);
class Ch extends Wa {
    getFragmentSource() {
        return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uVibrance;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float max = max(color.r, max(color.g, color.b));\n    float avg = (color.r + color.g + color.b) / 3.0;\n    float amt = (abs(max - avg) * 2.0) * uVibrance;\n    color.r += max != color.r ? (max - color.r) * amt : 0.00;\n    color.g += max != color.g ? (max - color.g) * amt : 0.00;\n    color.b += max != color.b ? (max - color.b) * amt : 0.00;\n    gl_FragColor = color;\n  }\n";
    }
    applyTo2d(t) {
        let { imageData: { data: e } } = t;
        const s = -this.vibrance;
        for(let t = 0; t < e.length; t += 4){
            const i = e[t], r = e[t + 1], n = e[t + 2], o = Math.max(i, r, n), a = (i + r + n) / 3, h = 2 * Math.abs(o - a) / 255 * s;
            e[t] += o !== i ? (o - i) * h : 0, e[t + 1] += o !== r ? (o - r) * h : 0, e[t + 2] += o !== n ? (o - n) * h : 0;
        }
    }
    sendUniformData(t, e) {
        t.uniform1f(e.uVibrance, -this.vibrance);
    }
    isNeutralState() {
        return 0 === this.vibrance;
    }
}
t(Ch, "type", "Vibrance"), t(Ch, "defaults", {
    vibrance: 0
}), t(Ch, "uniformLocations", [
    "uVibrance"
]), tt.setClass(Ch);
var bh = Object.freeze({
    __proto__: null,
    BaseFilter: Wa,
    BlackWhite: rh,
    BlendColor: za,
    BlendImage: Na,
    Blur: Ua,
    Brightness: qa,
    Brownie: Za,
    ColorMatrix: Ja,
    Composed: nh,
    Contrast: oh,
    Convolute: hh,
    Gamma: lh,
    Grayscale: dh,
    HueRotation: fh,
    Invert: ph,
    Kodachrome: th,
    Noise: mh,
    Pixelate: vh,
    Polaroid: sh,
    RemoveColor: yh,
    Resize: _h,
    Saturation: xh,
    Sepia: ih,
    Technicolor: eh,
    Vibrance: Ch,
    Vintage: $a
});
;
 //# sourceMappingURL=index.min.mjs.map
}),
"[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "hasA11yProp",
    ()=>hasA11yProp,
    "mergeClasses",
    ()=>mergeClasses,
    "toCamelCase",
    ()=>toCamelCase,
    "toKebabCase",
    ()=>toKebabCase,
    "toPascalCase",
    ()=>toPascalCase
]);
const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const toCamelCase = (string)=>string.replace(/^([A-Z])|[\s-_]+(\w)/g, (match, p1, p2)=>p2 ? p2.toUpperCase() : p1.toLowerCase());
const toPascalCase = (string)=>{
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
const mergeClasses = (...classes)=>classes.filter((className, index, array)=>{
        return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
    }).join(" ").trim();
const hasA11yProp = (props)=>{
    for(const prop in props){
        if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
            return true;
        }
    }
};
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>defaultAttributes
]);
var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
;
 //# sourceMappingURL=defaultAttributes.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>Icon
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
;
;
;
const Icon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ color = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, iconNode, ...rest }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])("svg", {
        ref,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])("lucide", className),
        ...!children && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasA11yProp"])(rest) && {
            "aria-hidden": "true"
        },
        ...rest
    }, [
        ...iconNode.map(([tag, attrs])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(tag, attrs)),
        ...Array.isArray(children) ? children : [
            children
        ]
    ]));
;
 //# sourceMappingURL=Icon.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>createLucideIcon
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)");
;
;
;
const createLucideIcon = (iconName, iconNode)=>{
    const Component = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ className, ...props }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"], {
            ref,
            iconNode,
            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])(`lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toKebabCase"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName))}`, `lucide-${iconName}`, className),
            ...props
        }));
    Component.displayName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName);
    return Component;
};
;
 //# sourceMappingURL=createLucideIcon.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/pencil.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Pencil
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
            key: "1a8usu"
        }
    ],
    [
        "path",
        {
            d: "m15 5 4 4",
            key: "1mk7zo"
        }
    ]
];
const Pencil = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("pencil", __iconNode);
;
 //# sourceMappingURL=pencil.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/pencil.js [app-ssr] (ecmascript) <export default as Pencil>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Pencil",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$pencil$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$pencil$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/pencil.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/hand.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Hand
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2",
            key: "1fvzgz"
        }
    ],
    [
        "path",
        {
            d: "M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2",
            key: "1kc0my"
        }
    ],
    [
        "path",
        {
            d: "M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8",
            key: "10h0bg"
        }
    ],
    [
        "path",
        {
            d: "M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15",
            key: "1s1gnw"
        }
    ]
];
const Hand = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("hand", __iconNode);
;
 //# sourceMappingURL=hand.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/hand.js [app-ssr] (ecmascript) <export default as Hand>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Hand",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$hand$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$hand$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/hand.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/undo-2.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Undo2
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M9 14 4 9l5-5",
            key: "102s5s"
        }
    ],
    [
        "path",
        {
            d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11",
            key: "f3b9sd"
        }
    ]
];
const Undo2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("undo-2", __iconNode);
;
 //# sourceMappingURL=undo-2.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/undo-2.js [app-ssr] (ecmascript) <export default as Undo2>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Undo2",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$undo$2d$2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$undo$2d$2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/undo-2.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/redo-2.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Redo2
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m15 14 5-5-5-5",
            key: "12vg1m"
        }
    ],
    [
        "path",
        {
            d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13",
            key: "6uklza"
        }
    ]
];
const Redo2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("redo-2", __iconNode);
;
 //# sourceMappingURL=redo-2.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/redo-2.js [app-ssr] (ecmascript) <export default as Redo2>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Redo2",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$redo$2d$2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$redo$2d$2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/redo-2.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/sparkles.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Sparkles
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
            key: "1s2grr"
        }
    ],
    [
        "path",
        {
            d: "M20 2v4",
            key: "1rf3ol"
        }
    ],
    [
        "path",
        {
            d: "M22 4h-4",
            key: "gwowj6"
        }
    ],
    [
        "circle",
        {
            cx: "4",
            cy: "20",
            r: "2",
            key: "6kqj1y"
        }
    ]
];
const Sparkles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("sparkles", __iconNode);
;
 //# sourceMappingURL=sparkles.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/sparkles.js [app-ssr] (ecmascript) <export default as Sparkles>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Sparkles",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$sparkles$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$sparkles$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/sparkles.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/monitor.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Monitor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "rect",
        {
            width: "20",
            height: "14",
            x: "2",
            y: "3",
            rx: "2",
            key: "48i651"
        }
    ],
    [
        "line",
        {
            x1: "8",
            x2: "16",
            y1: "21",
            y2: "21",
            key: "1svkeh"
        }
    ],
    [
        "line",
        {
            x1: "12",
            x2: "12",
            y1: "17",
            y2: "21",
            key: "vw1qmm"
        }
    ]
];
const Monitor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("monitor", __iconNode);
;
 //# sourceMappingURL=monitor.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/monitor.js [app-ssr] (ecmascript) <export default as Monitor>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Monitor",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$monitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$monitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/monitor.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/grid-3x3.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Grid3x3
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "rect",
        {
            width: "18",
            height: "18",
            x: "3",
            y: "3",
            rx: "2",
            key: "afitv7"
        }
    ],
    [
        "path",
        {
            d: "M3 9h18",
            key: "1pudct"
        }
    ],
    [
        "path",
        {
            d: "M3 15h18",
            key: "5xshup"
        }
    ],
    [
        "path",
        {
            d: "M9 3v18",
            key: "fh3hqa"
        }
    ],
    [
        "path",
        {
            d: "M15 3v18",
            key: "14nvp0"
        }
    ]
];
const Grid3x3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("grid-3x3", __iconNode);
;
 //# sourceMappingURL=grid-3x3.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/grid-3x3.js [app-ssr] (ecmascript) <export default as Grid>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Grid",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$grid$2d$3x3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$grid$2d$3x3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/grid-3x3.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/zoom-in.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ZoomIn
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "circle",
        {
            cx: "11",
            cy: "11",
            r: "8",
            key: "4ej97u"
        }
    ],
    [
        "line",
        {
            x1: "21",
            x2: "16.65",
            y1: "21",
            y2: "16.65",
            key: "13gj7c"
        }
    ],
    [
        "line",
        {
            x1: "11",
            x2: "11",
            y1: "8",
            y2: "14",
            key: "1vmskp"
        }
    ],
    [
        "line",
        {
            x1: "8",
            x2: "14",
            y1: "11",
            y2: "11",
            key: "durymu"
        }
    ]
];
const ZoomIn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("zoom-in", __iconNode);
;
 //# sourceMappingURL=zoom-in.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/zoom-in.js [app-ssr] (ecmascript) <export default as ZoomIn>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ZoomIn",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$zoom$2d$in$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$zoom$2d$in$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/zoom-in.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/zoom-out.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ZoomOut
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "circle",
        {
            cx: "11",
            cy: "11",
            r: "8",
            key: "4ej97u"
        }
    ],
    [
        "line",
        {
            x1: "21",
            x2: "16.65",
            y1: "21",
            y2: "16.65",
            key: "13gj7c"
        }
    ],
    [
        "line",
        {
            x1: "8",
            x2: "14",
            y1: "11",
            y2: "11",
            key: "durymu"
        }
    ]
];
const ZoomOut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("zoom-out", __iconNode);
;
 //# sourceMappingURL=zoom-out.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/zoom-out.js [app-ssr] (ecmascript) <export default as ZoomOut>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ZoomOut",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$zoom$2d$out$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$zoom$2d$out$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/zoom-out.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_c77815b2._.js.map